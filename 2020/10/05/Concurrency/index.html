<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jycoder.club","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="并发编程相比于Java中其他知识点的学习门槛要高很多，从而导致很多人望而却步，但无论是职场面试，还是高并发&#x2F;高流量系统的实现，却都离不开并发编程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="https://jycoder.club/2020/10/05/Concurrency/index.html">
<meta property="og:site_name" content="吉永超">
<meta property="og:description" content="并发编程相比于Java中其他知识点的学习门槛要高很多，从而导致很多人望而却步，但无论是职场面试，还是高并发&#x2F;高流量系统的实现，却都离不开并发编程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jycoder.club/2020/10/05/Concurrency/assets/1605541454922.png">
<meta property="og:image" content="https://jycoder.club/2020/10/05/Concurrency/assets/1605541658677.png">
<meta property="article:published_time" content="2020-10-04T16:00:00.000Z">
<meta property="article:modified_time" content="2021-07-16T11:03:27.655Z">
<meta property="article:author" content="吉永超">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jycoder.club/2020/10/05/Concurrency/assets/1605541454922.png">

<link rel="canonical" href="https://jycoder.club/2020/10/05/Concurrency/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发编程 | 吉永超</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吉永超</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/jiyongchao-qf" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jycoder.club/2020/10/05/Concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吉永超">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吉永超">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-05T00:00:00+08:00">2020-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-16 19:03:27" itemprop="dateModified" datetime="2021-07-16T19:03:27+08:00">2021-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>85k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:17</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>并发编程相比于Java中其他知识点的学习门槛要高很多，从而导致很多人望而却步，但无论是职场面试，还是高并发/高流量系统的实现，却都离不开并发编程。</p>
<span id="more"></span>
<p>全文大致共分为三个部分，第一部分为Java并发编程基础篇，主要讲解Java并发编程的基础知识、线程有关的知识和并发编程中的其他概念，这些知识在后续的章节中都会用到。第二部分为Java并发编程的高级篇，讲解Java并发包中的核心组件的实现原理。第三部分为Java并发编程实践篇，主要讲解并发组件的使用方法，以及一些注意事项。</p>
<p>本文主要结合张龙老师的视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qK4y1t78Z?from=search&seid=2031440298446612503">精通Java并发</a>，以及《Java并发编程之美》，系统而全面的介绍Java并发的方方面面。</p>
<h1 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h1><h2 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h2><p>在正式开始并发编程的基础内容的学习之前，有必要讨论两个核心的问题，第一是什么是并发编程，第二为什么要学习并发编程。</p>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><p>在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。<br>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程一个执行路径，一个<br>进程中至少有一个线程，进程中的多个线程共享进程的资源。</p>
<h2 id="Thread和Runnable"><a href="#Thread和Runnable" class="headerlink" title="Thread和Runnable"></a>Thread和Runnable</h2><p>Thread类和Runnable接口无疑是了解Java并发编程的入口，Thread类本身是实现了Runnable接口的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们来阅读以下Thread类的文档说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have </span><br><span class="line">multiple threads of execution running concurrently.</span><br></pre></td></tr></table></figure>

<p>一个thread指的是程序执行中的一个线程，Java虚拟机支持一个应用可以有多个并发执行的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Every thread has a priority. Threads with higher priority are executed in preference to threads with </span><br><span class="line">lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread </span><br><span class="line">creates a new Thread object, the new thread has its priority initially set equal to the priority of the </span><br><span class="line">creating thread, and is a daemon thread if and only if the creating thread is a daemon.</span><br></pre></td></tr></table></figure>

<p>每一个线程都会有一个优先级，拥有高优先级的线程在执行的时候就会比低优先级的线程优先级要高，每一个线程也可以被标记为daemon（后台线程），当运行在某一个线程中的代码创建了一个新的线程，默认情况下，新的线程的优先级会和创建它的线程优先级相同，并且只有创建它的线程是daemon线程时，新的线程才会是daemon。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls </span><br><span class="line">the method named main of some designated class). The Java Virtual Machine continues to execute threads </span><br><span class="line">until either of the following occurs:</span><br></pre></td></tr></table></figure>

<p>当Java虚拟机启动的时候，通常会有一个单个的、非daemon线程（通常情况会调用某一个被指定类的main方法），Java虚拟机会继续执行线程，直到下面的两种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The exit method of class Runtime has been called and the security manager has permitted the exit </span><br><span class="line">operation to take place.</span><br><span class="line">All threads that are not daemon threads have died, either by returning from the call to the run method or </span><br><span class="line">by throwing an exception that propagates beyond the run method.</span><br></pre></td></tr></table></figure>

<ul>
<li>类的Runtime方法被调用，并且安全管理器允许退出操作发生。</li>
<li>所有的非后台线程都已经消亡了，要么是通过run方法的调用返回了，要么是run方法外面抛出了异常。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">There are two ways to create a new thread of execution. One is to declare a class to be a subclass of </span><br><span class="line">Thread. This subclass should override the run method of class Thread. An instance of the subclass can </span><br><span class="line">then be allocated and started. For example, a thread that computes primes larger than a stated value </span><br><span class="line">could be written as follows:</span><br></pre></td></tr></table></figure>

<p>有两种方式来创建一个新的执行线程，一种是继承Thread类，这个子类应该重写Thread类的run方法，这个子类就可以创建实例并且执行，比如，一个线程计算大于某一个状态值的，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> minPrime;</span><br><span class="line">           PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">               <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">                . . .</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>如下代码将会生成线程并且使用start方法开始执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>

<p>接下来是另外一种创建线程的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The other way to create a thread is to declare a class that implements the Runnable interface. That class </span><br><span class="line">then implements the run method. An instance of the class can then be allocated, passed as an argument </span><br><span class="line">when creating Thread, and started. The same example in this other style looks like the following:</span><br></pre></td></tr></table></figure>

<p>另一种创建线程的方式就是声明一个类并且实现Runnable接口，在这个类实现了run方法之后，就可以创建实例。当创建Thread的时候把这个类作为一个参数传入并启动，相同的例子用这个方式来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> minPrime;</span><br><span class="line">          PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">              <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">               . . .</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>如下代码就会创建一个线程并执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Every thread has a name for identification purposes. More than one thread may have the same name. If a </span><br><span class="line">name is not specified when a thread is created, a new name is generated for it.</span><br><span class="line">Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a </span><br><span class="line">NullPointerException to be thrown.</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个名称用于标识，不同的线程可能会有相同的名称，如果创建线程的时候没有指定名称，就会产生一个新的名称，如无特别说明，将null参数传递给构造方法或者这个类的其他方法就会导致空指针异常。</p>
<p>这里用到了start方法来启动线程，我们来阅读以下start方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread.</span><br><span class="line">The result is that two threads are running concurrently: the current thread (which returns from the call </span><br><span class="line">to the start method) and the other thread (which executes its run method).</span><br><span class="line">It is never legal to start a thread more than once. In particular, a thread may not be restarted once it</span><br><span class="line">has completed execution.</span><br></pre></td></tr></table></figure>

<p>当调用了start方法意味这个这个线程开始执行了，Java虚拟机会调用这个线程的run方法，结果是当前线程（调用start方法所返回的线程）和另外一个线程（执行run方法的线程）会并发的运行，多次启动一个线程是不合法的，特别的，一个线程已经执行完成之后不可以被重新启动。</p>
<p>Runnable接口本身是一个函数式接口，里面有且仅有一个抽象方法run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们阅读以下Runnable接口的文档说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The Runnable interface should be implemented by any class whose instances are intended to be executed by </span><br><span class="line">a thread. The class must define a method of no arguments called run.</span><br><span class="line">This interface is designed to provide a common protocol for objects that wish to execute code while they </span><br><span class="line">are active. For example, Runnable is implemented by class Thread. Being active simply means that a thread </span><br><span class="line">has been started and has not yet been stopped.</span><br></pre></td></tr></table></figure>

<p>任何一个执行线程的类都应该实现Runnable接口，这个类必须定义一个无参的run方法。设计这个接口是为了，给执行处在激活状态的代码的时候，提供一种公共的协议，比如说，Runnable是被Thread类所实现出来了。处于激活状态表示一个线程被启动了，而且没有停止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In addition, Runnable provides the means for a class to be active while not subclassing Thread. A class </span><br><span class="line">that implements Runnable can run without subclassing Thread by instantiating a Thread instance and </span><br><span class="line">passing itself in as the target. In most cases, the Runnable interface should be used if you are only </span><br><span class="line">planning to override the run() method and no other Thread methods. This is important because classes </span><br><span class="line">should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior</span><br><span class="line">of the class.</span><br></pre></td></tr></table></figure>

<p>此外，Runnable提供了让一个类处在激活状态同时又没有子类化的方式，一个类实现了Runnable可以不用通过子类化来运行，这是通过初始化一个Thread实例，然后将它自己作为目标传入，如果你只是计划重写run方法，而不打算重写Thread类其他的方法，一般情况下，都应该使用Runnable，这是非常重要的，除非程序员打算增强或修改一些基础的行为，因为类不应该被子类化。</p>
<p>接下来我们阅读以下run方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When an object implementing interface Runnable is used to create a thread, starting the thread causes the </span><br><span class="line">object&#x27;s run method to be called in that separately executing thread.</span><br><span class="line">The general contract of the method run is that it may take any action whatsoever.</span><br></pre></td></tr></table></figure>

<p>当使用实现了Runnable接口的对象创建了一个线程，启动这个线程，就会在单独执行的线程上执行这个类的run方法，run方法一种通用的锲约是它可以接口任何的动作。</p>
<p>同样的在Thread类中也有一个run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If this thread was constructed using a separate Runnable run object, then that Runnable object&#x27;s run </span><br><span class="line">method is called; otherwise, this method does nothing and returns.</span><br><span class="line">Subclasses of Thread should override this method.</span><br></pre></td></tr></table></figure>

<p>如果这个线程是通过单独的Runnable接口对象来构建的话，那么Runnable对象的run方法就会被调用，否则，这个方法什么都不做，直接返回。Thread的子类应该重写这个方法。</p>
<p>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// private Runnable target;</span></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread类的run方法会判断本地的Runnable对象是否已经被赋值，如果已经赋值了就执行里面的run方法。</p>
<p>Thread类的构造方法都会调用init方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先了解以下这个init方法，方法的参数说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程组</span></span><br><span class="line">g – the Thread group</span><br><span class="line"><span class="comment">// 这个对象的run将会被调用</span></span><br><span class="line">target – the object whose run将会被调用() method gets called</span><br><span class="line"><span class="comment">// 新创建的线程的名称</span></span><br><span class="line">name – the name of the <span class="keyword">new</span> Thread</span><br><span class="line"><span class="comment">// 新的线程所需要的栈的大小，0表示这个参数会忽略掉</span></span><br><span class="line">stackSize – the desired stack size <span class="keyword">for</span> the <span class="keyword">new</span> thread, or zero to indicate that <span class="keyword">this</span> parameter is to be ignored.</span><br></pre></td></tr></table></figure>

<h2 id="wait、sleep和notify"><a href="#wait、sleep和notify" class="headerlink" title="wait、sleep和notify"></a>wait、sleep和notify</h2><h3 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h3><p>在Object类中有几个与线程相关的方法：notify、notifyAll、wait，这几个方法非常的重要，接下来我们分析一下这个几个方法，首先从wait方法开始，wait方法又有几个重载的方法，首先来看不带参数的wait方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() </span><br><span class="line">method for this object. In other words, this method behaves exactly as if it simply performs the call </span><br><span class="line">wait(0).</span><br></pre></td></tr></table></figure>

<p>wait方法会导致当前的线程进入等待状态，直到另外一个线程调用了这个对象的notify或者notifyAll方法，换言之，这个方法的行为是与wait(0)是等价的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The current thread must own this object&#x27;s monitor. The thread releases ownership of this monitor and </span><br><span class="line">waits until another thread notifies threads waiting on this object&#x27;s monitor to wake up either through a </span><br><span class="line">call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership</span><br><span class="line">of the monitor and resumes execution.</span><br><span class="line">As in the one argument version, interrupts and spurious wakeups are possible, and this method should </span><br><span class="line">always be used in a loop:</span><br></pre></td></tr></table></figure>

<p>要调用当前对象wait方法，当前线程必须要拥有这个对象的锁，这个线程在调用了wait方法之后，就会释放掉锁的控制权，并且进行等待，直到另外的线程通知在这个锁上等待的所有线程。唤醒的方式要么是通过notify方法或者是notifyAll方法。接下来，这个线程还是会继续等待，直到它可以重新获取锁的有用权，并且恢复执行。对于一个参数的版本来说，终端和一些虚假的唤醒是可能发生的，这个方法应该只在循环当中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">               <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                   obj.wait();</span><br><span class="line">               ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify </span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法应该只是被拥有了这个对象的锁的线程去调用，参考notify方法来查看什么情况下，一个线程可以成为锁的拥有者。</p>
<p>如果没有锁直接调用wait方法会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序就会直接抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br></pre></td></tr></table></figure>

<p>按照给出的示例，我们将程序改写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            object.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序并没有抛出异常，而是进入进入了一直等待的状态。在Thread类中有一个sleep方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of</span><br><span class="line">milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not </span><br><span class="line">lose ownership of any monitors.</span><br></pre></td></tr></table></figure>

<p>它会导致当前正在执行的线程进入到休眠的状态（临时的终止执行）一段指定的毫秒数，它会收到系统定时器和调度器的精度的限制，线程并不会失去任何锁的所有权。</p>
<p>这里其实就是wait方法和sleep方法的最明显的区别，调用wait方法之前，线程必须持有对象的锁，在调用wait方法之后，线程就会释放锁，而sleep方法则不会释放掉锁。</p>
<p>前面我们提到过，不带参数的wait方法会调用他的重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait方法本身又有两个重载的方法，我们首先来阅读一下只有一个参数的相关文档：</p>
<p>首先是方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Causes the current thread to wait until either another thread invokes the notify() method or the </span><br><span class="line">notifyAll() method for this object, or a specified amount of time has elapsed.</span><br><span class="line">The current thread must own this object&#x27;s monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法会让当前的线程进入等待状态，除非对当前这个对象使用notify或者notifyAll方法，或者已经到了指定的超时时间，当前对象必须要拥有当前对象的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This method causes the current thread (call it T) to place itself in the wait set for this object and </span><br><span class="line">then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for </span><br><span class="line">thread scheduling purposes and lies dormant until one of four things happens:</span><br></pre></td></tr></table></figure>

<p>这个方法会导致当前的线程（T），将它自身放置到一个这个对象的等待集合当中，然后放弃任何同步的声明，线程T将无法再进行调度，处在休眠状态，直到下面的四种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen</span><br><span class="line">as the thread to be awakened.</span><br><span class="line">Some other thread invokes the notifyAll method for this object.</span><br><span class="line">Some other thread interrupts thread T.</span><br><span class="line">The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time</span><br><span class="line">is not taken into consideration and the thread simply waits until notified.</span><br></pre></td></tr></table></figure>

<ul>
<li>另外一个线程调用了这个对象的notify方法，当前的线程T碰巧是要被选择唤醒的线程；</li>
<li>其他的线程调用了这个对象的notifyAll方法；</li>
<li>其他的线程中断了T线程</li>
<li>指定的时间已经过去了，不过如果时间设置为0的话，线程会一直进入等待直到被通知，而不会再去计算时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It </span><br><span class="line">then competes in the usual manner with other threads for the right to synchronize on the object; once it </span><br><span class="line">has gained control of the object, all its synchronization claims on the object are restored to the status </span><br><span class="line">quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then </span><br><span class="line">returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization </span><br><span class="line">state of the object and of thread T is exactly as it was when the wait method was invoked.</span><br></pre></td></tr></table></figure>

<p>接下来线程T会从对象等待集合中移除掉，然后，重新又可以进行线程的调度了。它会按照通常的方式与其他的线程竞争对于对象的同步权，一旦获得了对象的同步权，所有它的对这个对象同步的声明又会恢复到之前的同步声明状态，也就是说恢复到wait方法被调用的时候所处的状态，接下来线程T就会从wait方法的调用当中去返回，返回的时候，对象的同步状态以及线程T的同步状态与wait方法被调用的时候的状态是一模一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious </span><br><span class="line">wakeup. While this will rarely occur in practice, applications must guard against it by testing for the </span><br><span class="line">condition that should have caused the thread to be awakened, and continuing to wait if the condition is </span><br><span class="line">not satisfied. In other words, waits should always occur in loops, like this one:</span><br></pre></td></tr></table></figure>

<p>一个线程还可以被唤醒无需被通知、中断或者超时，这个称之为虚假的唤醒，虽然这种实际情况下很少发生，但是应用还是应该通过测试条件保证这一点，并且如果条件没有被满足的时候就持续处于等待状态，换句话说，等待总是应该发生在循环当中，就向下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">              <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                  obj.wait(timeout);</span><br><span class="line">              ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If the current thread is interrupted by any thread before or while it is waiting, then an </span><br><span class="line">InterruptedException is thrown. This exception is not thrown until the lock status of this object has </span><br><span class="line">been restored as described above.</span><br></pre></td></tr></table></figure>

<p>如果当前的线程被别的线程在它等待之前或等待当中的时候被中断了，这个锁状态恢复之后才会被正常的抛出InterruptedException异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note that the wait method, as it places the current thread into the wait set for this object, unlocks </span><br><span class="line">only this object; any other objects on which the current thread may be synchronized remain locked while </span><br><span class="line">the thread waits.</span><br></pre></td></tr></table></figure>

<p>wait方法会将当前的线程放置到它的等待的对象集合当中，只会解锁当前的对象，当这个线程等待的时候，任何其它的对象对象可能会依然处于锁定的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify </span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法应该只被持有对象锁的线程所调用，请查看notify方法来查看如何让一个线程成为锁的拥有者。</p>
<p>接下来我们查看wait方法另外一个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 底层实现还是调用wait(long timeout)方法</span></span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait方法和notify方法总是成对出现的，notify方法也是一个native方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们来了解一下notify方法的作用：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wakes up a single thread that is waiting on this object&#x27;s monitor. If any threads are waiting on this </span><br><span class="line">object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the</span><br><span class="line">implementation. A thread waits on an object&#x27;s monitor by calling one of the wait methods.</span><br></pre></td></tr></table></figure>

<p>它会唤醒正在等待这个对象的锁的单个线程，如果有多个线程都在等待这个对象的锁，那么就会选择其中的一个进行唤醒，选择是随机的，并且是根据实现来决定的，一个线程会通过调用某一个wait方法进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The awakened thread will not be able to proceed until the current thread relinquishes the lock on this</span><br><span class="line">object. The awakened thread will compete in the usual manner with any other threads that might be </span><br><span class="line">actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable</span><br><span class="line">privilege or disadvantage in being the next thread to lock this object.</span><br><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. A thread  </span><br><span class="line">becomes the owner of the object&#x27;s monitor in one of three ways:    </span><br></pre></td></tr></table></figure>

<p>被唤醒的线程是无法执行的，直到当前的线程放弃了这个对象的锁，被唤醒的线程会按照常规的方式与其他的线程进行对象同步的竞争，比如说，被唤醒的线程它是没有任何的特权，也没有任何不足的地方，都有可能会获得当前对象的锁。notify方法只能被这个对象的持有者来进行调用，一个线程获取对象锁有以下三种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">By executing a synchronized instance method of that object.</span><br><span class="line">By executing the body of a synchronized statement that synchronizes on the object.</span><br><span class="line">For objects of type Class, by executing a synchronized static method of that class.</span><br></pre></td></tr></table></figure>

<ul>
<li>通过执行对象的synchronized实例方法来获取</li>
<li>通过执行这个对象的synchronized语句块来获取</li>
<li>对于Class类型的对象，通过执行这个class中synchronized静态方法来获取</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Only one thread at a time can own an object&#x27;s monitor.  </span><br></pre></td></tr></table></figure>

<p>在某一个时刻只有一个线程拥有一个对象的锁。</p>
<p>同样的，notifyAll方法也是一个本地方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wakes up all threads that are waiting on this object&#x27;s monitor. A thread waits on an object&#x27;s monitor by</span><br><span class="line">calling one of the wait methods.</span><br></pre></td></tr></table></figure>

<p>notifyAll方法会唤醒在这个对象的锁上等待的所有的线程，线程可以通过调用这个对象的wait方法等待这个对象的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The awakened threads will not be able to proceed until the current thread relinquishes the lock on this </span><br><span class="line">object. The awakened threads will compete in the usual manner with any other threads that might be </span><br><span class="line">actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable </span><br><span class="line">privilege or disadvantage in being the next thread to lock this object.</span><br></pre></td></tr></table></figure>

<p>被唤醒的线程只有在当前对象释放掉锁的时候才能继续执行，它会按照通常的方式与其他的线程竞争对象的同步，既没有什么特权，也没有什么缺陷，都有可能是下一个给当前对象上锁的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify</span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法只能被持有锁的对象锁调用，查看notify方法获取对象锁的方式。</p>
<p>我们可以用一张表格来总结以下wait、notify、notifyAll方法的区别：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wait</td>
<td align="center">1、当调用wait方法时，首先需要确保wait方法的线程已经持有了对象的锁<br>2、当调用wait后，该线程会释放掉这个对象的锁，然后进入到等待状态（wait set）<br>3、当线程调用了wait后进入等待状态时，它就可以等待线程调用相同对象的notify和notifyAll方法来使得自己被唤醒<br>4、一旦这个线程被其他线程唤醒后，该线程就会与其他线程一同开始竞争这个对象的锁（公平竞争）；只有当该线程获取到了这个对象的锁后，线程才会继续往下执行<br>5、调用wait方法的代码片段需要放在synchronize代码块或者synchronized方法中，这样才可以确保线程在调用wait方法前已经获取到了对象的锁</td>
</tr>
<tr>
<td align="center">notify</td>
<td align="center">1、当调用对象的notify方法时，它会随机唤醒该对象等待集合（wait set）中的任意一个线程，当某个线程被唤醒后，它就会与其他线程一同竞争对象的锁<br>2、在某一时刻只有唯一一个线程可以拥有对象的锁</td>
</tr>
<tr>
<td align="center">notifyAll</td>
<td align="center">1、当调用对象的notifyAll方法时，它会唤醒该对象集合（wait set）中所有的线程，这些线程被唤醒后，又会开始竞争对象的锁</td>
</tr>
</tbody></table>
<h3 id="方法实践"><a href="#方法实践" class="headerlink" title="方法实践"></a>方法实践</h3><p>我们来看一个需要运用并发编程的实际的需求：</p>
<p> 1、存在一个对象，该对象有个int类型的成员变量counter，该成员变量的初始值为0；</p>
<p>2、创建两个线程，其中一个线程对该对象的成员变量counter加1，另一个线程对该对象的成员变量减1；</p>
<p>3、输出该对象成员变量counter每次变化后的值；</p>
<p>4、最终输出的结果应为：1010101010…。</p>
<p>首先是我们需要操作的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要操作的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter--;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加的线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyObject myObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncreaseThread</span><span class="params">(MyObject myObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myObject = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             myObject.increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减少的线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyObject myObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecreaseThread</span><span class="params">(MyObject myObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myObject = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            myObject.decrease();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用客户端来进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        <span class="comment">// 这里先启动哪个线程结果都是相同的</span></span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序也正如我们所愿，输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :client.main()</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>接下来我们尝试创建多个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread increaseThread2 = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread2 = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        increaseThread.start();</span><br><span class="line">        increaseThread2.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">        decreaseThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :client.main()</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line">-2</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line">-4</span><br></pre></td></tr></table></figure>

<p>可以看到这个时候，输入的结果其实已经是没有规律的了。这是因为在之前只有两个线程的时候，调用notify方法一定会唤醒唯一的另外一个方法，而在上面的这个例子中，被唤醒的线程实际上是随机的。</p>
<p>为了避免这种情况的发生，我们应该使用while来进行判断，而不是使用if：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (counter != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter--;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized详解"><a href="#synchronized详解" class="headerlink" title="synchronized详解"></a>synchronized详解</h2><h3 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h3><p>我们首先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 传入的是同一个Runnable实例，都可以访问到成员变量x</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;result: &quot;</span> + x++);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个程序，实际上每次输出的结果都是不相同的，这两个线程实际上共享了成员变量x，如果一个对象有可以被修改的成员变量，我们就认为这个对象是可变的对象，或者称之为有状态的，反之，如果一个对象没有被修改的成员变量，那么我们称这个对象是无状态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread1(myClass);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread2(myClass);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">700</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">400</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyClass myClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myClass.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass myClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myClass.world();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :MyThreadTest2.main()</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>如果一个对象有若个synchronized方法，在某一个时刻只会有唯一的一个synchronized方法会被某一个线程访问，原因就在于当前对象的锁只有一个。当方法是static的时候，获取的锁不再是当前对象的锁，而是当前对象的Class的锁。</p>
<h3 id="synchronized字节码分析"><a href="#synchronized字节码分析" class="headerlink" title="synchronized字节码分析"></a>synchronized字节码分析</h3><p>synchronized关键字一般来说可以作用在代码块和方法当中，当作用在代码块的中的时候，一般会使用如下的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到object对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令进行反编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c MyTest2.class</span><br></pre></td></tr></table></figure>

<p>反编译的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrency2</span>.<span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="comment">// 获取当前对象的成员变量</span></span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="comment">// 锁进入</span></span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="comment">// 开始执行代码</span></span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">15</span>: aload_1</span><br><span class="line">      <span class="comment">// 锁退出</span></span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: goto          <span class="number">25</span></span><br><span class="line">      <span class="number">20</span>: astore_2</span><br><span class="line">      <span class="number">21</span>: aload_1</span><br><span class="line">      <span class="comment">// 处理异常退出锁的释放</span></span><br><span class="line">      <span class="number">22</span>: monitorexit</span><br><span class="line">      <span class="number">23</span>: aload_2</span><br><span class="line">      <span class="number">24</span>: athrow</span><br><span class="line">      <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">17</span>    <span class="number">20</span>   any</span><br><span class="line">          <span class="number">20</span>    <span class="number">23</span>    <span class="number">20</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个monitorexit的原因是，无论代码执行是否抛出了异常，都会释放掉锁的对象，这部分是由Java编译器所做的工作。</p>
<p>当我们使用synchronized关键字来修饰代码块时，字节码层面上是通过monitor与monitorexit指令来实现的锁的获取与释放动作，一个monitor可能对应一个或者多个monitorexit，为了说明这一点，我们修改一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到object对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候反编译字节码就会得到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrency2</span>.<span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">new</span>           #<span class="number">7</span>                  <span class="comment">// class java/lang/RuntimeException</span></span><br><span class="line">      <span class="number">18</span>: dup</span><br><span class="line">      <span class="comment">// RuntimeException的构造方法</span></span><br><span class="line">      <span class="number">19</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: astore_2</span><br><span class="line">      <span class="number">24</span>: aload_1</span><br><span class="line">      <span class="number">25</span>: monitorexit</span><br><span class="line">      <span class="number">26</span>: aload_2</span><br><span class="line">      <span class="number">27</span>: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">26</span>    <span class="number">23</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么只有一个monitorexit呢？因为程序的出口只有一种，或者说程序运行的最终结果一定会抛出异常，这个时候athrow是一定会执行的，因此只有唯一的一个monitorexit。</p>
<p>当线程进入到monitorenter指令后，线程将会持有Monitor对象，退出monitorenter指令后，线程将会释放Moniter对象。</p>
<p>synchronized关键字除了可以作用在代码块上，还可以作用在方法上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样反编译之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;                                                                                                         </span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest3();                                                                          </span><br><span class="line">    descriptor: ()V                                                                                       </span><br><span class="line">    flags: ACC_PUBLIC                                                                                     </span><br><span class="line">    Code:                                                                                                 </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                      </span><br><span class="line">         <span class="number">0</span>: aload_0                                                                                       </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V                     </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>                                                                                        </span><br><span class="line">      LineNumberTable:                                                                                    </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span>                                                                                         </span><br><span class="line">      LocalVariableTable:                                                                                 </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                             </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest3;                                                </span><br><span class="line">                                                                                                          </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;                                                                      </span><br><span class="line">    descriptor: ()V                                                                                       	<span class="comment">// ACC_SYNCHRONIZED表示这是一个synchronized方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED                                                                   </span><br><span class="line">    Code:                                                                                                 	<span class="comment">//默认情况下参数的长度为1，是因为传入了当前对象</span></span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                      </span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;         </span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world                                       </span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V </span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span>                                                                                        </span><br><span class="line">      LineNumberTable:                                                                                    </span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span>                                                                                        </span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span>                                                                                        </span><br><span class="line">      LocalVariableTable:                                                                                 </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                             </span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest3;                                                </span><br><span class="line">&#125;                                                                                                       </span><br></pre></td></tr></table></figure>

<p>synchronized关键字修饰方法与代码块不同的地方是，并没有通过monitorenter与monitorexit指令来描述，而是使用ACC_SYNCHRONIZED表示该方法被synchronized修饰。当方法被调用的时候，JVM会检查该方法是否拥有ACC_SYNCHRONIZED标志，如果有，那么执行线程将会持有方法所在的Monitor对象，然后再去执行方法体，在该方法执行期间，其他线程均无法再获取到这个Monitor对象，当线程执行完该方法后，它会释放掉这个Monitor对象。</p>
<p>synchronized关键字还有可能作用在静态方法上面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;                                                                                                          </span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest4();                                                                           </span><br><span class="line">    descriptor: ()V                                                                                        </span><br><span class="line">    flags: ACC_PUBLIC                                                                                      </span><br><span class="line">    Code:                                                                                                  </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                       </span><br><span class="line">         <span class="number">0</span>: aload_0                                                                                        </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V                      </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>                                                                                         </span><br><span class="line">      LineNumberTable:                                                                                     </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span>                                                                                          </span><br><span class="line">      LocalVariableTable:                                                                                  </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                              </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest4;                                                 </span><br><span class="line">                                                                                                           </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;                                                                </span><br><span class="line">    descriptor: ()V</span><br><span class="line">    <span class="comment">//  ACC_STATIC表示静态的同步方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED                                                        </span><br><span class="line">    Code:                                                                                                  </span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span>                                                                       </span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;          </span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world                                        </span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V  </span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span>                                                                                         </span><br><span class="line">      LineNumberTable:                                                                                     </span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span>                                                                                         </span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span>                                                                                         </span><br><span class="line">&#125;                                                                                                          </span><br></pre></td></tr></table></figure>

<p>可以看到无论是修改实例方法还是静态方法，都是通过ACC_SYNCHRONIZED来实现的，静态方法还会增加ACC_STATIC来表示是静态方法。</p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><h3 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h3><p>JVM中的同步是基于进入与退出监视器对象（管程对象）（Monitor）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象会和Java对象一同创建，一同销毁，Monitor对象是由C++来实现的。</p>
<p>当多个线程同时访问一段同步代码时，这些线程会被方法一个EntryList集合当中，处于阻塞状态的线程都会被方法该列表中。接下来，当线程获取到对象的Monitor时，Monitor是依赖于底层操作系统的mutex lock（互斥锁）来实现互斥的，线程获取mutex成功，则会持有mutex，这时其他线程就无法再获取到该mutex。</p>
<p>如果线程调用了wait方法，那么该线程就会释放掉所持有的mutex，并且该线程会进入到WaitSet集合（等待集合）中，等待下一次被其他线程调用notify/notifyAll唤醒。如果当前线程顺利执行完毕方法，那么它也会释放掉所持有的mutex。</p>
<p>同步锁再这种实现方式当中，因为Monitor是依赖于底层的操作系统实现，因此存在用户态与内核态之间的切换，所以会增加性能开销，通过对象互斥锁的概念来保证共享数据操作的完整性。每个对象都对应于一个可称为互斥锁的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象。</p>
<p>那些处于EntryList与WaitSet中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在linux下是通过pthread_ mutex_lock函数实现的。线程被阻塞之后便会进入到内核调度方法，这会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。</p>
<p>解决上述问题的办法便是自旋（Spin），其原理是：当发生对Monitor的争用时，如果Owner能够在很短的时间内释放掉锁，则那些正在争用的线程就是稍微等待一下（即自旋），在Owner线程释放锁之后，争用线程就有可能会立刻获取到锁，从而避免了系统阻塞。不过，当Owner运行的时间超过了临界值后，争用线程自旋一段时间后依然无法获取到锁，这时争用线程则会停止自旋进入到阻塞状态，所的来说：先自旋，不成功再进入阻塞状态，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有极大的性能提升。显然，自旋在多核心处理器上才有意义。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁的属性：</p>
<ol>
<li>PTHREAD_MUTEX_TIME_NP：这是缺省值，也就是普通锁，当一个线程加锁以后，其余请求锁的线程将会形成一个等待队列，并且在解锁后按照优先级获取到锁。这种策略可以确保资源分配的公平性。</li>
<li>PTHREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许一个线程对同一个锁成功获取多次，并且通过unlock解锁，如果是不同线程请求，则在加锁线程解锁时重新进行竞争。</li>
<li>PTHREAD_MUTEX_ERRORCHECK_NP：检错锁，如果一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIME_NP类型相同，这样就保证了当不允许多次加锁时出现最简单情况下的死锁。</li>
<li>PTHREAD_MUTEX_ADAPTIVE_NP：适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争。</li>
</ol>
<h3 id="Monitor源码分析"><a href="#Monitor源码分析" class="headerlink" title="Monitor源码分析"></a>Monitor源码分析</h3><p>接下来我们通过<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/73f624a2488d/src/share/vm/runtime">openjdk</a>的源代码来分析Monitor底层的实现。</p>
<p>objectMonitor.hpp（头文件）和objectMonitor.cpp（具体的实现）这两个文件是关于Monitor的底层实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARE_VM_RUNTIME_OBJECTMONITOR_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHARE_VM_RUNTIME_OBJECTMONITOR_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/os.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/park.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/perfData.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞在当前的Monitor上的线程的封装，是一种链表的结构：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span> :</span> <span class="keyword">public</span> StackObj &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">TStates</span> &#123;</span> TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ &#125; ;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Sorted</span>  &#123;</span> PREPEND, APPEND, SORTED &#125; ;</span><br><span class="line">  <span class="comment">// 前一个ObjectWaiter</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _next;</span><br><span class="line">  <span class="comment">// 后一个ObjectWaiter</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _prev;</span><br><span class="line">  Thread*       _thread;</span><br><span class="line">  jlong         _notifier_tid;</span><br><span class="line">  ParkEvent *   _event;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span>  _notified ;</span><br><span class="line">  <span class="keyword">volatile</span> TStates TState ;</span><br><span class="line">  Sorted        _Sorted ;           <span class="comment">// List placement disposition</span></span><br><span class="line">  <span class="keyword">bool</span>          _active ;           <span class="comment">// Contention monitoring is enabled</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ObjectWaiter</span>(Thread* thread);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_begin</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_end</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectMonitor</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    OM_OK,                    <span class="comment">// no error</span></span><br><span class="line">    OM_SYSTEM_ERROR,          <span class="comment">// operating system error</span></span><br><span class="line">    OM_ILLEGAL_MONITOR_STATE, <span class="comment">// IllegalMonitorStateException</span></span><br><span class="line">    OM_INTERRUPTED,           <span class="comment">// Thread.interrupt()</span></span><br><span class="line">    OM_TIMED_OUT              <span class="comment">// Object.wait() timed out</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_offset_in_bytes</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _header);     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">object_offset_in_bytes</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _object);     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">owner_offset_in_bytes</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _owner);      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count_offset_in_bytes</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _count);      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursions_offset_in_bytes</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _recursions); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cxq_offset_in_bytes</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _cxq) ;       &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">succ_offset_in_bytes</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _succ) ;      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">EntryList_offset_in_bytes</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _EntryList);  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FreeNext_offset_in_bytes</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, FreeNext);    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">WaitSet_offset_in_bytes</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _WaitSet) ;   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Responsible_offset_in_bytes</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _Responsible);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Spinner_offset_in_bytes</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _Spinner);    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*SpinCallbackFunction)</span><span class="params">(<span class="keyword">intptr_t</span>, <span class="keyword">int</span>)</span> </span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">intptr_t</span> SpinCallbackArgument ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">markOop   <span class="title">header</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_header</span><span class="params">(markOop hdr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span> <span class="title">is_busy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _count|_waiters|<span class="built_in">intptr_t</span>(_owner)|<span class="built_in">intptr_t</span>(_cxq)|<span class="built_in">intptr_t</span>(_EntryList ) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">is_entered</span><span class="params">(Thread* current)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">owner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_owner</span><span class="params">(<span class="keyword">void</span>* owner)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">waiters</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_count</span><span class="params">(<span class="keyword">intptr_t</span> count)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">contentions</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">recursions</span><span class="params">()</span> <span class="keyword">const</span>                                         </span>&#123; <span class="keyword">return</span> _recursions; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JVM/DI GetMonitorInfo() needs this</span></span><br><span class="line">  <span class="function">ObjectWaiter* <span class="title">first_waiter</span><span class="params">()</span>                                         </span>&#123; <span class="keyword">return</span> _WaitSet; &#125;</span><br><span class="line">  <span class="function">ObjectWaiter* <span class="title">next_waiter</span><span class="params">(ObjectWaiter* o)</span>                           </span>&#123; <span class="keyword">return</span> o-&gt;_next; &#125;</span><br><span class="line">  <span class="function">Thread* <span class="title">thread_of_waiter</span><span class="params">(ObjectWaiter* o)</span>                            </span>&#123; <span class="keyword">return</span> o-&gt;_thread; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化Monitor对象，除了semaphore都是简单的对象或者指针</span></span><br><span class="line">  <span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 等待集合</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">     <span class="comment">// 等待集合</span></span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> Add asserts ...</span></span><br><span class="line">   <span class="comment">// _cxq == 0 _succ == NULL _owner == NULL _waiters == 0</span></span><br><span class="line">   <span class="comment">// _count == 0 _EntryList  == NULL etc</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Recycle</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add stronger asserts ...</span></span><br><span class="line">    <span class="comment">// _cxq == 0 _succ == NULL _owner == NULL _waiters == 0</span></span><br><span class="line">    <span class="comment">// _count == 0 EntryList  == NULL</span></span><br><span class="line">    <span class="comment">// _recursions == 0 _WaitSet == NULL</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> assert (is_busy()|_recursions) == 0</span></span><br><span class="line">    _succ          = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList     = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq           = <span class="literal">NULL</span> ;</span><br><span class="line">    _WaitSet       = <span class="literal">NULL</span> ;</span><br><span class="line">    _recursions    = <span class="number">0</span> ;</span><br><span class="line">    _SpinFreq      = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock     = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread  = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">object</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">object_addr</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_object</span><span class="params">(<span class="keyword">void</span>* obj)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">check</span><span class="params">(TRAPS)</span></span>;       <span class="comment">// true if the thread owns the monitor.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">check_slow</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sanity_checks</span><span class="params">()</span></span>;  <span class="comment">// public for -XX:+ExecuteInternalVMTests</span></span><br><span class="line">                                <span class="comment">// in PRODUCT for -XX:SyncKnobs=Verbose=1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">verify</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">try_enter</span> <span class="params">(TRAPS)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">enter</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">wait</span><span class="params">(jlong millis, <span class="keyword">bool</span> interruptable, TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notify</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notifyAll</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the following at your own risk</span></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">complete_exit</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">reenter</span><span class="params">(<span class="keyword">intptr_t</span> recursions, TRAPS)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">AddWaiter</span> <span class="params">(ObjectWaiter * waiter)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span>    <span class="keyword">void</span> <span class="title">DeferredInitialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ObjectWaiter * <span class="title">DequeueWaiter</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">DequeueSpecificWaiter</span> <span class="params">(ObjectWaiter * waiter)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">EnterI</span> <span class="params">(TRAPS)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ReenterI</span> <span class="params">(Thread * Self, ObjectWaiter * SelfNode)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">UnlinkAfterAcquire</span> <span class="params">(Thread * Self, ObjectWaiter * SelfNode)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TryLock</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">NotRunnable</span> <span class="params">(Thread * Self, Thread * Owner)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_Fixed</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_VaryFrequency</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_VaryDuration</span>  <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ctAsserts</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ExitEpilog</span> <span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">ExitSuspendEquivalent</span> <span class="params">(JavaThread * Self)</span> </span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSynchronizer</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// WARNING: this must be the very first word of ObjectMonitor</span></span><br><span class="line">  <span class="comment">// This means this class can&#x27;t use any virtual member functions.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> markOop   _header;       <span class="comment">// displaced object header word - mark</span></span><br><span class="line">  <span class="keyword">void</span>*     <span class="keyword">volatile</span> _object;       <span class="comment">// backward object pointer - strong root</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> SharingPad [<span class="number">1</span>] ;           <span class="comment">// temp to reduce false sharing</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// All the following fields must be machine word aligned</span></span><br><span class="line">  <span class="comment">// The VM assumes write ordering wrt these fields, which can be</span></span><br><span class="line">  <span class="comment">// read from other threads.</span></span><br><span class="line"> <span class="comment">// 锁的持有者</span></span><br><span class="line"> <span class="keyword">protected</span>:                         <span class="comment">// protected for jvmtiRawMonitor</span></span><br><span class="line">  <span class="keyword">void</span> *  <span class="keyword">volatile</span> _owner;          <span class="comment">// pointer to owning thread OR BasicLock</span></span><br><span class="line">  <span class="keyword">volatile</span> jlong _previous_owner_tid; <span class="comment">// thread id of the previous owner of the monitor</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _recursions;   <span class="comment">// recursion count, 0 for first entry</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> OwnerIsThread ;               <span class="comment">// _owner is (Thread *) vs SP/BasicLock</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _cxq ;    <span class="comment">// LL of recently-arrived threads blocked on entry.</span></span><br><span class="line">                                    <span class="comment">// The list is actually composed of WaitNodes, acting</span></span><br><span class="line"> <span class="comment">// 没获取到锁的线程                                   // as proxies for Threads.</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _EntryList ;     <span class="comment">// Threads blocked on entry or reentry.</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Thread * <span class="keyword">volatile</span> _succ ;          <span class="comment">// Heir presumptive thread - used for futile wakeup throttling</span></span><br><span class="line">  Thread * <span class="keyword">volatile</span> _Responsible ;</span><br><span class="line">  <span class="keyword">int</span> _PromptDrain ;                <span class="comment">// rqst to drain cxq into EntryList ASAP</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _Spinner ;           <span class="comment">// for exit-&gt;spinner handoff optimization</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinFreq ;          <span class="comment">// Spin 1-out-of-N attempts: success rate</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinClock ;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinDuration ;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span> _SpinState ;    <span class="comment">// MCS/CLH list of spinners</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO-<span class="doctag">FIXME:</span> _count, _waiters and _recursions should be of</span></span><br><span class="line">  <span class="comment">// type int, or int32_t but not intptr_t.  There&#x27;s no reason</span></span><br><span class="line">  <span class="comment">// to use 64-bit fields for these variables on a 64-bit JVM.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _count;        <span class="comment">// reference count to prevent reclaimation/deflation</span></span><br><span class="line">                                    <span class="comment">// at stop-the-world time.  See deflate_idle_monitors().</span></span><br><span class="line">                                    <span class="comment">// _count is approximately |_WaitSet| + |_EntryList|</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _waiters;      <span class="comment">// number of waiting threads</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 等待集合定义</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _WaitSet; <span class="comment">// LL of threads wait()ing on the monitor</span></span><br><span class="line">    <span class="comment">// 等待队列,简单的自旋锁</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _WaitSetLock;        <span class="comment">// protects Wait Queue - simple spinlock</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _QMix ;                       <span class="comment">// Mixed prepend queue discipline</span></span><br><span class="line">  ObjectMonitor * FreeNext ;        <span class="comment">// Free list linkage</span></span><br><span class="line">  <span class="keyword">intptr_t</span> StatA, StatsB ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_ContendedLockAttempts ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_FutileWakeups ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Parks ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_EmptyNotifications ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Notifications ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowEnter ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowExit ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowNotify ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowNotifyAll ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_FailedSpins ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SuccessfulSpins ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_PrivateA ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_PrivateB ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_MonInCirculation ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_MonScavenged ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Inflations ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Deflations ;</span><br><span class="line">  <span class="keyword">static</span> PerfLongVariable * _sync_MonExtant ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Knob_Verbose;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Knob_SpinLimit;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateHeap</span>(size, mtInternal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span> size) <span class="built_in"><span class="keyword">throw</span></span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span> (size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FreeHeap</span>(p, mtInternal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="keyword">void</span> *p) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TEVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEVENT(nom) &#123;<span class="meta-keyword">if</span> (SyncVerbose) FEVENT(nom); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FEVENT(nom) &#123; static volatile int ctr = 0 ; int v = ++ctr ; <span class="meta-keyword">if</span> ((v &amp; (v-1)) == 0) &#123; ::printf (#nom <span class="meta-string">&quot; : %d \n&quot;</span>, v); ::fflush(stdout); &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  TEVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEVENT(nom) &#123;;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>EntryList、WaitSet采用链表的方式是因为在这个链表中，要根据某一定的规则查找、删除、增加线程比较容易。只有经过wait方法调用的时候，才会进入到WaitSet集合当中。</p>
<h3 id="wait、notify源码分析"><a href="#wait、notify源码分析" class="headerlink" title="wait、notify源码分析"></a>wait、notify源码分析</h3><p>wait方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::wait</span><span class="params">(jlong millis, <span class="keyword">bool</span> interruptible, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">   <span class="built_in">assert</span>(Self-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;Must be Java thread!&quot;</span>);</span><br><span class="line">   JavaThread *jt = (JavaThread *)THREAD;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Throw IMSX or IEX.</span></span><br><span class="line">   <span class="built_in">CHECK_OWNER</span>();</span><br><span class="line"></span><br><span class="line">   EventJavaMonitorWait event;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// check for a pending interrupt</span></span><br><span class="line">   <span class="keyword">if</span> (interruptible &amp;&amp; Thread::<span class="built_in">is_interrupted</span>(Self, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">     <span class="comment">// post monitor waited event.  Note that this is past-tense, we are done waiting.</span></span><br><span class="line">     <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_waited</span>()) &#123;</span><br><span class="line">        <span class="comment">// Note: &#x27;false&#x27; parameter is passed here because the</span></span><br><span class="line">        <span class="comment">// wait was not timed out due to thread interrupt.</span></span><br><span class="line">        JvmtiExport::<span class="built_in">post_monitor_waited</span>(jt, <span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In this short circuit of the monitor wait protocol, the</span></span><br><span class="line">        <span class="comment">// current thread never drops ownership of the monitor and</span></span><br><span class="line">        <span class="comment">// never gets added to the wait queue so the current thread</span></span><br><span class="line">        <span class="comment">// cannot be made the successor. This means that the</span></span><br><span class="line">        <span class="comment">// JVMTI_EVENT_MONITOR_WAITED event handler cannot accidentally</span></span><br><span class="line">        <span class="comment">// consume an unpark() meant for the ParkEvent associated with</span></span><br><span class="line">        <span class="comment">// this ObjectMonitor.</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">       <span class="built_in">post_monitor_wait_event</span>(&amp;event, <span class="keyword">this</span>, <span class="number">0</span>, millis, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Wait - Throw IEX) ;</span><br><span class="line">     <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>());</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">TEVENT</span> (Wait) ;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">assert</span> (Self-&gt;_Stalled == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line">   jt-&gt;<span class="built_in">set_current_waiting_monitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// create a node to be put into the queue</span></span><br><span class="line">   <span class="comment">// Critically, after we reset() the event but prior to park(), we must check</span></span><br><span class="line">   <span class="comment">// for a pending interrupt.</span></span><br><span class="line">   <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span></span>;</span><br><span class="line">   node.TState = ObjectWaiter::TS_WAIT ;</span><br><span class="line">   Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">   OrderAccess::<span class="built_in">fence</span>();          <span class="comment">// ST into Event; membar ; LD interrupted-flag</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Enter the waiting queue, which is a circular doubly linked list in this case</span></span><br><span class="line">   <span class="comment">// but it could be a priority queue or any data structure.</span></span><br><span class="line">   <span class="comment">// _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only</span></span><br><span class="line">   <span class="comment">// by the the owner of the monitor *except* in the case where park()</span></span><br><span class="line">   <span class="comment">// returns because of a timeout of interrupt.  Contention is exceptionally rare</span></span><br><span class="line">   <span class="comment">// so we use a simple spin-lock instead of a heavier-weight blocking lock.</span></span><br><span class="line"></span><br><span class="line">   Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - add&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 将封装好的node对象放到队列中，通过双向链表实现的</span></span><br><span class="line">   <span class="built_in">AddWaiter</span> (&amp;node) ;</span><br><span class="line">   Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">intptr_t</span> save = _recursions; <span class="comment">// record the old recursion count</span></span><br><span class="line">   _waiters++;                  <span class="comment">// increment the number of waiters</span></span><br><span class="line">   _recursions = <span class="number">0</span>;             <span class="comment">// set the recursion level to be 1</span></span><br><span class="line">    <span class="comment">// 释放掉锁</span></span><br><span class="line">   <span class="built_in">exit</span> (<span class="literal">true</span>, Self) ;                    <span class="comment">// exit the monitor</span></span><br><span class="line">   <span class="built_in">guarantee</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The thread is on the WaitSet list - now park() it.</span></span><br><span class="line">   <span class="comment">// On MP systems it&#x27;s conceivable that a brief spin before we park</span></span><br><span class="line">   <span class="comment">// could be profitable.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// TODO-<span class="doctag">FIXME:</span> change the following logic to a loop of the form</span></span><br><span class="line">   <span class="comment">//   while (!timeout &amp;&amp; !interrupted &amp;&amp; _notified == 0) park()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> ret = OS_OK ;</span><br><span class="line">   <span class="keyword">int</span> WasNotified = <span class="number">0</span> ;</span><br><span class="line">   &#123; <span class="comment">// State transition wrappers</span></span><br><span class="line">     OSThread* osthread = Self-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">     <span class="function">OSThreadWaitState <span class="title">osts</span><span class="params">(osthread, <span class="literal">true</span>)</span></span>;</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line">       <span class="comment">// Thread is in thread_blocked state and oop access is unsafe.</span></span><br><span class="line">       jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (interruptible &amp;&amp; (Thread::<span class="built_in">is_interrupted</span>(THREAD, <span class="literal">false</span>) || HAS_PENDING_EXCEPTION)) &#123;</span><br><span class="line">           <span class="comment">// Intentionally empty</span></span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">if</span> (node._notified == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (millis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> () ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> (millis) ;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// were we externally suspended while we were waiting?</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">ExitSuspendEquivalent</span> (jt)) &#123;</span><br><span class="line">          <span class="comment">// TODO-<span class="doctag">FIXME:</span> add -- if succ == Self then succ = null.</span></span><br><span class="line">          jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="comment">// Exit thread safepoint: transition _thread_blocked -&gt; _thread_in_vm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Node may be on the WaitSet, the EntryList (or cxq), or in transition</span></span><br><span class="line">     <span class="comment">// from the WaitSet to the EntryList.</span></span><br><span class="line">     <span class="comment">// See if we need to remove Node from the WaitSet.</span></span><br><span class="line">     <span class="comment">// We use double-checked locking to avoid grabbing _WaitSetLock</span></span><br><span class="line">     <span class="comment">// if the thread is not on the wait queue.</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Note that we don&#x27;t need a fence before the fetch of TState.</span></span><br><span class="line">     <span class="comment">// In the worst case we&#x27;ll fetch a old-stale value of TS_WAIT previously</span></span><br><span class="line">     <span class="comment">// written by the is thread. (perhaps the fetch might even be satisfied</span></span><br><span class="line">     <span class="comment">// by a look-aside into the processor&#x27;s own store buffer, although given</span></span><br><span class="line">     <span class="comment">// the length of the code path between the prior ST and this load that&#x27;s</span></span><br><span class="line">     <span class="comment">// highly unlikely).  If the following LD fetches a stale TS_WAIT value</span></span><br><span class="line">     <span class="comment">// then we&#x27;ll acquire the lock and then re-fetch a fresh TState value.</span></span><br><span class="line">     <span class="comment">// That is, we fail toward safety.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (node.TState == ObjectWaiter::TS_WAIT) &#123;</span><br><span class="line">         Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - unlink&quot;</span>) ;</span><br><span class="line">         <span class="keyword">if</span> (node.TState == ObjectWaiter::TS_WAIT) &#123;</span><br><span class="line">            <span class="built_in">DequeueSpecificWaiter</span> (&amp;node) ;       <span class="comment">// unlink from WaitSet</span></span><br><span class="line">            <span class="built_in">assert</span>(node._notified == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">            node.TState = ObjectWaiter::TS_RUN ;</span><br><span class="line">         &#125;</span><br><span class="line">         Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// The thread is now either on off-list (TS_RUN),</span></span><br><span class="line">     <span class="comment">// on the EntryList (TS_ENTER), or on the cxq (TS_CXQ).</span></span><br><span class="line">     <span class="comment">// The Node&#x27;s TState variable is stable from the perspective of this thread.</span></span><br><span class="line">     <span class="comment">// No other threads will asynchronously modify TState.</span></span><br><span class="line">     <span class="built_in">guarantee</span> (node.TState != ObjectWaiter::TS_WAIT, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     OrderAccess::<span class="built_in">loadload</span>() ;</span><br><span class="line">     <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">     WasNotified = node._notified ;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reentry phase -- reacquire the monitor.</span></span><br><span class="line">     <span class="comment">// re-enter contended monitor after object.wait().</span></span><br><span class="line">     <span class="comment">// retain OBJECT_WAIT state until re-enter successfully completes</span></span><br><span class="line">     <span class="comment">// Thread state is thread_in_vm and oop access is again safe,</span></span><br><span class="line">     <span class="comment">// although the raw address of the object may have changed.</span></span><br><span class="line">     <span class="comment">// (Don&#x27;t cache naked oops over safepoints, of course).</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// post monitor waited event. Note that this is past-tense, we are done waiting.</span></span><br><span class="line">     <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_waited</span>()) &#123;</span><br><span class="line">       JvmtiExport::<span class="built_in">post_monitor_waited</span>(jt, <span class="keyword">this</span>, ret == OS_TIMEOUT);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (node._notified != <span class="number">0</span> &amp;&amp; _succ == Self) &#123;</span><br><span class="line">         <span class="comment">// In this part of the monitor wait-notify-reenter protocol it</span></span><br><span class="line">         <span class="comment">// is possible (and normal) for another thread to do a fastpath</span></span><br><span class="line">         <span class="comment">// monitor enter-exit while this thread is still trying to get</span></span><br><span class="line">         <span class="comment">// to the reenter portion of the protocol.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// The ObjectMonitor was notified and the current thread is</span></span><br><span class="line">         <span class="comment">// the successor which also means that an unpark() has already</span></span><br><span class="line">         <span class="comment">// been done. The JVMTI_EVENT_MONITOR_WAITED event handler can</span></span><br><span class="line">         <span class="comment">// consume the unpark() that was done when the successor was</span></span><br><span class="line">         <span class="comment">// set because the same ParkEvent is shared between Java</span></span><br><span class="line">         <span class="comment">// monitors and JVM/TI RawMonitors (for now).</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// We redo the unpark() to ensure forward progress, i.e., we</span></span><br><span class="line">         <span class="comment">// don&#x27;t want all pending threads hanging (parked) with none</span></span><br><span class="line">         <span class="comment">// entering the unlocked monitor.</span></span><br><span class="line">         node._event-&gt;<span class="built_in">unpark</span>();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">       <span class="built_in">post_monitor_wait_event</span>(&amp;event, <span class="keyword">this</span>, node._notifier_tid, millis, ret == OS_TIMEOUT);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">assert</span> (Self-&gt;_Stalled != <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">assert</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     ObjectWaiter::TStates v = node.TState ;</span><br><span class="line">     <span class="keyword">if</span> (v == ObjectWaiter::TS_RUN) &#123;</span><br><span class="line">         <span class="built_in">enter</span> (Self) ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">guarantee</span> (v == ObjectWaiter::TS_ENTER || v == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">ReenterI</span> (Self, &amp;node) ;</span><br><span class="line">         node.<span class="built_in">wait_reenter_end</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Self has reacquired the lock.</span></span><br><span class="line">     <span class="comment">// Lifecycle - the node representing Self must not appear on any queues.</span></span><br><span class="line">     <span class="comment">// Node is about to go out-of-scope, but even if it were immortal we wouldn&#x27;t</span></span><br><span class="line">     <span class="comment">// want residual elements associated with this thread left on any lists.</span></span><br><span class="line">     <span class="built_in">guarantee</span> (node.TState == ObjectWaiter::TS_RUN, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span>    (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span>    (_succ != Self , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   &#125; <span class="comment">// OSThreadWaitState()</span></span><br><span class="line"></span><br><span class="line">   jt-&gt;<span class="built_in">set_current_waiting_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">guarantee</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   _recursions = save;     <span class="comment">// restore the old recursion count</span></span><br><span class="line">   _waiters--;             <span class="comment">// decrement the number of waiters</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Verify a few postconditions</span></span><br><span class="line">   <span class="built_in">assert</span> (_owner == Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   <span class="built_in">assert</span> (_succ  != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SyncFlags &amp; <span class="number">32</span>) &#123;</span><br><span class="line">      OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// check if the notification happened</span></span><br><span class="line">   <span class="keyword">if</span> (!WasNotified) &#123;</span><br><span class="line">     <span class="comment">// no, it could be timeout or Thread.interrupt() or both</span></span><br><span class="line">     <span class="comment">// check for interrupt event, otherwise it is timeout</span></span><br><span class="line">     <span class="keyword">if</span> (interruptible &amp;&amp; Thread::<span class="built_in">is_interrupted</span>(Self, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">       <span class="built_in">TEVENT</span> (Wait - <span class="keyword">throw</span> IEX from epilog) ;</span><br><span class="line">       <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// <span class="doctag">NOTE:</span> Spurious wake up will be consider as timeout.</span></span><br><span class="line">   <span class="comment">// Monitor notify has precedence over thread interrupt.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notify方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::notify</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK_OWNER</span>();</span><br><span class="line">    <span class="comment">// 等待集合为空</span></span><br><span class="line">  <span class="keyword">if</span> (_WaitSet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Empty-Notify) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_PROBE</span>(notify, <span class="keyword">this</span>, <span class="built_in">object</span>(), THREAD);</span><br><span class="line">	<span class="comment">// 不同的调度策略（具体唤醒哪一个线程），使用调度策略将这个ObjectWaiter放置到EntryList</span></span><br><span class="line">  <span class="keyword">int</span> Policy = Knob_MoveNotifyee ;</span><br><span class="line"></span><br><span class="line">  Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - notify&quot;</span>) ;</span><br><span class="line">  ObjectWaiter * iterator = <span class="built_in">DequeueWaiter</span>() ;</span><br><span class="line">  <span class="keyword">if</span> (iterator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Notify1 - Transfer) ;</span><br><span class="line">     <span class="built_in">guarantee</span> (iterator-&gt;TState == ObjectWaiter::TS_WAIT, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">guarantee</span> (iterator-&gt;_notified == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> (Policy != <span class="number">4</span>) &#123;</span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">     &#125;</span><br><span class="line">     iterator-&gt;_notified = <span class="number">1</span> ;</span><br><span class="line">     Thread * Self = THREAD;</span><br><span class="line">     iterator-&gt;_notifier_tid = <span class="built_in">JFR_THREAD_ID</span>(Self);</span><br><span class="line"></span><br><span class="line">     ObjectWaiter * List = _EntryList ;</span><br><span class="line">     <span class="keyword">if</span> (List != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (List-&gt;_prev == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (List-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (List != iterator, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">0</span>) &#123;       <span class="comment">// prepend to EntryList</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             List-&gt;_prev = iterator ;</span><br><span class="line">             iterator-&gt;_next = List ;</span><br><span class="line">             iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">1</span>) &#123;      <span class="comment">// append to EntryList</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CONSIDER:  finding the tail currently requires a linear-time walk of</span></span><br><span class="line">            <span class="comment">// the EntryList.  We can make tail access constant-time by converting to</span></span><br><span class="line">            <span class="comment">// a CDLL instead of using our current DLL.</span></span><br><span class="line">            ObjectWaiter * Tail ;</span><br><span class="line">            <span class="keyword">for</span> (Tail = List ; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">            <span class="built_in">assert</span> (Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            Tail-&gt;_next = iterator ;</span><br><span class="line">            iterator-&gt;_prev = Tail ;</span><br><span class="line">            iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">2</span>) &#123;      <span class="comment">// prepend to cxq</span></span><br><span class="line">         <span class="comment">// prepend to cxq</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iterator-&gt;TState = ObjectWaiter::TS_CXQ ;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                ObjectWaiter * Front = _cxq ;</span><br><span class="line">                iterator-&gt;_next = Front ;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (iterator, &amp;_cxq, Front) == Front) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">3</span>) &#123;      <span class="comment">// append to cxq</span></span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_CXQ ;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ObjectWaiter * Tail ;</span><br><span class="line">            Tail = _cxq ;</span><br><span class="line">            <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (iterator, &amp;_cxq, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (Tail-&gt;_next != <span class="literal">NULL</span>) Tail = Tail-&gt;_next ;</span><br><span class="line">                Tail-&gt;_next = iterator ;</span><br><span class="line">                iterator-&gt;_prev = Tail ;</span><br><span class="line">                iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ParkEvent * ev = iterator-&gt;_event ;</span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_RUN ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        ev-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (Policy &lt; <span class="number">4</span>) &#123;</span><br><span class="line">       iterator-&gt;<span class="built_in">wait_reenter_begin</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// _WaitSetLock protects the wait queue, not the EntryList.  We could</span></span><br><span class="line">     <span class="comment">// move the add-to-EntryList operation, above, outside the critical section</span></span><br><span class="line">     <span class="comment">// protected by _WaitSetLock.  In practice that&#x27;s not useful.  With the</span></span><br><span class="line">     <span class="comment">// exception of  wait() timeouts and interrupts the monitor owner</span></span><br><span class="line">     <span class="comment">// is the only thread that grabs _WaitSetLock.  There&#x27;s almost no contention</span></span><br><span class="line">     <span class="comment">// on _WaitSetLock so it&#x27;s not profitable to reduce the length of the</span></span><br><span class="line">     <span class="comment">// critical section.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iterator != <span class="literal">NULL</span> &amp;&amp; ObjectMonitor::_sync_Notifications != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ObjectMonitor::_sync_Notifications-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁升级与偏向锁"><a href="#锁升级与偏向锁" class="headerlink" title="锁升级与偏向锁"></a>锁升级与偏向锁</h3><p>随着JDK版本的不断更迭，底层对于synchronized关键字的实现方式也不断地在进行调整。在JDK1.5之前，要实现线程同步，只能通过synchronized关键字来实现，Java底层也是通过synchronized关键字来做到数据的原子性维护，synchronized关键字是JVM实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是由JVM帮助我们隐式实现的。从JDK1.5开始，并发包引入了Lock锁，Lock同步锁是基于Java来实现的，因此锁的获取与释放都是通过Java代码来实现与控制的，synchronized是基于底层操作系统Mutex Lock来实现的，每次对锁的获取与释放动作都会带来用户态与内核态之间的切换，这种切换会极大的增加系统的负担。在并发量较高时，也就是说锁的竞争比较激烈的时候，synchronized锁在性能上的表现就非常差。</p>
<p>从JDK1.6开始，synchronized锁的实现发生了很大的变化，JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁、轻量级锁、重量级锁等，从而减少锁的竞争锁带来的用户态与内核态之前的切换，这种锁的优化是通过Java对象头中的一些标志位来去实现的。对于锁的访问与改变，实际上都与Java对象头息息相关。</p>
<p>从JDK1.6开始，对象实例在堆当中会被划分为三个组成部分：对象头、实例数据与对齐填充。</p>
<p>对象头主要由3块内容来构成：</p>
<ol>
<li>Mark Word </li>
<li>指向类的指针</li>
<li>数组的长度</li>
</ol>
<p>其中Mark Word （它记录了对象、锁及垃圾回收相关的信息，在64位的JVM中，其长度也是64bit）的位信息包括了如下的组成部分：</p>
<ol>
<li>无锁标记</li>
<li>偏向锁标记</li>
<li>轻量级锁标记</li>
<li>重量级锁标记</li>
<li>GC标记</li>
</ol>
<p>对于synchronized锁来说，锁的升级主要是通过Mark Word中的锁的标志位与是否是偏向锁标志位来达成的；synchronized关键字锁对应的锁都是从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后则变成了重量级锁。</p>
<p>对于锁的演化来说，它会经历如下阶段：</p>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p>偏向锁：针对于一个线程来说，它的作用就是优化同一个线程多次获取一个锁的情况；如果一个synchronized方法被一个线程访问，那么这个方法所在的对象就会在其Mark Word中将偏向锁进行标记，同时还会有一个字段来存储该线程的ID；当这个线程再次访问同一个synchronized方法时，它会检查这个对象的Mark Word的偏向锁标记以及是否指向了其线程ID，如果是的话，那么该线程就无需进行管程（Monitor）了，而是直接进入到该方法体中。如果是另外一个线程访问这个synchronized方法，那么偏向锁的标记就会被去掉。</p>
<p>轻量级锁：若第一个线程已经获取到了当前对象的锁，这是第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程在争抢时，会发现该对象头中的Mark Word已经是偏向锁，但里面存储的线程ID不是自己（第一个线程），那么它会进行CAS（Compare and Swap），从而获取到锁，这里面存在两种情况：</p>
<ol>
<li>获取锁成功，那么它会直接将Mark Word中的线程ID由第一个线程变成自己（偏向锁标记位保持不变），这样该对象依然会保持偏向锁的状态</li>
<li>获取锁失败，表示这时可能会有多个线程同时在尝试争抢该对象的锁，那么这时偏向锁会进行升级，升级为轻量级锁</li>
</ol>
<p>自旋锁：若自旋失败（依然无法获取到锁），那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到Monitor（即内核态）。自旋最大的一个特点就是避免了线程从用户态进入到内核态。</p>
<p>重量级锁：线程最终从用户态进入到了内核态。</p>
<h3 id="锁粗化与锁消除"><a href="#锁粗化与锁消除" class="headerlink" title="锁粗化与锁消除"></a>锁粗化与锁消除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器对于锁的优化措施：JIT编译器（Just In Time编译器）可以在动态编译同步代码时，使用一种叫做逃逸分析的技术，来通过该项技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散布到其他线程当中，如果情况就是这样的话，那么JIT编译器在编译这个同步代码时就不会生成synchronized关键字所标识的锁的申请与释放机器码，从而消除了锁的使用流程，这就是锁的消除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果object是成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下就发生了：锁粗化，JIT编译器在执行动态编译时，若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块合并为一个较大的同步块，这样做的好处在于线程在执行这些代码的时候，就无需频繁的申请与释放锁了，从而达到申请与释放锁一次，就可以执行完全部的同步代码块，从而提升了性能。</p>
<h3 id="死锁及死锁检测"><a href="#死锁及死锁检测" class="headerlink" title="死锁及死锁检测"></a>死锁及死锁检测</h3><ul>
<li>死锁：线程1等待线程2互斥持有的资源，而线程2也在等待线程1互斥持有的资源，两个线程都无法继续执行；</li>
<li>活锁：线程持续重试一个总是失败的操作，导致无法继续执行；</li>
<li>饿死：线程一直被调度器延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总是会有一个高优先级的线程可以执行，饿死也叫做无限延迟。</li>
</ul>
<p>首先来看一下可能会发生死锁的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest7</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myMethod1 invoked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myMethod2 invoked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest7 myTest7 = <span class="keyword">new</span> MyTest7();</span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                myTest7.method1();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable1, <span class="string">&quot;myThread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                myTest7.method2();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable2, <span class="string">&quot;myThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行一段时间之后就发生死锁的现象，发生死锁之后可以使用JVM自带的一些工具来进行检测。</p>
<p>首先是jvisualvm:</p>
<p><img src="./assets/1605541454922.png" alt="1605541454922"></p>
<p>可以看到，已经检测到死锁的情况，点击线程Dump可以查看详情。</p>
<p><img src="./assets/1605541658677.png" alt="1605541658677"></p>
<p>除了使用可视化界面之外，也可以使用命令行的工具来进行检测死锁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\code\java8\jyc&gt;jps -l</span><br><span class="line">9104</span><br><span class="line">12212 concurrency2.MyTest7</span><br><span class="line">11656 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">16428 org.gradle.launcher.daemon.bootstrap.GradleDaemon</span><br><span class="line">3468 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure>

<p>可以看到运行我们程序的进行号为12212，继续使用jstack来查看当前线程的执行详情：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">D:\code\java8\jyc&gt;jstack 12212</span><br><span class="line">2020-11-16 23:50:41</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.212-b10 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;JMX server connection timeout 18&quot; #18 daemon prio=5 os_prio=0 tid=0x0000000019fca800 nid=0x25ec in Object.wait() [0x000000001b9de000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at com.sun.jmx.remote.internal.ServerCommunicatorAdmin$Timeout.run(ServerCommunicatorAdmin.java:168)</span><br><span class="line">        - locked &lt;0x00000000d8408178&gt; (a [I)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;RMI Scheduler(0)&quot; #17 daemon prio=5 os_prio=0 tid=0x0000000019fc9800 nid=0x36a0 waiting on condition [0x000000001b8df000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000d8410188&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;RMI TCP Accept-0&quot; #15 daemon prio=5 os_prio=0 tid=0x0000000019f5f000 nid=0x4270 runnable [0x000000001b6df000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.accept0(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:131)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)</span><br><span class="line">        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:199)</span><br><span class="line">        - locked &lt;0x00000000d84182b0&gt; (a java.net.SocksSocketImpl)</span><br><span class="line">        at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">        at java.net.ServerSocket.accept(ServerSocket.java:513)</span><br><span class="line">        at sun.management.jmxremote.LocalRMIServerSocketFactory$1.accept(LocalRMIServerSocketFactory.java:52)</span><br><span class="line">        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.executeAcceptLoop(TCPTransport.java:405)</span><br><span class="line">        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.run(TCPTransport.java:377)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000000002a6e000 nid=0x19c0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;myThread2&quot; #12 prio=5 os_prio=0 tid=0x000000001a17e000 nid=0x3290 waiting for monitor entry [0x000000001b58f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at concurrency2.MyTest7.method2(MyTest7.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$1(MyTest7.java:44)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$2/1418481495.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;myThread1&quot; #11 prio=5 os_prio=0 tid=0x000000001a17d800 nid=0x3b8c waiting for monitor entry [0x000000001b48f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at concurrency2.MyTest7.method1(MyTest7.java:15)</span><br><span class="line">        - waiting to lock &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$0(MyTest7.java:32)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$1/471910020.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #10 daemon prio=9 os_prio=0 tid=0x0000000019ebf000 nid=0x3194 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread3&quot; #9 daemon prio=9 os_prio=2 tid=0x0000000019e28800 nid=0x48c0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread2&quot; #8 daemon prio=9 os_prio=2 tid=0x0000000019e28000 nid=0x219c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os_prio=2 tid=0x0000000019e26800 nid=0x39c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os_prio=2 tid=0x0000000019e1f800 nid=0x22c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x0000000019e1d800 nid=0x898 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x0000000019e1c800 nid=0x3174 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000019db1000 nid=0x40e4 in Object.wait() [0x000000001a38e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">        - locked &lt;0x00000000d84385e8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000019db0800 nid=0x23e4 in Object.wait() [0x000000001a28e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        - locked &lt;0x00000000d8430758&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=2 tid=0x0000000017fb8800 nid=0x1f84 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000003008000 nid=0x2d74 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x0000000003009800 nid=0x5374 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000300b000 nid=0x21ec runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000300c800 nid=0x4064 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#4 (ParallelGC)&quot; os_prio=0 tid=0x000000000300f000 nid=0x234c runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#5 (ParallelGC)&quot; os_prio=0 tid=0x0000000003011000 nid=0x2ea8 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#6 (ParallelGC)&quot; os_prio=0 tid=0x0000000003014000 nid=0x14a0 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#7 (ParallelGC)&quot; os_prio=0 tid=0x0000000003015800 nid=0x39d4 runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x0000000019ed4000 nid=0x1d40 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 232</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到一个Java级别的死锁</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;myThread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ee6c8 (object 0x00000000d84202f0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread1&quot;</span><br><span class="line">&quot;myThread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ed228 (object 0x00000000d8420300, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;myThread2&quot;:</span><br><span class="line">        at concurrency2.MyTest7.method2(MyTest7.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$1(MyTest7.java:44)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$2/1418481495.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;myThread1&quot;:</span><br><span class="line">        at concurrency2.MyTest7.method1(MyTest7.java:15)</span><br><span class="line">        - waiting to lock &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$0(MyTest7.java:32)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$1/471910020.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<h1 id="concurrent并发包"><a href="#concurrent并发包" class="headerlink" title="concurrent并发包"></a>concurrent并发包</h1><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="锁的机制与原理"><a href="#锁的机制与原理" class="headerlink" title="锁的机制与原理"></a>锁的机制与原理</h3><p>Lock是非常重要的顶级接口，接下来我们阅读一下关于它的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock implementations provide more extensive locking operations than can be obtained using synchronized </span><br><span class="line">methods and statements. They allow more flexible structuring, may have quite different properties, and </span><br><span class="line">may support multiple associated Condition objects.</span><br></pre></td></tr></table></figure>

<p>Lock实现了要比使用synchronized关键字修饰的方法及语句用途更为广泛的锁的操作，它们支持更为灵活的结构化，拥有很多不同的属性，支持多种相关联的Condition对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock </span><br><span class="line">provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all </span><br><span class="line">access to the shared resource requires that the lock be acquired first. However, some locks may allow </span><br><span class="line">concurrent access to a shared resource, such as the read lock of a ReadWriteLock.</span><br></pre></td></tr></table></figure>

<p>锁是一种多个线程对于一个共享资源的访问，通常情况下，一个锁会对共享资源提供一种排它性的访问，这意味着在同一个时刻，只能有一个线程获取到锁，其他线程必须要先获取到锁才能访问共享资源。然而，某些锁可以对于共享资源的并发访问，比如读锁中的ReadWriteLock（读写锁）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The use of synchronized methods or statements provides access to the implicit monitor lock associated </span><br><span class="line">with every object, but forces all lock acquisition and release to occur in a block-structured way: when </span><br><span class="line">multiple locks are acquired they must be released in the opposite order, and all locks must be released </span><br><span class="line">in the same lexical scope in which they were acquired.</span><br></pre></td></tr></table></figure>

<p>使用synchronized方法或者synchronized代码块提供了对于每一个对象的所关联的隐式的monitor对象的访问，但是它会强制所有锁的获取和释放都发生在块结构的方式中，当多个锁被获取的时候，必须要以相反的顺序释放，而且所有的锁必须以获取的相同的作用域释放掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">While the scoping mechanism for synchronized methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</span><br></pre></td></tr></table></figure>

<p>虽然synchronized方法和代码块的作用域使得我们对于monitor锁的编程更加轻松，而且还会避免与锁相关的编码错误，但是存在一些场景，需要更加灵活的处理锁，比如某些算法需要并发的遍历被访问的数据结构，他们需要需要使用hand-over-hand或者chain locking：你需要首先获取到node A的锁，然后是node B的锁，紧接着释放A，然后获取到C，然后释放掉B，然后获取到D等等，Lock接口的实现使得这种技术的使用成为可能，它可以使得锁的获取和释放不在同一个作用域，也可以不再按照顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">With this increased flexibility comes additional responsibility. The absence of block-structured locking </span><br><span class="line">removes the automatic release of locks that occurs with synchronized methods and statements. In most </span><br><span class="line">cases, the following idiom should be used:</span><br></pre></td></tr></table></figure>

<p>但是如果我们不使用这种块结构的锁的话，就没法再使用synchronized提供的自动释放锁的功能，在大多数情况下按照如下的方式使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line"> l.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// access the resource protected by this lock</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   l.unlock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is </span><br><span class="line">executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is </span><br><span class="line">released when necessary.</span><br></pre></td></tr></table></figure>

<p>当加锁和解锁出现在不同的作用域当中，我们必须要非常小心的确保被执行的所有的代码都是在try-finally 或者try-catch的保护当中，从而保证锁在必要的时候可以被释放掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lock implementations provide additional functionality over the use of synchronized methods and </span><br><span class="line">statements by providing a non-blocking attempt to acquire a lock (tryLock()), an attempt to acquire the </span><br><span class="line">lock that can be interrupted (lockInterruptibly, and an attempt to acquire the lock that can timeout </span><br><span class="line">(tryLock(long, TimeUnit)).</span><br></pre></td></tr></table></figure>

<p>Lock的实现相比于synchronized方法和语句的实现提供了一些额外的功能，它是通过一种非阻塞的方式获取到锁，并且还提供了获取锁的操作是可以被中断的，可以设置锁的超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A Lock class can also provide behavior and semantics that is quite different from that of the implicit </span><br><span class="line">monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection. If an </span><br><span class="line">implementation provides such specialized semantics then the implementation must document those </span><br><span class="line">semantics.</span><br></pre></td></tr></table></figure>

<p>一个Lock的类还可以提供一些与隐式的monitor锁的完全不同的行为和语义，比如可以确保顺序性、可重入的使用或者死锁检测。如果一种实现实现了这种特殊的语气，那么实现就必须将这个语义清楚的记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Note that Lock instances are just normal objects and can themselves be used as the target in a </span><br><span class="line">synchronized statement. Acquiring the monitor lock of a Lock instance has no specified relationship with</span><br><span class="line">invoking any of the lock methods of that instance. It is recommended that to avoid confusion you never</span><br><span class="line">use Lock instances in this way, except within their own implementation.</span><br></pre></td></tr></table></figure>

<p>Lock实例仅仅是一个普通的对象而已，它们本身也可以被synchronized语句修饰，因为每个对象都会有一个与之相关的monitor存在，对于Lock实例对象也不例外，获取到Lock实例的monitor锁，与调用这个Lock方法之间没有什么特殊的关联关系。换言之，我们如果将一个Lock实例作为synchronized使用的对象的话，JVM会获取到Lock实例的monitor对象，它与Lock是两个层面的东西，推荐的做法是避免这种混淆，除了在它们自己的底层实现当中，永远不要通过这种方式使用Lock实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification (17.4 Memory Model) :</span><br></pre></td></tr></table></figure>

<p>所有的Lock的实现都必须强制与内建的monitor锁的内存同步语义是一致的，这一点是在Java语言规范中明确的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A successful lock operation has the same memory synchronization effects as a successful Lock action.</span><br><span class="line">A successful unlock operation has the same memory synchronization effects as a successful Unlock action.</span><br></pre></td></tr></table></figure>

<ul>
<li>一个成功的加锁的操作与成功的synchronization拥有相同的同步效果</li>
<li>一个成功的释放锁的操作与成功的synchronization拥有相同的释放锁的效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unsuccessful locking and unlocking operations, and reentrant locking/unlocking operations, do not require any memory synchronization effects.</span><br></pre></td></tr></table></figure>

<p>（可重入的）加锁和释放锁不成功的操作，它们是不要求任何的内存同步的效果的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance </span><br><span class="line">characteristics, ordering guarantees, or other implementation qualities.</span><br></pre></td></tr></table></figure>

<p>获取lock的三种方式（可中断的，非可中断的，基于时间的）在性能上、顺序上的保证还有一些其他的特性上可能有所不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Further, the ability to interrupt the ongoing acquisition of a lock may not be available in a given Lock class. Consequently, </span><br><span class="line">an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, </span><br><span class="line">nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document </span><br><span class="line">the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined </span><br><span class="line">in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on </span><br><span class="line">method entry.</span><br></pre></td></tr></table></figure>

<p>进一步而言，这种能力可以中断锁获取可能不在给定的lock类当中，因此一种实现并不要求精确的定义相同的这种语义针对于这三种实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor </span><br><span class="line">responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after </span><br><span class="line">another action may have unblocked the thread. An implementation should document this behavior.</span><br></pre></td></tr></table></figure>

<p>由于中断通常意味着取消，因此检查这个中断通常不是一个频繁的操作，实现可以对一个中断进行响应，而不是等待一个正常的方法的返回。即便中断可能出现在另外一个动作之后有可能解锁这个线程，实现应该将这种行为记录下来。</p>
<p>以上是Lock接口的说明，接下来我们了解一下其中部分的核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Acquires the lock.</span><br><span class="line">If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until </span><br><span class="line">the lock has been acquired.</span><br></pre></td></tr></table></figure>

<p>该方法用于获取到锁，如果获取不到锁，当前的线程将会无法被用于线程调度，线程会进入睡眠状态，直到获取到锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and </span><br><span class="line">may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that</span><br><span class="line">Lock implementation.</span><br></pre></td></tr></table></figure>

<p>Lock实现可以检测锁的错误的使用，比如可能导致死锁的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Acquires the lock unless the current thread is interrupted.</span><br><span class="line">Acquires the lock if it is available and returns immediately.</span><br><span class="line">If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</span><br></pre></td></tr></table></figure>

<p>如果当前线程没有被中断就尝试获取到锁。如果锁是可以获取，就会立刻返回。如果这个锁是不可用的，那么当前线程也无法进行调度，而且会陷入到睡眠状态，直到下面两种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The lock is acquired by the current thread; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of lock acquisition is supported.</span><br></pre></td></tr></table></figure>

<ul>
<li>当前线程获取到锁</li>
<li>其他的线程中断了当前线程，而且锁获取的过程的是支持的中断的</li>
</ul>
<p>如果当前线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">has its interrupted status set on entry to this method; or</span><br><span class="line">is interrupted while acquiring the lock, and interruption of lock acquisition is supported,</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个方法的入口中拥有自己的被中断的状态</li>
<li>在获取锁的过程被中断了，并且这种在获取锁的时候的中断是被支持的</li>
</ul>
<p>那么 InterruptedException 会被抛出，并且当前线程的状态会被清理掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Acquires the lock only if it is free at the time of invocation.</span><br><span class="line">Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this </span><br><span class="line">method will return immediately with the value false.</span><br><span class="line">A typical usage idiom for this method would be:</span><br></pre></td></tr></table></figure>

<p>调用的时候，只有当可以获取的锁的时候，才获取到锁。如果获取可以获取到锁，就会立刻返回true，如果获取不到，就会立刻返回false，一中典型的使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"> <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// manipulate protected state</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// perform alternative actions</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This usage ensures that the lock is unlocked if it was acquired, and doesn&#x27;t try to unlock if the lock was not acquired.</span><br></pre></td></tr></table></figure>

<p>这种用法可以保证如果锁被获取了，那么锁是会被释放掉的，如果没有获取到锁，就不用去释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>这是另外一个重载的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Acquires the lock if it is free within the given waiting time and the current thread has not been interrupted.</span><br><span class="line">If the lock is available this method returns immediately with the value true. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</span><br></pre></td></tr></table></figure>

<p>在给定的等待时间之内，如果线程没有被中断并且锁是可以获取的，那么就获取到锁。如果锁拿到了，就会立刻返回true，如果没有获取到，那么线程就无法再进行调度，进入睡眠状态，直到如下三种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The lock is acquired by the current thread; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of lock acquisition is supported; or</span><br><span class="line">The specified waiting time elapses</span><br></pre></td></tr></table></figure>

<ul>
<li>当前线程获取到了锁</li>
<li>其他线程中断了当前的线程，并且在锁获取的过程中，中断是被支持的</li>
<li>指定的时间到了</li>
</ul>
<p>如果获取到了锁则立刻返回true，如果当前线程被中断了，并且这种中断是被允许的，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">then InterruptedException is thrown and the current thread&#x27;s interrupted status is cleared.</span><br><span class="line">If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.</span><br></pre></td></tr></table></figure>

<p>当前线程就会抛出InterruptedException，并且当前线程的状态也会被清理掉。如果过了指定的时间，那么就会返回false，如果指定时间小于或者等于0，那么这个方法就会做任何的等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Lock implementation will usually impose restrictions on which thread can release a lock (typically only the holder of the lock can release it) and may throw an (unchecked) exception if the restriction is violated. Any restrictions and the exception type must be documented by that Lock implementation.</span><br></pre></td></tr></table></figure>

<p>该方法用来释放掉锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Returns a new Condition instance that is bound to this Lock instance.</span><br><span class="line">Before waiting on the condition the lock must be held by the current thread. A call to Condition.await() will atomically release the lock before waiting and re-acquire the lock before the wait returns.</span><br></pre></td></tr></table></figure>

<p>它会返回一个新的绑定到当前Lock上的Condition实例，在等待condition之前，当前线程必须持有锁，调用Condition.await()会自动地释放掉锁。</p>
<p>接下来我们看一个有关于锁的使用的实际案例。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;myMethod1 invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果注释掉这行代码，程序仍然可以访问到此线程的锁，即上一行的输出会打印，但myMethod2因为获取不到锁，因此不会执行。</span></span><br><span class="line">            <span class="comment">// lock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;myMethod2 invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest1 myTest1 = <span class="keyword">new</span> MyTest1();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                myTest1.myMethod1();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                myTest1.myMethod2();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对myMethod2进行一定的改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序就可以正常的往下执行，可以看出Lock为我们提供了一种更为优雅的方式来获取锁，本小节的最后，我们对于Lock和synchronized关键字的区别进行归纳总结。</p>
<ol>
<li>锁的获取方式：Lock是通过程序代码的方式由开发者手工获取，而synchronized是通过JVM来获取的（无需开发者干预）。</li>
<li>具体的实现方式：Lock是通过Java代码的方式来实现，synchronized是通过JVM底层来实现（无需开发者关注）。</li>
<li>锁的释放方式：Lock务必通过unlock()方法在finally块中手工释放，synchronized是通过JVM来释放（无需开发者关注）。</li>
<li>锁的具体类型：Lock提供了多种，如公平锁、非公平锁，synchronized与Lock都提供了可重入锁。</li>
</ol>
<h3 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h3><p>在Lock接口中，有一个方法的返回值是Condition，在之前的例子中，我们可以通过sychronized+wait+notify/notifyAll来实现多个线程之间的协调与通信，整个过程都是由JVM来帮助我们实现的，开发者无需（也无法）了解底层的实现细节，从JDK5开始，并发包提供了Lock，Condition(await与signal/signalAll)来实现多个线程之间的协调与通信，整个过程都是由开发者来控制的，相比于传统的方式，更加的灵活，功能也更加强大。接下来我们就来了解一下这个接口的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to </span><br><span class="line">give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary </span><br><span class="line">Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition</span><br><span class="line">replaces the use of the Object monitor methods.</span><br></pre></td></tr></table></figure>

<p>Condition本质上类似于Object对象的监控器的方法（wait,notify和notifyAll），可以让各种不同的对象拥有多个等待集合，是通过使用任意的一个Lock的实现将他们组合起来，我们会使用Lock来替代synchronized方法和代码块的使用，Condition来替换Object对象中的监控器方法的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Conditions (also known as condition queues or condition variables) provide a means for one thread to </span><br><span class="line">suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be </span><br><span class="line">true. Because access to this shared state information occurs in different threads, it must be protected,</span><br><span class="line">so a lock of some form is associated with the condition. The key property that waiting for a condition</span><br><span class="line">provides is that it atomically releases the associated lock and suspends the current thread, just like </span><br><span class="line">Object.wait.</span><br></pre></td></tr></table></figure>

<p>Conditions(也叫做条件队列或者条件变量)提供了一种让一个线程可以挂起执行（让线程进入等待状态）直到另外一个condition为true的线程通知当前线程的方式，由于对于共享的状态信息的访问是发生在不同的线程当中的，因此它必须受到保护，即Lock就一定要关联到一个某个Condition上面，一个关键的属性是，它会自动的释放掉关联的锁然后挂起当前的线程，就行Object.wait方法一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method.</span><br></pre></td></tr></table></figure>

<p>一个Condition实例会被天然的绑定到一个lock上面，要想获得一个特定的Lock实例对应的Condition实例的话，需要使用newCondition()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">As an example, suppose we have a bounded buffer which supports put and take methods. If a take is </span><br><span class="line">attempted on an empty buffer, then the thread will block until an item becomes available; if a put is </span><br><span class="line">attempted on a full buffer, then the thread will block until a space becomes available. We would like to </span><br><span class="line">keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of </span><br><span class="line">only notifying a single thread at a time when items or spaces become available in the buffer. This can </span><br><span class="line">be achieved using two Condition instances.</span><br></pre></td></tr></table></figure>

<p>举个例子，加我们我们有一个有界的缓冲区，支持put和take方法，如果一个take尝试从空的缓冲区获取元素就会被阻塞，直到缓冲区中有新的元素，如果一个put尝试向一个满的缓冲区中添加元素，这个线程也会被阻塞，直到有可用的空闲空间为止，我们将会让等待的put线程和take线程放置在两个等待集合当中，这样我们就可以在条目存在或者空间存在的时候，只通知一个线程，这个是可以通过使用两个Condition实例来做到的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A Condition implementation can provide behavior and semantics that is different from that of the Object </span><br><span class="line">monitor methods, such as guaranteed ordering for notifications, or not requiring a lock to be held when</span><br><span class="line">performing notifications. If an implementation provides such specialized semantics then the </span><br><span class="line">implementation must document those semantics.</span><br></pre></td></tr></table></figure>

<p>Condition实现可以提供与Object的monitor方法是不一样的行为，比如对于通知的确定性的排序，或者在执行通知的时候不要求持有锁，如果某一个实现提供了这样一些专门化的语义，在实现的时候，需要在文档当中记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Note that Condition instances are just normal objects and can themselves be used as the target in a </span><br><span class="line">synchronized statement, and can have their own monitor wait and notification methods invoked. Acquiring</span><br><span class="line">the monitor lock of a Condition instance, or using its monitor methods, has no specified relationship </span><br><span class="line">with acquiring the Lock associated with that Condition or the use of its waiting and signalling methods. </span><br><span class="line">It is recommended that to avoid confusion you never use Condition instances in this way, except perhaps</span><br><span class="line">within their own implementation.</span><br></pre></td></tr></table></figure>

<p>注意Condition实例仅仅就是一个普通的obeject对象，它们自己也可以使用sychronized代码块当中，并且拥有自己的monitor方法，比如wait和notification方法。使用Condition实例获取锁对象，其中的waiting和signalling方法与monitor对象中的方法是没有任何关系的，推荐的做法是避免这种混淆，永远不应该在除了内部实现的地方外使用这种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">When waiting upon a Condition, a &quot;spurious wakeup&quot; is permitted to occur, in general, as a concession to the underlying </span><br><span class="line">platform semantics. This has little practical impact on most application programs as a Condition should always be waited upon </span><br><span class="line">in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of </span><br><span class="line">spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a </span><br><span class="line">loop.</span><br></pre></td></tr></table></figure>

<p>当我们在等待一个Condition为真的时候，一个假的唤醒是允许发生的，通常情况下，作为平台的一种底层的语义，这种对于大多数的程序不会产生什么实际的影响，因为Condition总是在一个while循环当中去等待，去测试这个被唤醒的条件是否被满足了。实现可以自由的移除这种假的唤醒的可能性，但是推荐的做法是开发者确保程序总是能够执行的并且总是放在循环当中的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation</span><br><span class="line">on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and </span><br><span class="line">maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread </span><br><span class="line">may not always be feasible to implement on all platforms.</span><br></pre></td></tr></table></figure>

<p>三种Condition等待的方式（可中断的、不可中断的、基于时间的）在不同的平台上的实现和性能是不一样的，特别的，我们很难去提供这些特性，并且维护具体的语义，比如说排序的保证，更进一步，这种中断进程的挂起实际是要想在所有平台都实现是难做到非常灵活的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of </span><br><span class="line">waiting, nor is it required to support interruption of the actual suspension of the thread</span><br></pre></td></tr></table></figure>

<p>因此，一个实现针对于这几种方式的等待并不要求精确的定义相同的语义或者相同的保证，同样的，也不要求线程实际的挂起的中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface.</span><br></pre></td></tr></table></figure>

<p>实现可以被要求清晰的定义这些语义和保证由每一个等待方法，当一个实现并不支持线程中断的话，必须要遵循定义在这个接口中中断的语义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor </span><br><span class="line">responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after</span><br><span class="line">another action that may have unblocked the thread. An implementation should document this behavior.</span><br></pre></td></tr></table></figure>

<p>由于中断通常暗示着一种取消，因此检查这个中断不是一个频繁的操作，实现可以自由决定，它可以去响应中断，而非正常的这种方法返回，即便是中断是发生在另一个动作之后，实现需要把这个行为记录下来。</p>
<p>以上就是Condition类的所有的说明，接下来我们来阅读一下Condition接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted.</span><br></pre></td></tr></table></figure>

<p>这个方法会使得当前线程进入等待状态，直到signal方法被调用或者被中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling </span><br><span class="line">purposes and lies dormant until one of four things happens:</span><br></pre></td></tr></table></figure>

<p>调用了await方法之后，与Condition所关联的lock会被自动的释放，当前的线程将无法进行线程调度，并且进入休眠状态，直到下面的四种情况之一发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be </span><br><span class="line">awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>

<ul>
<li>另外一个线程调用了当前线程的signal方法，并且当前的线程恰好是被选中的线程；</li>
<li>另外一个线程调用了signalAll方法；</li>
<li>另外一个线程中断了当前的线程，并且线程是可以中断的；</li>
<li>虚假唤醒出现了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When </span><br><span class="line">the thread returns it is guaranteed to hold this lock.</span><br></pre></td></tr></table></figure>

<p>在以上的四种情况中，在调用了await方法能够返回之前，当前的线程必须要重新获取到与这个condition对应的lock。当线程返回的时候，我们可以保证获取到了lock。</p>
<p>如果当前的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">has its interrupted status set on entry to this method; or</span><br><span class="line">is interrupted while waiting and interruption of thread suspension is supported,</span><br></pre></td></tr></table></figure>

<ul>
<li>当前的线程在进入到这个方法的时候，已经设置了中断的状态；</li>
<li>等待的时候被中断了，并且线程的中断是支持的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">then InterruptedException is thrown and the current thread&#x27;s interrupted status is cleared. It is not specified, in the first</span><br><span class="line">case, whether or not the test for interruption occurs before the lock is released.</span><br></pre></td></tr></table></figure>

<p>就会抛出InterruptedException异常，当前线程的状态也会被清理掉，在一种情况下，在释放锁之前，无论是否测试了中断，都是如此。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the </span><br><span class="line">implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as </span><br><span class="line">IllegalMonitorStateException) and the implementation must document that fact.</span><br></pre></td></tr></table></figure>

<p>当前线程在调用await方法的时候，被假定要持有与Condition相关联的锁，这个取决于具体的实现是否要满足这种条件，如果不满足，应该如何应对，典型的，可以抛出异常（IllegalMonitorStateException），实现必须要将这个情况记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the </span><br><span class="line">implementation must ensure that the signal is redirected to another waiting thread, if there is one</span><br></pre></td></tr></table></figure>

<p>实现也可以选择去响应一个中断而不是通常的方法的返回，在这种情况下，如果有的另外一个线程，实现也必须signal会重定向到另外一个线程。</p>
<p>接下来是awaitUninterruptibly方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>awaitUninterruptibly方法会使得线程进入等待状态，直到下面三种情况之一发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>

<p>与await方法唯一不同的是，这个方法并不回应中断。</p>
<p>接下来是awaitNanos方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses.</span><br></pre></td></tr></table></figure>

<p>调用awaitNanos，会导致当前的线程进入等待状态直到被signal或者被中断或者指定的时间已经过去了，直到下面五种情况有一个发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</span><br><span class="line">The specified waiting time elapses; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>

<p>可以看到与await方法不同的地方在于，指定的等待时间已经过去了，就会返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The method returns an estimate of the number of nanoseconds remaining to wait given the supplied nanosTimeout value upon</span><br><span class="line">return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-</span><br><span class="line">wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the </span><br><span class="line">following form:</span><br></pre></td></tr></table></figure>

<p>这个方法会返回一个近似的纳秒的时间，这个时间是给定时间的剩余的时间，还有可能返回的是一个小于或者等于零的值，这意味着超时了。这个值可以用来是否以及多长时间重新的等待，典型的使用场景是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionBeingWaitedFor()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      nanos = theCondition.awaitNanos(nanos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss </span><br><span class="line">would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when </span><br><span class="line">re-waits occur.</span><br></pre></td></tr></table></figure>

<p>这个方法需要的是一个纳秒的参数来去避免一个截断上的错误再去返回剩余时间，使用它来确保整体的等待时间，这种精度的损失可能对于程序员而言是非常困难的。</p>
<p>接下来是另外一个await方法的重载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. This method is behaviorally equivalent to:</span><br><span class="line">  awaitNanos(unit.toNanos(time)) &gt; 0</span><br></pre></td></tr></table></figure>

<p>这个方法实际上是awaitNanos方法的一个变形，实际上的实现等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awaitNanos(unit.toNanos(time)) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>接下来是awaitUntil方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>一种典型的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aMethod</span><span class="params">(Date deadline)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> stillWaiting = <span class="keyword">true</span>;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionBeingWaitedFor()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!stillWaiting)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      stillWaiting = theCondition.awaitUntil(deadline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上都是针对于await方法的一些变形和衍生，本质上并没有什么差别。</p>
<p>接下来是signal方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wakes up one waiting thread.</span><br><span class="line">If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock </span><br><span class="line">before returning from await.</span><br></pre></td></tr></table></figure>

<p>该方法用于唤醒一个等待的线程，如果有多个线程在condition上等待，那么就会选择其中的一个进行唤醒，在返回await方法之前，被唤醒的线程必须获取到lock，而具体唤醒哪一个线程取决于具体的实现。</p>
<p>最后是signalAll方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wakes up all waiting threads.</span><br><span class="line">If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from await.</span><br></pre></td></tr></table></figure>

<p>该方法会唤醒所有处于等待状态的线程，如果有多个线程在condition上等待，那么它们都会被唤醒。每个线程都要获取到lcok才能从awit方法返回。</p>
<h3 id="Condition实践"><a href="#Condition实践" class="headerlink" title="Condition实践"></a>Condition实践</h3><p>Thread.sleep与await（或是Object的wait方法）的本质区别：sleep方法本质上不会释放锁，而await会释放锁，并且在signal后，还需要重新获取到锁才能继续执行（该行为与Object的wait方法完全一致）。</p>
<p>接下来我们通过一个具体的例子来了解Condition的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] elements = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notEmptyCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notFullCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组中已有元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置元素索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取元素索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放置元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 需要放置的目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String element)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.elementCount == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                notFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            elements[putIndex] = element;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++putIndex == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                putIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++elementCount;</span><br><span class="line">            System.out.println(<span class="string">&quot;put method: &quot;</span> + Arrays.toString(elements));</span><br><span class="line">            notEmptyCondition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmptyCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            String element = elements[takeIndex];</span><br><span class="line">            elements[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++takeIndex == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                takeIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --elementCount;</span><br><span class="line">            System.out.println(<span class="string">&quot;take method: &quot;</span> + Arrays.asList(elements));</span><br><span class="line">            notFullCondition.signal();</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写入口类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BoundedContainer boundedContainer = <span class="keyword">new</span> BoundedContainer();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                boundedContainer.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start());</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                boundedContainer.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">put method: [hello, null, null, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, null, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, hello, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, hello, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, null, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, null, null]</span><br></pre></td></tr></table></figure>

<h3 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h3><p>volatile本身的含义的是不稳定的意思，总体而言，volitle关键字主要有三方面的作用：</p>
<ol>
<li>实现long/double类型变量的原子操作</li>
<li>防止指令重排序</li>
<li>实现变量的可变性</li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢您的支持！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="吉永超 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>吉永超
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jycoder.club/2020/10/05/Concurrency/" title="Java并发编程">https://jycoder.club/2020/10/05/Concurrency/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/16/SpringCloud/" rel="prev" title="SpringCloud">
      <i class="fa fa-chevron-left"></i> SpringCloud
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/07/Interview/" rel="next" title="面试题精选">
      面试题精选 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">并发编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Java并发编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.</span> <span class="nav-text">线程简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E5%92%8CRunnable"><span class="nav-number">1.3.</span> <span class="nav-text">Thread和Runnable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait%E3%80%81sleep%E5%92%8Cnotify"><span class="nav-number">1.4.</span> <span class="nav-text">wait、sleep和notify</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">方法简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.4.2.</span> <span class="nav-text">方法实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.5.</span> <span class="nav-text">synchronized详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E7%AE%80%E4%BB%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">synchronized简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.5.2.</span> <span class="nav-text">synchronized字节码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monitor"><span class="nav-number">1.6.</span> <span class="nav-text">Monitor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B"><span class="nav-number">1.6.1.</span> <span class="nav-text">自旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">1.6.2.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monitor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.6.3.</span> <span class="nav-text">Monitor源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E3%80%81notify%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.6.4.</span> <span class="nav-text">wait、notify源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">1.6.5.</span> <span class="nav-text">锁升级与偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%B2%97%E5%8C%96%E4%B8%8E%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">1.6.6.</span> <span class="nav-text">锁粗化与锁消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">1.6.7.</span> <span class="nav-text">死锁及死锁检测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#concurrent%E5%B9%B6%E5%8F%91%E5%8C%85"><span class="nav-number">2.</span> <span class="nav-text">concurrent并发包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">2.1.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">锁的机制与原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">Condition简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.1.3.</span> <span class="nav-text">Condition实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.1.4.</span> <span class="nav-text">Volatile关键字</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">吉永超</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:jyccoder@gmail.com" title="E-Mail → mailto:jyccoder@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吉永超</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">710k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:46</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
