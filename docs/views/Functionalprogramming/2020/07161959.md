---
title: 函数式接口
date: 2020-07-16
categories:
 - Functionalprogramming
author: jyc

---

函数式接口是函数式编程中最重要的概念，函数式编程与传统的编码方式相比最明显的区别就是，它允许把函数（或者说表达式）当成参数传递给另一个函数，在其他编程语言中，Lambda表达式的类型是函数，但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象--函数式接口（functional interface）。

## 函数式接口定义

在之前的这个例子中：
``` java
public class LambdaTest {

    public static void main(String[] args) {
        List<String> list = Arrays.asList("hello","world","hello world");
        list.forEach(item-> System.out.println(item));
    }
}
```
点击箭头就会进入到一个接口当中：
``` java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);

    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```
可以看到这个接口上有一个@FunctionInterface的注解，点击这个注解进入，就可以看到这样一段JavaDoc:
```java
/**
 * An informative annotation type used to indicate that an interface
 * type declaration is intended to be a <i>functional interface</i> as
 * defined by the Java Language Specification.
 *
 * Conceptually, a functional interface has exactly one abstract
 * method.  Since {@linkplain java.lang.reflect.Method#isDefault()
 * default methods} have an implementation, they are not abstract.  If
 * an interface declares an abstract method overriding one of the
 * public methods of {@code java.lang.Object}, that also does
 * <em>not</em> count toward the interface's abstract method count
 * since any implementation of the interface will have an
 * implementation from {@code java.lang.Object} or elsewhere.
 *
 * <p>Note that instances of functional interfaces can be created with
 * lambda expressions, method references, or constructor references.
 *
 * <p>If a type is annotated with this annotation type, compilers are
 * required to generate an error message unless:
 *
 * <ul>
 * <li> The type is an interface type and not an annotation type, enum, or class.
 * <li> The annotated type satisfies the requirements of a functional interface.
 * </ul>
 *
 * <p>However, the compiler will treat any interface meeting the
 * definition of a functional interface as a functional interface
 * regardless of whether or not a {@code FunctionalInterface}
 * annotation is present on the interface declaration.
 *
 * @jls 4.3.2. The Class Object
 * @jls 9.8 Functional Interfaces
 * @jls 9.4.3 Interface Method Body
 * @since 1.8
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface {}
```
我们一行一行来仔细阅读一下这段文档：
``` txt
 An informative annotation type used to indicate that an interface
 type declaration is intended to be a <i>functional interface</i> as
 defined by the Java Language Specification.
```
这里说，@FunctionInterface这个注解，它使用Java语言规范定义，使用通知性的annotation,来声明函数式接口，换言之，如果一个接口上使用了@FunctionInterface这个注解，那么这个接口就是函数式接口。

那么到底什么是函数式接口呢？继续往下看：
```txt
 Conceptually, a functional interface has exactly one abstract
 method.  Since {@linkplain java.lang.reflect.Method#isDefault()
 default methods} have an implementation, they are not abstract.  If
 an interface declares an abstract method overriding one of the
 public methods of {@code java.lang.Object}, that also does <em>not</em> count toward the interface's abstract method count since any implementation of the interface will have an implementation from {@code java.lang.Object} or elsewhere.
```
一个函数式接口，它只有一个精确的抽象方法，也就是说，有且仅有一个抽象方法，那么这个接口就被称为函数式接口（在jdk8中，除了抽象方法外还可以定义default method和static method，不一定都是抽象方法），并且如果这个抽象方法是Object类中的方法，不会计入这个接口的抽象方法数量。需要注意的是，可以通过Lambda表达式来创建，方法引用来创建，或者构造方法的引用来创建函数式接口的实例。

关于Lambda表达式的创建会在后续的文章中详细讲解，这里只需要大概了解函数式接口实例创建的方式有这么三种。我们继续往下：
``` txt
  <p>Note that instances of functional interfaces can be created with
  lambda expressions, method references, or constructor references.
 
  <p>If a type is annotated with this annotation type, compilers are
  required to generate an error message unless:
 
  <ul>
  <li> The type is an interface type and not an annotation type, enum, or class.
  <li> The annotated type satisfies the requirements of a functional interface.
  </ul>
  <p>However, the compiler will treat any interface meeting the
  definition of a functional interface as a functional interface
  regardless of whether or not a {@code FunctionalInterface}
  annotation is present on the interface declaration.
```
如果一个接口上有@FunctionInterface这个注解，如果不满足以下情况编译器会报错：
* 被注解的是一个接口类型，而不是一个注解类型，而是枚举或者类；
* 被注解的类型满足函数式接口的定义；

例如，创建线程时需要用到的Runnable接口：
``` java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```
可以看到这个接口从JDK8开始就加上了@FunctionalInterface这个注解，换句话说，Runnable接口现在变成了函数式接口，我们可以通过Lambda表达式来创建Runnable接口的实例。

在上面的文档中，还有最后一段话：
``` txt
  <p>However, the compiler will treat any interface meeting the
  definition of a functional interface as a functional interface
  regardless of whether or not a {@code FunctionalInterface}
  annotation is present on the interface declaration
```
然而，编译器其实会自动为满足函数式接口定义的接口添加@FunctionalInterface注解，也就是说，如果一个接口满足了函数式接口的定义，即便我们没有给他加上@FunctionalInterface这个注解，编译器会自动将它看成是函数式接口。

总的来说，关于函数式接口的定义如下：

1.如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口
2.如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口
3.如果某个接口只有一个抽象方法，但我们并没有对该接口声明FunctionalInterface注解，编译器依旧会将该接口看作是函数式接口。

再以这个接口为例：
``` java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);

    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```
可以看到，在这个接口中，除了一个抽象方法accept()方法外，还有一个default默认方法andThen()，但是总的来说还是只有一个抽象方法，所以满足函数式接口的定义。

再比如：
``` java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);  

    default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }
    default Predicate<T> negate() {
        return (t) -> !test(t);
    }

    default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }

    static <T> Predicate<T> isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -> targetRef.equals(object);
    }
}
```
同样的，这个接口中只有一个抽象方法test()，除此之外，有3个default默认方法，有一个static方法，因此同样满足函数式接口的定义。

再比如：
``` java
@FunctionalInterface
public interface MyInterface {

    void test();

    String toString();

}
```
这个接口中看起来有两个抽象方法，但toString()方法是基类Object中的方法，因此在检查函数式接口的定义的时候，它并不算数，因为Object类是所有类的父类，所有的类默认已经有了这个方法，如果算的话，其实是没有意义的，所以在定义函数式接口的时候，Object类中方法并不会对函数式接口的方法的数量变化。

在JDK8中的提供了大量的现成的函数式接口供我们使用，以之前我们使用forEach()为例：

``` java
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
```
其实forEach()方法接收的函数式接口就是我们上面举得第一个例子Consumer，然后调用Consumer接口中的accept方法，诸多的函数式接口，为我们方便的传递各种不同需求的行为提供了可能。

## 为什么是函数式接口？

在前面我们了解了函数式接口的概念之后，我们来具体看一个例子：
``` java
@FunctionalInterface
interface MyInterface {
    void test();

    @Override
    String toString();
}

public class FunctionalInterfaceTest {
    public static void main(String[] args) {

    }
}
```
我们定义了一个接口，MyInterface，这个接口中有两个抽象方法，但由于toString()是继承自Obeject类中的方法，所以并不会对这个接口的抽象方法的总数有影响，还是只有一个抽象方法，那么显然，它满足函数式接口的定义。

首先我们使用传统的匿名内部类的方式来实现MyInterface中的test()方法：
```java
@FunctionalInterface
interface MyInterface {
    void test();

    @Override
    String toString();
}

public class FunctionalInterfaceTest {

    public void MyTest(MyInterface myInterface) {
        System.out.println(1);
        myInterface.test();
        System.out.println(2);
    }
    public static void main(String[] args) {
        FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest();
        functionalInterfaceTest.MyTest(new MyInterface() {
            @Override
            public void test() {
                System.out.println("myTest");
            }
        });
    }
}
```
MyInterface既然满足函数式接口的定义，那么就意味着我们可以使用Lambda表达式的方式来创建MyInterface的实例：
``` java
@FunctionalInterface
interface MyInterface {
    void test();

    @Override
    String toString();
}

public class FunctionalInterfaceTest {

    public void MyTest(MyInterface myInterface) {
        System.out.println(1);
        myInterface.test();
        System.out.println(2);
    }
    public static void main(String[] args) {
        FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest();
        functionalInterfaceTest.MyTest(() -> System.out.println("myTest"));
    }
}
```
这两种写法的运行结果完全是等价的，编译器会自动根据上下文，来推测出 functionalInterfaceTest.MyTest()中需要接收的参数的类型，也就是说，() -> System.out.println("myTest")就是MyInterface 的一个实例，由于函数式接口中只会有一个抽象方法，那么对于这个Lambda表达式而言，箭头左边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的参数，右边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的实现，由于test()方法的参数是空值，所以左边的括号是空值。

这样看起来，其实MyInterface 这个接口中的抽象方法，具体叫什么名字，反而没有那么重要了，当然虽然这个函数的名字我们并不会直接去调用，但在起名字的时候，最好还是要有意义。

可能初学者并不能直观的认识到() -> System.out.println("myTest")表达的具体含义，我们可以换一种写法：
``` java
interface MyInterface {
    void test();

    @Override
    String toString();
}

public class FunctionalInterfaceTest {

    public void MyTest(MyInterface myInterface) {
        System.out.println(1);
        myInterface.test();
        System.out.println(2);
    }
    public static void main(String[] args) {
        FunctionalInterfaceTest functionalInterfaceTest = new FunctionalInterfaceTest();
        MyInterface myInterface = () -> System.out.println("myTest")
        functionalInterfaceTest.MyTest(myInterface);
    }
}
```
程序运行的效果是完全等价的，使用这种写法，我们就更能直观的体会到，() -> System.out.println("myTest")其实就是MyInterface的一个具体实现。

前面我们提到过，在Java中，Lambda表达式需要依赖于函数式接口这样一种特殊的形式，实际上，对于一个特定的Lambda表达式是什么类型的，是需要上下文才能解读的，来看这样一个例子：
``` java
public class Essence {
    public static void main(String[] args) {

        InterfaceTestA interfaceTestA = () -> {};
        
        InterfaceTestB interfaceTestB = () -> {};
    }
}

interface InterfaceTestA {

    void myMethod();
}

interface InterfaceTestB {

    void myMethod2();
}
```
可以看到，对于这两个不同的函数式接口的实现都是() -> {}这同一种实现，对于这个特定的Lambda表达式，必须要联系他的上下文才能知道：
``` txt
 InterfaceTestA interfaceTestA
```
和
``` txt
 InterfaceTestB interfaceTestB
```
就是这两个Lambda表达式的上下文。

我们再回到遍历List集合的例子中：
``` java
public class LambdaTest {

    public static void main(String[] args) {
        List<String> list = Arrays.asList("hello","world","hello world");
        list.forEach(item-> System.out.println(item));
    }
}
```
点击forEach方法，就会自动跳转到：
``` java

    /**
     * Performs the given action for each element of the {@code Iterable}
     * until all elements have been processed or the action throws an
     * exception.  Unless otherwise specified by the implementing class,
     * actions are performed in the order of iteration (if an iteration order
     * is specified).  Exceptions thrown by the action are relayed to the
     * caller.
     *
     * @implSpec
     * <p>The default implementation behaves as if:
     * <pre>{@code
     *     for (T t : this)
     *         action.accept(t);
     * }</pre>
     *
     * @param action The action to be performed for each element
     * @throws NullPointerException if the specified action is null
     * @since 1.8
     */
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
```
首先它是一个默认方法，接收的参数类型是Consumer，遍历这个集合，对集合中的每个元素执行Consumer中的accept()方法。

不妨来读一下这段文档：
 ``` txt
      Performs the given action for each element of the {@code Iterable}
      until all elements have been processed or the action throws an
      exception.  Unless otherwise specified by the implementing class,
      actions are performed in the order of iteration (if an iteration order
      is specified).  Exceptions thrown by the action are relayed to the
      caller
 ```
针对于Iterable每一个元素去执行给定的动作，换句话说，这里并不是将值作为参数，而是将行为作为参数进行传递，执行到集合中所有的元素执行完或者抛出异常为止，如果没有被实现类所指定的话，那么动作就会按照迭代的顺序去执行，是不是抛出异常取决于调用者。

其实这里最关键的就是Consumer这个参数，接下来我们重点分析Consumer这个函数式接口。