<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringCloud</title>
    <url>/2020/07/16/SpringCloud/</url>
    <content><![CDATA[<p>==SpringCloud==</p>
<span id="more"></span>
<h1 id="Feign中使用动态服务名"><a href="#Feign中使用动态服务名" class="headerlink" title="Feign中使用动态服务名"></a>Feign中使用动态服务名</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicFeignClient</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FeignClientBuilder feignClientBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicFeignClient</span><span class="params">(<span class="meta">@Autowired</span> ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.feignClientBuilder = <span class="keyword">new</span> FeignClientBuilder(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFeignClient</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.feignClientBuilder.forType(type, serviceName).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DynamicFeignClient&lt;ISysDictClient&gt; client;</span><br><span class="line"><span class="comment">// 获取到Feign客户端</span></span><br><span class="line">client.getFeignClient(ISysDictClient.class, serviceName).method(...);</span><br></pre></td></tr></table></figure>

<h1 id="Feign的实现原理"><a href="#Feign的实现原理" class="headerlink" title="Feign的实现原理"></a>Feign的实现原理</h1><p><a href="https://www.cnblogs.com/binarylei/p/11563023.html">https://www.cnblogs.com/binarylei/p/11563023.html</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode in Java</title>
    <url>/2021/06/24/leetcode/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2020/07/16/SpringBoot/</url>
    <content><![CDATA[<p>==SpringBoot==</p>
<span id="more"></span>
<h1 id="SpringBoot启动原理"><a href="#SpringBoot启动原理" class="headerlink" title="SpringBoot启动原理"></a>SpringBoot启动原理</h1><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>在SpringBoot项目中，一般情况下都有且仅有一个启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中@SpringBootApplication注解是SpringBoot的核心注解，它其实是一个组合注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中重要的有三个Annotation：</p>
<ol>
<li>@Configuration（@SpringBootConfiguration也是应用了@Configuration）</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ol>
<p>即SpringBoot项目的启动类也可以这么写（优化SpringBoot项目的启动时间就可以将注解拆开来写，缩小包扫描的范围）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>这里的@Configuration与JavaConfig形式的Spring IoC容器的配置类使用的@Configuration注解作用相同，启动类加上这个注解之后，本身就变成了IoC容器的配置类。</p>
<p>@Configuration的注解类标识这个类可以使用Spring IoC容器作为Bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的Bean。</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>@ComponentScan的功能是自动扫描并加载符合条件的组件（比如@Component和@Repository以及其他衍生注解）或者Bean定义，最终将这些Bean定义加载到IoC容器当中。</p>
<p>可以通过@ComponentScan的一些属性来进行细粒度的定制自动扫描的范围，如果不指定，Spring框架实现默认会从启动类所在的类的包进行扫描，所以启动类最好是放在所有的业务代码的外层，但如果要放在根目录（com包）下需要谨慎，低版本的SpringBoot会有一些兼容性的问题。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@EnableAutoConfiguration借助@Import的支持，收集和注册特定场景相关的Bean定义，在SpringBoot中还有一些与之类似的注解：</p>
<ul>
<li>@EnableScheduling是通过@Import将Spring调度框架相关的Bean定义都加载到IoC容器</li>
<li>@EnableMBeanExport是通过@Import将JMX相关的Bean定义加载到IoC容器</li>
<li>@EnableCaching是通过@Impotr将将缓存相关的Bean定义加载到IoC容器</li>
</ul>
<p>@EnableAutoConfiguration也是通过@Import将所有符合自动装配条件的Bean定义加载到IoC容器，会根据类路径中的jar依赖为项目进行自动配置，如：添加了spring-boot-starter-web依赖，会自动添加Tomcat和Spring MVC的依赖，SpringBoot会对Tomcat和Spring MVC进行自动配置。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQeiaPHgzp5kO2TicvJwMicpfTpsvPcOaNGobPWQoTUywEicPlgiabMIavTNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>@EnableAutoConfiguration作为一个复合Annotation，其自身定义关键信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助AutoConfigurationImportSelector，SpringBoot可以将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器，借助Spring框架的一个工具类SpringFactoriesLoader，@EnableAutoConfiguration可以智能的完成自动配置的功能。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQzmAj46icFN8ATeAbRhibHNmvNLt8zniczDnVPEIvBHEDSv8WZ38hoSkXg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在这其中，SpringFactoriesLoader扮演者十分重要的角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配合@EnableAutoConfiguration使用的话，它更多提供了一种配置查找的功能支持，即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找key，获取对应一组的@Configure类。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQeU3e08gDViaUrnokSZHP6zpQnticuQc0EbZrZK2FSJ7W5rLTA4rF9eNw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>总的来说，@EnaleAutoConfiguration的作用是从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项，通过反射实例化为标注了@Configuration的JavaConfig形式的IoC容器配置类，然后加载到IoC容器当中。</p>
<h2 id="启动执行流程"><a href="#启动执行流程" class="headerlink" title="启动执行流程"></a>启动执行流程</h2><h3 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h3><ol>
<li>使用SpringApplication的静态的run方法，而这个静态的run方法最终会调用SpringApplication实例的run方法，因此首先需要创建一个SpringApplication对象实例，然后调用这个创建号的SpringApplication的实例方法，在SpringApplication实例初始化的时候，它会提前做几件事情：<ul>
<li>根据classpath里面是否存在某个特征类org.springframework.boot.ConfigurableWebApplicationContext来决定是否应该创建一个Web应用使用的ApplicationContext类型</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可能的ApplicationContextInitializer</li>
<li>使用SpringFactories在应用的classpath中查找并加载所有可能的ApplicationListener</li>
<li>推断并设置main方法的定义类</li>
</ul>
</li>
<li>SpringApplication实例初始化完成并且完成设置后，就可以开始执行run方法的逻辑了，首先遍历执行所有通过SpringFactories可以查找到并加载的SpringApplicationRunListener，调用他们的started()方法</li>
<li>创建并配置当前SpringBoot应用将要使用的Environment（包括要使用的PropertySource以及Profile）、</li>
<li>调用所有的SpringApplicationRunListener的environmentPrepared()的方法</li>
<li>如果SpringApplication的showBanner属性被设置为true，则打印banner</li>
<li>根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，并且将之前准备好的Environment设置给创建好的ApplicationContext使用</li>
<li>ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理</li>
<li>遍历所有SpringApplicationRunListener的contextPrepared()方法</li>
<li>最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext</li>
<li>遍历调用所有SpringApplicationRunListener的contextLoaded()方法</li>
<li>调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序</li>
<li>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们</li>
<li>正常情况下，遍历执行SpringApplicationListener的finished()方法（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将一场信息一并传入处理</li>
</ol>
<p>去掉事件通知点后，整体流程大体如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQbNicaeuHicrIdruCcP5eQ981LjIgb8vSv7PbI3XSRCEs07jq6bUBvoSw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>简单一点，也可以将启动流程分为三个部分：</p>
<ol>
<li>第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器</li>
<li>第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块</li>
<li>第三部分是自动化配置模块，该模块是SpringBoot自动配置的核心。</li>
</ol>
<h3 id="启动详情"><a href="#启动详情" class="headerlink" title="启动详情"></a>启动详情</h3><p>首先进入run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource,</span></span></span><br><span class="line"><span class="params"><span class="function">		String... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到调用了重载的run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="params"><span class="function">		String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>依然是一个静态方法，这里首先要构造一个SpringApplication实例，然后再调用实例的run方法，这里的构造方法也有重载的版本，最终调用的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">   Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">   <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">   setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">         ApplicationContextInitializer.class));</span><br><span class="line">   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">   <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		configureHeadlessProperty();</span><br><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">		listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">					args);</span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">					applicationArguments);</span><br><span class="line">			configureIgnoreBeanInfo(environment);</span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">					SpringBootExceptionReporter.class,</span><br><span class="line">					<span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">			refreshContext(context);</span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">						.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中有几个关键步骤：</p>
<ol>
<li><p>创建了应用的见同期SpringApplicationRunListeners并开始监听</p>
</li>
<li><p>加载SpringBoot配置环境（ConfigurableEnvironment），如果是通过Web容器发布，会加载StandardEnvironment，其最终也是集成了ConfigurableEnvironment，类图如下</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQurfYCoiaPsiaBBeBrCWOHMTHwl7mQ6iaYqKYMoRbT2bz6270LohsDndIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>配置环境（Environment）加入到监听器对象中（SpringApplicationRunListeners）</p>
</li>
<li><p>创建run方法的返回对象：ConfigurableApplicationContext（应用配置上下文），创建方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">	<span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">			<span class="keyword">case</span> SERVLET:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REACTIVE:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">					<span class="string">&quot;Unable create a default ApplicationContext, &quot;</span></span><br><span class="line">							+ <span class="string">&quot;please specify an ApplicationContextClass&quot;</span>,</span><br><span class="line">					ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法会先获取显示设置的应用上下文（appcationContextClass），如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载Bean），最后通过BeanUtils实例化上下文对象，并返回。</p>
</li>
<li><p>回到run方法内，prepareContext方法将listeners、enviroment、applicationArguments、banner等重要组件与上下文对象关联</p>
</li>
<li><p>加下来的refreshContext(context)方法（方法如下）是实现spring-boot-starter-*等自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line">   </span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">   </span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line">   </span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>配置结束后，SpringBoot做了一些基本的收尾工作，返回了应用环境上下文。总体而言，SpringBoot的启动，主要创建了配置环境（environment）、事件监听（listener）、应用上下文（applicationContex），并基于以上条件，在容器中开始实例化我们需要的Bean，最终完成SpringBoot的启动，这里面有一个核心就是自动化装配。</p>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>在整个SpringBoot启动过程中，多出都调用了SpringBoot的自动装配模块</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQn8nK36PPIsEBpXXjQmX8ibniaohz5ahOYM5WnyicjgdYFa0Libxaztg6CQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>该配置模块主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称对应的类加载器，方法会根据指定的classLoader，加载该类加载器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为下入这种一对多的类型集合，或者到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQu9QicvqeO7RicwHibtCVtibnQHLmGxuKm0jw1ttR5mjBrqCIolBibRRo3icw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>自动配置流程如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQFztFbwUteZ16sVKv9RoEl7o63sT4buwBdBBFQ82w7Q581ntceUqx8w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>mybatis-spring-boot-starter</code>、<code>spring-boot-starter-web</code>等组件的META-INF文件下均含有<code>spring.factories</code>文件，自动配置模块中，<code>SpringFactoriesLoader</code>收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p>
<p>之前我们提到了<code>EnableAutoConfiguration</code>注解，其类图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQr8IZpibDYUkTRzFA4j2WWw7YFiciaZevFuxH1oSxMd0Jr7drDmILq3YMw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以发现其最终实现了<code>ImportSelector</code>(选择器)和<code>BeanClassLoaderAware</code>(bean类加载器中间件)，重点关注一下<code>AutoConfigurationImportSelector</code>的<code>selectImports</code>方法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQticdcJNNcF5hWVAA4a5xib1D3qhoRf1lW9xQibDxiavYj2Ieicvzq7od95w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQ7W4R5zDIcXoGv7Z12BlbAoqGQPGoR19rSFahPsiaqWfTLRqh7pZUQyA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>该方法中的<code>getCandidateConfigurations</code>方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了<code>loadFactoryNames</code>方法，查看该方法</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQGplWq8vdg5cDrXzLPyKPUZxgG5f1mN7eDYFaqrPfygKGib9QCWsmFTQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在上面的代码可以看到自动配置器会根据传入的<code>factoryClass.getName()</code>到项目系统路径下所有的<code>spring.factories</code>文件中找到相应的key，从而加载里面的类。我们就选取这个<code>mybatis-spring-boot-autoconfigure</code>下的<code>spring.factories</code>文件</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQBR85MD5HgVeib7Juia527ia5DedXvMDoZwibXtUvwIcIib3UsA1Z6eFKWgQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>进入<code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code>中，主要看一下类头：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQvDDF5STJSTOC9e5Nvou7NoyvgkdZHiam1ic8Hnz1cknuRM8lMLmVWicxw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>发现Spring的<code>@Configuration</code>，俨然是一个通过注解标注的springBean，继续向下看</p>
<ul>
<li><code>@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</code>：当存在<code>SqlSessionFactory.class</code>, <code>SqlSessionFactoryBean.class</code>这两个类时才解析<code>MybatisAutoConfiguration</code>配置类，否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类</li>
<li><code>@CondtionalOnBean(DataSource.class)</code>：只有处理已经被声明为bean的dataSource</li>
<li><code>@ConditionalOnMissingBean(MapperFactoryBean.class)</code>这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</li>
</ul>
<p>以上配置可以保证<code>sqlSessionFactory、sqlSessionTemplate、dataSource</code>等mybatis所需的组件均可被自动配置，<code>@Configuration</code>注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。</p>
<p>通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在<code>SqlSessionFactory.class</code>, <code>SqlSessionFactoryBean.class</code>，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。</p>
<p>所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQKZibKhZCCVt3rXV9LD20lGHnKkLVfVjicblW5KJUQJnjHicxDicjB1WGYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里是截取的<code>mybatis-spring-boot-starter</code>的源码中pom.xml文件中所有依赖：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWyfMiax0ryO6Hs4SYOv1IzQTkmkxUoCMn3p5VBepEyVVA9YMKEiaJibrLsSDSeb1tibd20HiciauZx0S2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>因为maven依赖的传递性，我们只要依赖starter就可以依赖到所有需要自动配置的类，实现开箱即用的功能。也体现出Springboot简化了Spring框架带来的大量XML配置以及复杂的依赖管理，让开发人员可以更加关注业务逻辑的开发。</p>
<h1 id="SpringBoot打包"><a href="#SpringBoot打包" class="headerlink" title="SpringBoot打包"></a>SpringBoot打包</h1><h2 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h2><p>在Spring Boot应用中，我们可以约定不同的标识来定义不同的环境。例如 <code>dev</code> 表示开发环境、<code>test</code>表示测试环境，对应的配置文件为<code>application-dev.yaml</code>、<code>application-test.yaml</code>。我们通过声明<code>spring.profiles.active</code>来激活对应的环境配置，例如激活<code>dev</code>环境时<code>spring.profiles.active=dev</code>。完整的启动命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.security.egd=file:/dev/./urandom  -Dspring.profiles.active=dev -jar spring-boot-app.jar </span><br></pre></td></tr></table></figure>

<p>根据上面的命令编写一个能够适应多环境的<strong>Dockerfile</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 引入 openjdk 镜像</span></span><br><span class="line">FROM adoptopenjdk/openjdk8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 声明作者</span></span><br><span class="line">LABEL AUTHOR=felord OG=felord.cn</span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载几个有用的文件夹 比如日志</span></span><br><span class="line">VOLUME [&quot;/tmp&quot;,&quot;/logs&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 声明一个环境参数用来动态启用配置文件 默认dev</span></span><br><span class="line">ENV ACTIVE=dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暴露端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制并修改应用打包后的jar文件名称</span></span><br><span class="line">ADD /target/flyway-spring-boot-1.0.0.jar app.jar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器启动时第一个运行的命令 用来启动应用</span></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-Dspring.profiles.active=$&#123;ACTIVE&#125;&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>这样打包的Docker镜像就可以通过<code>docker run</code>添加额外的<code>--env ACTIVE=test</code> 来动态的改变环境。单纯的编写<strong>Dockerfile</strong>不方便我们DevOps。</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCvwCLZQv6fq6zEjyuBXHd9C5licH3DdoibYfYXGaQOZMiaibyQdeoyHGibNRfiab5Z2Z9Es2jX8DickH4hJw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们需要能够自动地构建、推送到仓库、拉取镜像、运行一系列流水线操作。好在市面上有很多工具来帮助我们实现这一过程。</p>
<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><h3 id="spring-boot-maven-plugin"><a href="#spring-boot-maven-plugin" class="headerlink" title="spring-boot-maven-plugin"></a>spring-boot-maven-plugin</h3><p>这个是Spring Boot官方的插件，在2.x的某个版本提供了Docker镜像构建能力。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>docker.repo.com/library/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">publish</span>&gt;</span>true<span class="tag">&lt;/<span class="name">publish</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">docker</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">publishRegistry</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">username</span>&gt;</span>user<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">password</span>&gt;</span>secret<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://docker.repo.com/v1/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">email</span>&gt;</span>user@example.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">publishRegistry</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">docker</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置好Docker私仓后就可以通过<code>mvn clean spring-boot:build-image</code> 进行构建镜像了，这种方式好处就是无额外依赖，缺点就是需要从github下载构建元件，网络如果不好就容易失败。</p>
<h3 id="Spotify-Maven-Plugin"><a href="#Spotify-Maven-Plugin" class="headerlink" title="Spotify Maven Plugin"></a>Spotify Maven Plugin</h3><p>Spotify Maven 插件是一个目前比较普遍的选择。它要求应用程序开发人员编写<strong>Dockerfile</strong>，并把<code>Dockerfile</code>放在项目<code>src/main/docker</code>目录下。然后你就可以通过引入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">repository</span>&gt;</span>repo.com/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个插件提供了<code>mvn dockerfile:build</code>、<code>mvn dockerfile:tag</code>、<code>mvn dockerfile:push</code>三个命令分别用来构建、打标签、发布到远端私有仓库，非常简单。</p>
<p>这个是一个非常容易上手的插件，唯一的要求就是需要会编写Dockerfile，对定制化要求高的可以使用这个。</p>
<h3 id="Jib-Maven-Plugin"><a href="#Jib-Maven-Plugin" class="headerlink" title="Jib Maven Plugin"></a>Jib Maven Plugin</h3><p>它是谷歌开源的OCI镜像打包工具，可以用来打包Docker镜像，大部分情况下已经满足需要。但是如果你要定制化的话还是不容易的，需要阅读官方给的文档。最开始的<strong>Dockerfile</strong>如果使用<strong>JIb</strong>的话需要这样配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span>&gt;</span>adoptopenjdk/openjdk8<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span>&gt;</span>docker.repo.com/library/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">auth</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">username</span>&gt;</span>felord<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tags</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extraDirectories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">from</span>&gt;</span>target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.jar<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span>*.jar<span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">into</span>&gt;</span>/app.jar<span class="tag">&lt;/<span class="name">into</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extraDirectories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">containerizingMode</span>&gt;</span>packaged<span class="tag">&lt;/<span class="name">containerizingMode</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">volumes</span>&gt;</span>/tmp,/logs<span class="tag">&lt;/<span class="name">volumes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ports</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ports</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">environment</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entrypoint</span>&gt;</span></span><br><span class="line">                java,-Djava.security.egd=file:/dev/./urandom,-Dspring.profiles.active=$&#123;active&#125;,-jar,/app.jar</span><br><span class="line">            <span class="tag">&lt;/<span class="name">entrypoint</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">creationTime</span>&gt;</span>USE_CURRENT_TIMESTAMP<span class="tag">&lt;/<span class="name">creationTime</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点是不需要本地Docker环境，而且支持分层构建、镜像瘦身，上手容易；缺点是定制化比较困难。</p>
<h1 id="SpringBoot项目docker打包体积优化"><a href="#SpringBoot项目docker打包体积优化" class="headerlink" title="SpringBoot项目docker打包体积优化"></a>SpringBoot项目docker打包体积优化</h1><h2 id="修改之前"><a href="#修改之前" class="headerlink" title="修改之前"></a>修改之前</h2><p>最开始使用的dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH /home/project/cmp</span><br><span class="line"><span class="keyword">ENV</span> APP_NAME @project.build.finalName@.@project.packaging@</span><br><span class="line"><span class="keyword">ENV</span> APP_VERSION @project.version@</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#VOLUME</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/home/project&quot;</span>, <span class="string">&quot;/tmp/data&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#COPY</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$APP_NAME</span> <span class="variable">$WORK_PATH</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$WORK_PATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> SIMSUN.TTC  /usr/share/fonts/SIMSUN.TTC</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span>  /usr/share/fonts</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> fc-cache -fsv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENTRYPOINT</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;-Xmx512m&quot;</span>, <span class="string">&quot;@project.build.finalName@.@project.packaging@&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>由于这里直接使用java8的镜像，本身就有600多M，加上业务模块本身的大小，大约有了800多M，这样每次打包构建，非常的耗时，也很占用磁盘空间。</p>
<p><img src="./assets/image-20210609163709373.png" alt="image-20210609163709373"></p>
<h2 id="使用Alpine镜像"><a href="#使用Alpine镜像" class="headerlink" title="使用Alpine镜像"></a>使用Alpine镜像</h2><p><code>Alpine Linux</code>操作系统是一个面向安全的轻型 <code>Linux</code> 发行版，<code>Alpine Docker</code> 镜像也继承了<code>Alpine Linux</code>发行版的这些优势，相比于其他Docker镜像，它的容量非常小，并且拥有自己的包管理机制，可以使用<code>apk</code> 包管理器替换 <code>apt</code> 工具，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apk add --no-cache &lt;package&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用Alpine提供的docker镜像：</p>
<p><img src="./assets/image-20210609165237674.png" alt="image-20210609165237674"></p>
<p>因此这里我们使用<code>Alpine</code>镜像，并且将RUN的指令合并在一起，减少构建的层数，修改之后的dockerfile，：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORK_PATH /home/project/cmp</span><br><span class="line"><span class="comment"># 这里的都是maven内置的变量</span></span><br><span class="line"><span class="keyword">ENV</span> APP_NAME @project.build.finalName@.@project.packaging@</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$APP_NAME</span> <span class="variable">$WORK_PATH</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WORKDIR</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$WORK_PATH</span></span></span><br><span class="line"><span class="comment"># 根据实际需求添加字体</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> simsun.ttc  /usr/share/fonts/simsun.ttc</span></span><br><span class="line"><span class="comment"># 为了解决docker容器内的时间和宿主机时间不一致的问题，并且安装了fontconfig，方便安装字体</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone &amp;&amp; apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENTRYPOINT</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;-Xmx512m&quot;</span>, <span class="string">&quot;@project.build.finalName@.@project.packaging@&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="分层构建镜像"><a href="#分层构建镜像" class="headerlink" title="分层构建镜像"></a>分层构建镜像</h2><p>使用了<code>Alpine</code>镜像之后，项目的体积有了比较明显的改善，但是每次打包的时候还是会全量构建项目中的所有内容，构建的时间还是比较长，这里我们使用分层的机制来进行打包，这里要注意的是，使用的<code>SpringBoot</code>的版本必须要大于2.3.X。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine as builder</span><br><span class="line"><span class="keyword">ENV</span> APP_NAME @project.build.finalName@.@project.packaging@</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="comment"># 注意这里对应的是编译后的dockerfile的目录，如果对应不上，可能会提示找不到文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="variable">$APP_NAME</span> application.jar</span></span><br><span class="line"><span class="comment"># 指定构建Jar的模式，并从Jar包中提取构建镜像所需的内容</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> java -Djarmode=layertools -jar application.jar extract</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> application</span></span><br><span class="line"><span class="comment"># 拷贝字体，这里安装宋体字体，alpine镜像会自动检测/usr/share/fonts是否含有字体</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> simsun.ttc  /usr/share/fonts/simsun.ttc</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/snapshot-dependencies/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/spring-boot-loader/ ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder application/application/ ./</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=<span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 设置虚拟机参数</span></span><br><span class="line"><span class="keyword">ENV</span> JVM_OPTS=<span class="string">&quot;-XX:MaxRAMPercentage=80.0&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;java <span class="variable">$JVM_OPTS</span> <span class="variable">$JAVA_OPTS</span> org.springframework.boot.loader.JarLauncher&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>配置pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用本地Jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                true</span><br><span class="line">            <span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Maven中内置变量"><a href="#Maven中内置变量" class="headerlink" title="Maven中内置变量"></a>Maven中内置变量</h2><ul>
<li><code>$&#123;basedir&#125;</code> 项目根目录</li>
<li><code>$&#123;project.build.directory&#125;</code> 构建目录，缺省为target</li>
<li><code>$&#123;project.build.outputDirectory&#125;</code> 构建过程输出目录，缺省为target/classes</li>
<li><code>$&#123;project.build.finalName&#125;</code> 产出物名称，缺省为{project.artifactId}-${project.version}</li>
<li><code>$&#123;project.packaging&#125;</code> 打包类型，缺省为jar</li>
<li><code>$&#123;project.xxx&#125;</code> 当前pom文件的任意节点的内容</li>
</ul>
<h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><ol>
<li><p>如果本身项目<code>SpringBoot</code>版本较低，不建议升级，推荐通过使用<code>Alpine</code>镜像以及优化dockerfile写法减少镜像体积，特别的，如果是使用的<code>Spring Cloud</code>，升级会出现组件版本不兼容的情况，可能需要升级诸多依赖的版本，并且需要投入精力进行测试验证。</p>
</li>
<li><p>如果项目不需要字体，可以跳过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li>
<li><p>如果项目中只需要宋体，可以只复制字体文件到镜像内，而不需要安装fontconfig，<code>alpine</code>镜像会自动检测<code>/usr/share/fonts</code>是否含有字体：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY simsun.ttc  /usr/share/fonts/simsun.ttc</span><br></pre></td></tr></table></figure></li>
<li><p>如果项目中既需要宋体又需要其他字体（例如图片验证码），这是时候，拷贝宋体字体文件和安装fontconfig都需要：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">COPY simsun.ttc  /usr/share/fonts/simsun.ttc</span><br><span class="line">RUN apk add --update ttf-dejavu fontconfig &amp;&amp; rm -rf /var/cache/apk/*</span><br></pre></td></tr></table></figure></li>
<li><p>如果镜像打包的体积还是过大，可以使用<code>docker history image_name --no-trunc=true</code>命令来查看构建的详情。</p>
</li>
</ol>
<p>附完整的pom文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-$&#123;profiles.active&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>application.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--这里实我们的dockerfile文件所在的目录--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/Dockerfile<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>../docker<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>static/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.json<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.ftl<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--引用本地Jar包--&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">layers</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span></span><br><span class="line">                          true</span><br><span class="line">                      <span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">layers</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 打包跳过测试 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 避免font文件的二进制文件格式压缩破坏 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>woff<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>woff2<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>eot<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>ttf<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>svg<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">delimiters</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">delimiter</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">delimiters</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">useDefaultDelimiters</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useDefaultDelimiters</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">id</span>&gt;</span>push-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">imageName</span>&gt;</span></span><br><span class="line">                              $&#123;docker.repostory&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;:$&#123;profiles.active&#125;-$&#123;project.version&#125;</span><br><span class="line">                          <span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">serverId</span>&gt;</span>harbor<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">imageName</span>&gt;</span></span><br><span class="line">                      $&#123;docker.repostory&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;</span><br><span class="line">                  <span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                      <span class="comment">&lt;!--docker的tag为项目版本号、latest--&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>$&#123;profiles.active&#125;-$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">rescource</span>&gt;</span><span class="comment">&lt;!-- 将打包文件放入dockerDirectory指定的位置 --&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                          <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.artifactId&#125;-$&#123;project.version&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;/<span class="name">rescource</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解JVM</title>
    <url>/2020/12/06/jvm/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>时至今日，JVM的重要性已经不言而喻，但是JVM本身的复杂性使得了解其原理与运作方式是一件极其困难的事情，本篇主要结合张龙老师的视频：<a href="https://www.bilibili.com/video/BV187411B7iv">深入理解JVM虚拟机</a>与《深入理解Java虚拟机》，系统而全面的介绍Java虚拟机的方方面面。</p>
<span id="more"></span>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>学习笔记地址：<a href="https://github.com/weolwo/jvm-learn.git">https://github.com/weolwo/jvm-learn.git</a></p>
<p>加载：查找并加载类的二进制数据</p>
<p>连接：</p>
<ul>
<li>验证：确保被加载的类的正确性</li>
<li>准备：为类的静态资源变量分配内存，并将其初始化为默认值</li>
<li>解析：把类中的符号引用转换为直接引用</li>
</ul>
<p>初始化：为类的静态变量赋予正确的初始值</p>
<p>Java程序对类的使用方式可分为两种：主动使用、被动使用</p>
<p>所有的Java虚拟机实现必须在每个类或者接口被Java程序“首次主动使用”时才初始化他们</p>
<p>主动使用（七种）：</p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test）</li>
<li>JDK1.7开始提供的动态语言支持：Java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化则初始化</li>
</ol>
<p>除了以上其中情况，其他使用Java类的方式都被看作时对类的被动使用，都不会导致了的初始化；</p>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构</p>
<p>加载.class文件的方式</p>
<ol>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ol>
<p>类加载器并不需要某个类被“首次主动使用”时再去加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误</p>
<p>当一个类在初始化时，要求其父类全部都初始化完毕，当一个接口在初始化时，并不要求其父接口都完成了初始化。</p>
<p>在双亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根类加载器之外，其余的类加载器都有且只有一个父加载器</p>
<p>自底向上检查类是否已经加载，自项向下尝试加载类。</p>
<p>启动类加载器：$JAVA_HOME中jre/lib/rt.jar里所有的class，由c++实现，不是classloader的子类；</p>
<p>扩展类加载器：加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包；</p>
<p>系统类加载器：负责加载classpath中指定的jar包及目录中class；</p>
<p>若有一个类加载器能够成功加载Test类，那么这个类加载器被称为定义类加载器，所有能成功返回Class对象引用的类加载器（包括定义类加载器）都成为初始类加载器。</p>
<p>加载器之间的父子关系实际上是包装关系。</p>
<p>双亲委托机制的有点是能够提高软件系统的安全性。因为在此机制下，用户自定义的类加载器不可能加载应该由父加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父加载器的可靠代码。</p>
<p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。</p>
<p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类，在不同的命名空间中，有可能会出出现类的完整名字（包括类的包名）相同的两个类</p>
<p>同一个命名空间内的类是相互可见的。</p>
<p>子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器加载的类，由父加载器加载的类不能看见子加载器加载的类</p>
<p>如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。</p>
<p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</p>
<p>由JAVA虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。</p>
<p>Java语言规范，Java虚拟机规范</p>
<p><strong>字节码</strong></p>
<p>1、使用javap -verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法，类中的方法信息、类变量与成员变量等信息。</p>
<p>2、魔数：所有的.class字节码文件前4个字节都是魔数，魔数值为固定值：oxCAFEBABE,来源：<a href="https://blog.csdn.net/renfufei/article/details/69938592">https://blog.csdn.net/renfufei/article/details/69938592</a></p>
<p>3、魔数之后的4个字节为版本信息，前两个字节表示minor version版本，后两个字节表似乎major version。主版本号为52表示该文件的版本号为1.8.0。可以通过java -version命令来验证这一点。</p>
<p>4、常量池（constant pool）：紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来维护和描述的。可以将常量池看作是class文件的资源仓库，比如Java类中定义的方法与变量信息，都是存储在常量池中。常量池中主要存储两类常量：字面量与符号引用，字面量如文本字符串，Java中声明为final的常量值等，而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。</p>
<p>5、常量池的总体结构：Java类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池数量紧跟在主版本号后面，占据2个字节，常量池数组紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不同，但是每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占据1个字节，JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数=常量池数-1（其中0暂时不使用），目的是为了满足某些常量池索引值在特定情况下需要表达【不引用任何一个常量池】的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应null值，所以，常量池的索引从1而非0开始。</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如下所示：B-byte，C-char，D-double，F-float，I-int，J-long，S-short，Z-boolean，V-void，L-对象类型，如Ljava/lang/String；</p>
<p>对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录为[I，String[][]，被记录为[[Ljava/lang/String；</p>
<p>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()之内，如方法：String getRealnamebyIdaAndNickname(int id,String name)的描述符为：（I，Ljava/lang/String;）Ljava/langString;</p>
<p><code>&lt;init&gt;</code>表示构造方法</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>深入理解Java字节码结构：<a href="https://blog.csdn.net/u011810352/article/details/80316870">https://blog.csdn.net/u011810352/article/details/80316870</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClssFile&#123; 	u4 				magic; 	u2				minor_version; 	u2				major_version; 	u2				constant_pool_count; 	cp_info			contant_pool[constant_pool_count -<span class="number">1</span>]; 	u2				access_flags; 	u2				<span class="keyword">this</span>.class; 	u2				<span class="keyword">super</span>.class; 	u2				interfaces_count; 	u2				interfaces[interfaces_count]; 	u2 				fields_count; 	field_info  	fields[fields_count]; 	u2 				method_count; 	method_info 	methos[method_count]; 	u2				attributes_count; 	attribute_info	attributes[attributes_count]; &#125; </span><br></pre></td></tr></table></figure>

<p>文件结构剖析：<a href="https://www.cnblogs.com/luozhiyun/p/10546608.html">https://www.cnblogs.com/luozhiyun/p/10546608.html</a></p>
<p>Class字节码中有两种数据类型：</p>
<p>1、字节数据直接量：这是基本数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的整体数据。</p>
<p>2、表（数组）：表是由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在：组成表的成分所在的位置和顺序都是已经严格定义好的。</p>
<p>Access_Flag访问标志:</p>
<p>访问标志信息包括该Class文件是类还是接口，是否被定位成public，是否是abstract，如果是类，是否被声明为final。</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>0x0021：是0x0020和0x0001的并集，表示ACC_PUBLIC与ACC_SUPER的并集</p>
<p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。</p>
<p>filed_count: u2</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>field_info{     u2                 access_flags; 0002     u2                 name_index;  0005     u2                descriptor_index; 0006     u2                attributes_count;    0000     attribute_info    attributes[attributes_count]; } </p>
<p>java反编译工具：<a href="http://java-decompiler.github.io/">http://java-decompiler.github.io/</a></p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>method_info{     u2                    access_flags;     u2                     name_index;     u2                    descriptor_index;     u2                    attributes_count;     attribute_info        attributes[attributes_count]; } </p>
<p>方法中的每个属性都是一个attribute_info结构：</p>
<p>attribute_info{     u2     attribute_name_index;     u4    attribute_length;     u1    info[attribute_length]; } </p>
<p>JVM预定义了部分attribute，但是编译器自己也可以实现自己的attribute写入class文件里，供运行时使用。</p>
<p>不同的attribute通过attribute_name_index来区分</p>
<p>Code attribute的作用是保存该方法的结构，如所对应的字节码：</p>
<p>Code_attribute{     u2    attribute_name_index;  //属性名     u4    attribute_length;     u2    max_stack;     u2    max_locals;     u4    code_length;     u1    code[code_length];     u2    exception_table_length; // 异常表长度     {         u2    start_pc;         u2    end_pc;         u2    handler_pc;         u2    catch_type;     }    exception_table[exception_table_length];     u2    attribute_count;     attribute_info attributes[attribute_count]; } </p>
<p>attribute_length表示attribute所包含的字节数，不包含attribute_name_index和attribute_length字段；</p>
<p>max_stack表示这个方法进行的任何时刻所能达到的操作数栈的最大深度；</p>
<p>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量；</p>
<p>code_length表示该方法所包含的字节码的字节数及具体的指令码；</p>
<p>code表示具体字节码，即是该方法被调用时，虚拟机所执行的字节码；</p>
<p>exception_table，这里存放的是处理异常的信息；</p>
<p>每个exception_table表项由start_pc，end_pc，handler_pc，catch_type组成；</p>
<p>start_pc和end_pc表示在code数组中的从start_pc到end_pc处（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项来处理； handler_pc表示处理异常的代码的开始处。catch_type表示会被处理的异常类型，它指向常量池的一个异常类。当catch_type为0时，表示处理所有的异常；</p>
<p>LineNumberTable：这个属性用来表示code数组中的字节码和java代码行数之间的关系。这个属性可以用来在调试的时候定位代码执行的行数：</p>
<p>lineNumberTable_attribute{     u2 attribute_name_index;     u4    attribute_length;     u2    line_number_table_length;     {         u2 start_pc         u2    line_number;     }line_number_table[line_number_table_length]; } </p>
<p>jclasslib查看工具</p>
<p>javap -verbose -p …</p>
<p>java字节码对于异常的处理方式：</p>
<p>1、统一采用异常表的方式来对异常进行处理</p>
<p>2、在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，而是采用特定的指令的方式</p>
<p>3、当异常处理存在finally语句块时，现在化的JVM采取处理方式时将finally语句块的字节码拼接到每一个catch块后面。换句话说，程序中存在多少个catch块后面重复多少个finally语句块的字节码。</p>
<p>栈帧（stack frame）:栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构。栈帧本身是一种数据结构，封装了方法的局部变量表，动态链接信息，方法的返回地址以及操作数栈等信息。</p>
<p>Java中有两种引用方式：符号引用，直接引用</p>
<p>类加载或者首次使用，符号引用—&gt;直接引用</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>栈帧：<a href="https://www.cnblogs.com/jhxxb/p/11001238.html">https://www.cnblogs.com/jhxxb/p/11001238.html</a></p>
<p>有些符号引用时在类加载阶段或是第一次使用时就会转换为直接引用，这种转换叫做静态解析；另外一些符号引用则是在每次运行期转换为直接引用，这种转换叫做动态链接，这体现为Java的多态性。</p>
<p>Animal a = new Cat(); a.sleep a = new Dog() a.sleep a = new Tiger() a.sleep </p>
<p>在程序编译期间，实际上调用的是Animal的sleep方法，执行期间会通过invokevirtual来检查真正的方法的指向。</p>
<p>JVM助记符：</p>
<p>1、invokeinterface：调用接口中的方法，实际上是在运行期决定的，决定到底调用实现该接口中的哪个对象的特定的方法；</p>
<p>2、invokestatic：调用静态方法；</p>
<p>3、invokespecial：调用自己的私有方法、构造方法（<code>&lt;init&gt;</code>）以及父类的方法；</p>
<p>4、invokevirtual：调用虚方法，运行期间动态查找的过程；</p>
<p>5、invokedynamic：动态调用方法。</p>
<p>静态解析的四种情形：</p>
<p>1、静态方法</p>
<p>2、父类方法</p>
<p>3、构造方法</p>
<p>4、私有方法（无法被重写）</p>
<p>以上四类方法称为非虚方法，他们是在类加载阶段就可以将符号引用换转为直接直接引用，这种情形就被称之为静态解析。</p>
<p>方法的静态分派：</p>
<p>Grandpa g1 = new Father(); </p>
<p>以上代码，g1的静态类型是Grandpa，而g1的实际类型（真正指向的类型）是Father。</p>
<p>结论：变量的静态类型是不会发生变化的，而变量的实际类型则是可以发生变化的（多态的一种体现）,实际类型是在运行期可确定。</p>
<p>方法重载对于JVM来讲是一种静态的行为，因此调用重载方法，变量类型是根据传入变量的静态类型来确定的。方法重载在编译期就可以完全确定的。</p>
<p>方法的动态分派：方法接收者指的是这个方法到底是由哪一个对象来的调用的，invokevirtual字节码指令的多态查找流程，在运行期间，首先找到操作数栈顶的第一个元素所指向的真正的类型，然后在实际的类型当中寻找到特定的方法，如果能找到，那就将符号引用转换为直接引用，如果找不到，就开始按照继承体系，在父类里面开始从下网上开始寻找，可以找到就转换为直接引用，如果没有找到，则抛出异常。</p>
<p>方法重载和方法重写的结论：方法重载是静态的，是编译期行为；方法重写是动态的，是运行期行为。</p>
<p>针对于方法调用的动态分派的过程，虚拟机在类的方法区简历一个虚方法表的数据结构（virtual method table，vtable）</p>
<p>针对于invokeinterface指令来说，虚拟机会建立一个接口方法表的数据结构（interface method table，itable）</p>
<p>编译执行，解释执行</p>
<p>现在JVM在执行java代码的时候，通常都会将解释执行与编译执行二者结合来进行。</p>
<p>所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令；</p>
<p>所谓编译执行，是通过即时编译器（Just In Time，JIT）将字节码转换为本地机器码来执行，现在JVM会根据代码热点来生成响应的本地机器码。</p>
<p>基于栈的指令集（内存当中执行），基于寄存器的指令集（CPU当中执行）的关系：</p>
<p>1、JVM执行指令时所采取的方式是基于栈的指令集；</p>
<p>2、基于栈的指令集主要的操作有入栈与出栈两种；</p>
<p>3、基于栈的指令集的优势在于它可以在不同平台之间一直，而基于寄存器的指令集是与硬件架构关联的，无法做到可移植；</p>
<p>4、基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多；基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机以采用一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。</p>
<p>unsigned byte: 0-255</p>
<p>构造代理对象的类：proxyClassFactory</p>
<p>通过字节码分析JDK8中Lambda表达式编译及执行机制：<a href="https://blog.csdn.net/lijingyao8206/article/details/51225839">https://blog.csdn.net/lijingyao8206/article/details/51225839</a></p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><img src="assets/clipboard.png" alt="img"></p>
<p>Java虚拟机栈：存储对象的引用，属于线程私有的内存空间，伴随着线程的生命周期；局部变量表中可以存储基本数据类型以及引用类型，每个方法执行的时候都会创建一个栈帧，栈用于存放局部变量表，操作栈，动态链接，方法出口等信息，一个方法的执行过程，就是这个方法对于栈帧的入栈、出栈过程；</p>
<p>Stack Frame 栈帧：</p>
<p>程序计数器（Program Counter）：用来标识当前执行线程的行号/顺序，也是线程所私有的内存空间；</p>
<p>本地方法栈（Native Method Stack）：主要用于处理本地方法，有的虚拟机实现会把本地方法栈和虚拟机栈合二为一，例如hostpot虚拟机；</p>
<p>堆（Heap）：存储真实的对象，JVM管理的最大的一块内存空间；堆空间的内存可以是连续的，也可以是不连续的，与堆相关的一个重要概念是垃圾收集器，现代几乎所有的垃圾收集器都是采用的分代收集算法，所以堆空间也基于这一点进行了相应的划分：新生代与老年代；Eden空间（80%），From Survivor空间（10%）与To Survivor空间（10%）。</p>
<p>方法区（Method Area）：存储元信息。永久代（Permanent Generation），从JDK1.8开始，已经彻底废弃了永久代，使用元空间（meta space），方法区里面的元信息是很少会被回收的，实例数据和元数据，元数据（Class对象）位于方法区；</p>
<p>运行时常量池：方法区的一部分内容。</p>
<p>直接内存：Direct Memory，并非由Java虚拟机管理的内存区域，与Java NIO密切相关，JVM是通过DirectByteBuffer来操作直接内存的。</p>
<p>关于Java对象创建的过程：</p>
<p>new关键字创建对象的3个步骤：</p>
<p>1、在推内存中创建出对象的实例；</p>
<p>2、为对象的成员变量赋初值；</p>
<p>3、将对象的引用返回；</p>
<p>分配内存的策略：</p>
<p>指针碰撞（前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间）</p>
<p>空闲列表（前提是堆内存空间中已使用与未被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些空间是未被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录）</p>
<p>对象在内存中的布局：</p>
<p>1、对象头</p>
<p>2、实例数据（即我们在一个类中所声明的各项信息）</p>
<p>3、对齐填充（可选）</p>
<p>引用访问对象的方式：</p>
<p>1、使用句柄的方式； </p>
<p>2、使用直接指针的方式。</p>
<p>可视化工具：</p>
<p>jvisualvm</p>
<p>jconsole</p>
<p>System.gc(); </p>
<p>OOM，全称“Out Of Memory”</p>
<p>-Xms5m -Xmx5m -xx:+HeapDumpOnOutOfMemoryError </p>
<p>虚拟机栈溢出：一直递归</p>
<p>参数设置：</p>
<p>-Xss160k </p>
<p>元空间大小设置：</p>
<p>-XX:MaxMetaspaceSize=10m -XX:+TraceClassLoading </p>
<p>Java永久代去哪儿了：<a href="https://www.infoq.cn/article/Java-PERMGEN-Removed/">https://www.infoq.cn/article/Java-PERMGEN-Removed/</a></p>
<p>获取java进程：</p>
<p>ps -ef | grep java jps -mlvV jps -l </p>
<p>打印类加载器数据命令：</p>
<p>jmap -clstats PID  // cl表示classloader </p>
<p> $ jmap -clstats   Attaching to process ID 6476, please wait…  Debugger attached successfully.  Server compiler detected.  JVM version is 25.5-b02  finding class loader instances ..done.  computing per loader stat ..done.  please wait.. computing liveness.liveness analysis may be inaccurate …  class_loader classes      bytes parent_loader     alive? type          655  1222734     null      live     0x000000074004a6c0    0    0    0x000000074004a708    dead      java/util/ResourceBundle$RBClassLoader@0x00000007c0053e20  0x000000074004a760    0    0      null      dead      sun/misc/Launcher$ExtClassLoader@0x00000007c002d248  0x00000007401189c8     1     1471 0x00000007400752f8    dead      sun/reflect/DelegatingClassLoader@0x00000007c0009870  0x000000074004a708    116   316053    0x000000074004a760   dead      sun/misc/Launcher$AppClassLoader@0x00000007c0038190  0x00000007400752f8    538  773854    0x000000074004a708   dead      org/dacapo/harness/DacapoClassLoader@0x00000007c00638b0  total = 6      1310   2314112           N/A       alive=1, dead=5     N/A   </p>
<p>打印堆内存命令：</p>
<p>jmap -heap PID </p>
<p>打印元空间的信息：</p>
<p>jstat -gc LVMID </p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>jcmd是从jdk1.7开始增加的命令，可以用来查看进程的JVM启动参数：</p>
<p>jcmd PID VM.flags </p>
<p>当前运行java进程可以执行的操作列表：</p>
<p>jcmd PID help </p>
<p>查看具体命令的选项：</p>
<p>jcmd PID help JFR.dump </p>
<p>查看JVM性能相关的参数：</p>
<p>jcmd PID PerfCounter.print </p>
<p>查看JVM启动的时长：</p>
<p>jcmd PID VM.uptime </p>
<p>查看系统中的类的统计信息：</p>
<p>jcmd PID GC.class_histogram </p>
<p>查看当前线程的堆栈信息：</p>
<p>jcmd PID Thread.print </p>
<p>导出Head dump 文件，导出的文件可以通过jvisualvm查看：</p>
<p>jcmd PID GC.head_dump file_name </p>
<p>查看JVM的属性信息：</p>
<p>jcmd PID VM.system_properties </p>
<p>查看JVM启动命令行的参数：</p>
<p>jcmd PID VM.command_line </p>
<p>jstack：可以查看或是导出Java应用程序中的堆栈信息</p>
<p>jmc：Java Mission Control</p>
<p>jfr：Java Flight Recorder 实时到统计数据</p>
<p>OQL：JVM 对象查询语言</p>
<p>jhat file_name </p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><a href="https://www.cnblogs.com/andy-zhou/p/5327288.html">https://www.cnblogs.com/andy-zhou/p/5327288.html</a></p>
<p>垃圾判断算法</p>
<p>GC算法</p>
<p>垃圾回收器的实现和选择</p>
<p>引用计数算法（Refence Counting）</p>
<p>给对象添加一个引用计数器，当有一个地方引用它，计数器加1，当引用失效，计数器减1，任何时刻计数器为0的对象就是不可能再被使用的；</p>
<p>引用计数算法无法解决对象循环引用的问题；</p>
<p>对象循环引用：A引用B，B引用A，当A和B都是孤立的时候，这两个对象的计数器都是1，无法进行回收，但实际上已经没有作用了。</p>
<p>根搜索算法（Root Tracing）</p>
<p>通过一系列的称为“GC Roots”的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链（Reference Chain）相连，则证明此对象是不可用的；</p>
<p>在Java语言中，GC Roots包括：</p>
<ol>
<li>在VM栈（栈帧中的本地变量）中的引用</li>
<li>方法区中的静态引用</li>
<li>JNI（即一半说的Nactive方法）中的引用</li>
</ol>
<p>方法区的GC主要回收两部分内容：废弃常量与常用类</p>
<p>类回收需要满足3个条件：</p>
<ol>
<li>该类所有的实例都已经被GC，也就是JVM中不存在改Class的任何实例；</li>
<li>加载该类的ClassLoader已经被GC；</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法。</li>
</ol>
<p>JVM常见的GC算法：</p>
<ul>
<li>标记-清除算法（Mark-Sweep）</li>
<li>标记-整理算法（Mark-Compact）</li>
<li>复制算法（Copying）</li>
<li>分代算法（Generational）</li>
</ul>
<p>Mark-Sweep</p>
<p>算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象。</p>
<p>缺点：</p>
<p>1、效率问题，标记和清理两个过程效率都不高，需要扫描所有对象，堆越大，GC越慢；</p>
<p>2、空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作。</p>
<p>Mark-Compact</p>
<p>标记过程仍然一样，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存。</p>
<p>没有内存碎片，但是需要耗费更多的时间进行Compact</p>
<p>Copying</p>
<p>将可用内存划分为两块，每次只使用其中的一块，当半区内存用完之后，仅将还存活的对象复制到另一块上面，然后就把原来整块内存空间一次性清理掉。</p>
<p>优点：</p>
<p>这样使得每次内存回收都是对整个搬去的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动过堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。</p>
<p>缺点：</p>
<p>这种算法的代价是将内存缩小为原来的一半，代价高昂</p>
<p>现在的虚拟机中都是采用此算法来回收新生代；</p>
<p>将内存分为一块较大的eden空间和两块较少的survivor空间，每次使用eden和其中一块survivor，当回收的时候会将eden和survivor还存活的对象一次性拷贝到另一块survivor空间上，然后清理掉eden和用过的survivor，用过的survivor称为From survivor，没有用过的survivor称为To survivor。</p>
<p>eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的。</p>
<p>复制收集算法在对象存活率高的时候，效率有所下降；</p>
<p>如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>特点：</p>
<ul>
<li>只需要扫描存活的对象，效率更高</li>
<li>不会产生脆片</li>
<li>需要浪费额外的内存作为复制区</li>
<li>复制算法非常适合生命周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小</li>
<li>根据IBM的专门研究，98%的Java对象只会存活1个GC周期，对这些对象很适合用复制算法。而且不用1：1的划分工作区和复制区的空间</li>
</ul>
<p>Generational Collecting</p>
<p>针对不同生命周期的对象采用不同的GC算法。</p>
<p>根据不同的存活周期将内存划分为几块。一半将Java堆分作新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法譬如新生代每次GC都有大批对象死去，只有少量存活，那么就可以选用复制算法只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>JVM6中划分为三个代：年轻代，老年代和永久代</p>
<p>年轻代：</p>
<p>通过Copying算法</p>
<p>老年代：</p>
<p>存放了经过一次或多次GC还存活的对象；</p>
<p>一般采用Mark-Sweep或者Mark-Compact算法进行GC</p>
<p>HotSpot将引用分为四种：Strong（强引用）、Soft（软引用）、Weak（弱引用）、Phantom（虚引用）</p>
<p>1、Strong即默认通过Object o = new Object()这种方式赋值的引用</p>
<p>2、Soft、Weak、Phantom这三种则都是继承Reference</p>
<p>Soft：没存不够时一定会被GC，长期不用也会被GC</p>
<p>Weak：一定会被GC，当被mark为dead，会在RefenceQueue中通知</p>
<p>Phantom：本来就没引用，当从JVM heap中释放时会通知</p>
<p>GC在分代模型的基础上，从时机上分为两种Scavenge GC和Full GC</p>
<p>Scavenge GC（Minor GC）</p>
<p>触发时机：新对象生成时，Eden空间满了</p>
<p>理论上Eden区大多数对象会在Scavenge GC回收，复制算法的执行效率会很高，Scavenge GC时间比较短。</p>
<p>Full GC</p>
<p>对整个JVM进行整理，包括Young、Old和Perm</p>
<p>主要的触发时机：1、Old满了 2、Perm满了 3、System.gc()</p>
<p>效率很低，需要避免Full GC。</p>
<p>并行（Parallel）：指多个收集器的线程同时工作，但是用户线程处于等待状态</p>
<p>并发（Concurrent）：指收集器在工作的同时，可以允许用户线程工作。</p>
<p>并发不代表解决了GC停顿的问题，在关键的步骤还是要停顿。比如在收集器标记垃圾的时候要停顿，但在清楚垃圾的时候，用户线程可以和GC线程并发执行。</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>Serial收集器</p>
<p>单线程收集器，收集时会暂停所有工作线程（Stop The World，简称STW），使用复制收集算法，虚拟机运行在Clint模式时的默认新生代收集器。</p>
<p>特点：</p>
<ul>
<li>最早的收集器，单线程进行GC</li>
<li>New和Old Generation都可以使用</li>
<li>在新生代，采用复制算法；在老年代，采用Mark-Compact算法</li>
<li>因为是单线程GC，没有多线程切换的额外开销，简单使用。</li>
<li>Hotspot Client模式缺省的收集器</li>
</ul>
<p>ParNew收集器</p>
<p>ParNew收集器就是Serial的多线程版本，除了使用多个收集线程外，其余行为包括算法，STW，对象分配规则，回收策略等都与Serial收集器一摸一样。</p>
<p>对应这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serila收集器有更好的效果</p>
<p>特点：</p>
<ul>
<li>使用复制算法</li>
<li>只有在多CPU的环境下，效率才会比Serial收集器高</li>
<li>可以通过-XX:ParallerlGCThreads来控制GC线程数的多少，需要结合具体的CPU的个数</li>
</ul>
<p>Parallel Scavenge收集器</p>
<p>也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都ParNew收集器有所不同，它是以吞吐量最大化（即GC时间占总运行时间最小）为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化。</p>
<p>Serial Old收集器</p>
<p>Serial Old是单线程收集器，使用标记一整理算法，是老年代的收集器</p>
<p>Parallel Old收集器</p>
<p>老年代版本吞吐量优化收集器，使用多线程和标记-整理算法，JVM1.6提供，在此之前，新生代使用了PS收集器的话，老年代除了Serial Old别无选择，因为PS无法与CMS收集器配合工作。</p>
<p>特点：</p>
<ul>
<li>Parallerl Scavenge + Parallel Old = 高吞吐量，但GC停顿可能不理想</li>
</ul>
<p>CMS收集器</p>
<p>CMS是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高（总体GC时间最小），但它能尽可能降低GC时服务的停顿时间，CMS收集器使用的是标记-清楚算法</p>
<p>特点:</p>
<ul>
<li>只针对于追求最短停顿时间，非常适合web应用</li>
<li>只针对老年去，一般结合ParNew使用</li>
<li>Concurrent，GC线程和用户线程并发工作（尽量并发）</li>
<li>Mark-Sweep</li>
<li>只有在多CPU环境下才有意义</li>
<li>使用-XX:+UseConcMarkSweepGC打开</li>
<li>CMS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少于4的时候，有可能对吞吐量影响非常大</li>
<li>CMS在并发清理的过程中 ，用户线程还在跑。这时候需要预留一部分空间给用户线程</li>
<li>CMS用Mark-Sweep，会带来碎片问题。碎片过多的时候会容易频繁触发Full GC</li>
</ul>
<p>Java内存泄漏的经典原因：</p>
<ol>
<li>对象定义在错误的范围（Wrong Scope）</li>
<li>异常（Exception）处理不当</li>
<li>集合数据管理不当（1、当使用基于数组的数据结构的时候，使用合适的初始值，减少resize的过程 2、如果List只需要顺序访问，不需要随机访问的话，使用LinkedList代替ArrayList）</li>
</ol>
<p>虚拟机参数设置：</p>
<p>-verbose:gc   // 表示输出详细的垃圾回收的日志 -Xms20M       // 堆内存初始大小 -Xmx20M       // 堆内存最大值 -Xmn10M       // 新生代大小是10m -XX:+PrintGCDetails     // 打印GC详细信息 -XX:SurvivorRatio=8    // 8:1 -XX:PretenureSizeThreshold=4194304   // 新生代创建对象的阈值大小，单位为字节，只有串行收集器才会生效 -XX:+UseSerialGC -XX:MaxTenuringThreshold  // 在可以自动调节对象晋升（Promote）到老年代阈值的GC中，设置该阈值的最大值 -XX:PrintTenuringDistribution </p>
<p>当新生代无法容纳待创建对象的时候，会在老年代分配内存</p>
<p>JDK1.8使用的默认垃圾收集器：</p>
<p>PSYoungGen：Parallel Scavenge（新生代垃圾收集器）</p>
<p>ParOldGen：parallel Old（老年代垃圾收集器）</p>
<p>查看java虚拟机启动参数：</p>
<p>java -XX:+PrintCommandLineFlags -version </p>
<p>执行结果：</p>
<p>-XX:InitialHeapSize=120400640 -XX:MaxHeapSize=1926410240 -XX:+PrintCommandLi neFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLarge PagesIndividualAllocation -XX:+UseParallelGC（使用的垃圾收集器策略，这里使用并行 的垃圾收集器） java version “1.8.0_212” Java(TM) SE Runtime Environment (build 1.8.0_212-b10) Java HotSpot(TM) 64-Bit Server VM (build 25.212-b10, mixed mode) </p>
<p>PretenureSizeThreshold：设置对象超过多大的时候直接在老年代进行分配</p>
<p>MaxTenuringThreshold：CMS中默认值为6，G1中默认值为15（该数值是由4个bit来表示的，所以最大值1111，即15）</p>
<p>经历了多次GC后，存活的对象会在From Survivor与To Survivor之间来回存放，而这里面的一个前提则是这两个空间由足够的大小来存放这些数据，在GC算法中，会计算每个对象年龄的大小，如果达到某个年龄后发现总大小已经大于了Survivor空间的50%，那么这时候就需要调整阈值，不能再继续等到默认的15次GC后才开始晋升，因为这样会导致Survivor空间不足，所以需要调整阈值，让这些存活对象尽快完成晋升。</p>
<p>枚举根节点</p>
<p>当执行系统停顿下来后，并不需要一个不露地检查完所有执行上下文和全局的引用位置，虚拟机应该当是有办法直接得知哪些地方存放着对象引用。再HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。</p>
<p>安全点</p>
<p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得更高；</p>
<p>实际上，HotSpot并没有为每条指令都生成OopMap，而只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停；</p>
<p>安全点的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负载，所以，安全点的选定基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显的特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点；</p>
<p>对于安全点，另一个需要考虑的问题就是如何让在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来：抢占式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。</p>
<p>抢占式中断：它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它执行到安全点上，再进行中断。</p>
<p>主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
<p>现在几乎没有虚拟机采用抢占式中断来暂停线程从而相应GC事件。</p>
<p>安全区域</p>
<p>在使用安全点似乎已经完美解决了如何进入GC的问题，但实际情况却并不一定，安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点，但如果程序在“不执行”的时候呢？所谓程序不执行就是没有分配CPU时间，典型的例子就是处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，JVM也显然不太可能等待线程重新弄分配CPU时间，对于这种情况，就需要安全区域（Safe Region）来解决了。</p>
<p>在线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，那样，当在这段时间里JVM要发去GC时，就不用管标识自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待知道收到可以安全离开安全区域的信号为止。</p>
<p>CMS（Concurrent Mark Sweep）收集器，以获取最短回收停顿时间（STW）为目标，多数应用于互联网站或者B/S系统的服务器端上，</p>
<p>CMS垃圾回收器详解：<a href="https://blog.csdn.net/zqz_zqz/article/details/70568819">https://blog.csdn.net/zqz_zqz/article/details/70568819</a></p>
<p>CMS是基于“标记-清除“算法实现的，整个过程分为4个步骤：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>其中，初始标记和重新标记步骤仍然需要STW，初始标记只是标记一下GC Roots能直接关联到的对象，速度很快；</p>
<p>并发标记阶段就是进行GC Roots Tracing的过程；</p>
<p>重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的挺短时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>在整个过程中耗时最长的并发标记和并发清理的过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>优点：</p>
<p>并发收集、低停顿</p>
<p>缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现”Concurrent Mode Failure“失败而导致另一次Full GC的产生 。如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupanyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，要是CMS运行期间预留的内存无法满足程序需要时，虚拟机将启动后备预案：临时启动Serial Old收集器来重新进行老年代的来及手机，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高了很容易导致大量”Concurrent Mode Failure“失败。性能反而降低。</li>
<li>收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一个Full GC。CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
</ul>
<p>空间分配担保</p>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。当大量对象在Minor GC后仍然存活，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象容量的平均值作为经验值），则进行一次Full GC。</p>
<p>CMS更详细的步骤：</p>
<ol>
<li> 初始标记(CMS-initial-mark) ,会导致swt；</li>
<li> 并发标记(CMS-concurrent-mark)，与用户线程同时运行；</li>
<li> 预清理（CMS-concurrent-preclean），与用户线程同时运行；</li>
<li> 可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</li>
<li>重新标记(CMS-final remark) ，会导致swt；</li>
<li> 并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</li>
<li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</li>
</ol>
<p>初始标记</p>
<p>\1. 标记老年代中所有的GC Roots对象，如下图节点1；</p>
<p>\2. 标记年轻代中活着的对象引用到的老年代的对象（指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象）如下图节点2、3；</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>并发标记</p>
<p>从“初始标记”阶段标记的对象开始找出所有存活的对象;</p>
<p>为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代；</p>
<p>并发标记阶段只负责将引用发生改变的Card标记为Dirty状态，不负责处理；</p>
<p>如下图所示，也就是节点1、2、3，最终找到了节点4和5。并发标记的特点是和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>预清理阶段</p>
<p>前一个阶段已经说明，不能标记出老年代全部的存活对象，是因为标记的同时应用程序会改变一些对象引用，这个阶段就是用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为Direty的Card</p>
<p>如下图所示，在并发清理阶段，节点3的引用指向了6；则会把节点3的card标记为Dirty；</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>最后将6标记为存活,如下图所示：</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>可终止的预处理</p>
<p>这个阶段尝试着去承担下一个阶段Final Remark（STW）阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生aboart的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。</p>
<p>ps:此阶段最大持续时间为5秒，之所以可以持续5秒，另外一个原因也是为了期待这5秒内能够发生一次ygc，清理年轻代的引用，是的下个阶段的重新标记阶段，扫描年轻带指向老年代的引用的时间减少；</p>
<p>重新标记</p>
<p>这个阶段会导致第二次stop the word，该阶段的任务是完成标记整个年老代的所有的存活对象。</p>
<p>这个阶段，重新标记的内存范围是整个堆，包含_young_gen和_old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了，也会使用这些不可达的对象当做cms的“gc root”，来扫描老年代； 因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作“GC ROOTS”:当此阶段耗时较长的时候，可以加入参数-XX:+CMSScavengeBeforeRemark，在重新标记之前，先执行一次ygc，回收掉年轻带的对象无用的对象，并将对象放入幸存带或晋升到老年代，这样再进行年轻带扫描时，只需要扫描幸存区的对象即可，一般幸存带非常小，这大大减少了扫描时间</p>
<p>由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻带的对象对老年代的引用已经发生了很多改变，这个时候，remark阶段要花很多时间处理这些改变，会导致很长stop the word，所以通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候。</p>
<p>另外，还可以开启并行收集：-XX:+CMSParallelRemarkEnabled</p>
<p>并发清理</p>
<p>通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过Garbage Collector采用清扫的方式回收那些不能用的对象了。</p>
<p>这个阶段主要是清除那些没有标记的对象并且回收空间；</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p>并发重置</p>
<p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p>
<p>CMS将大量工作分散到并发处理阶段来减少STW时间。</p>
<p>吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量。</p>
<p>衡量一个系统吞吐量的好坏：</p>
<ul>
<li>在一个小时内同一个事务（或者任务、请求）完成的次数（tps）</li>
<li>数据库一小时可以完成多少次查询</li>
</ul>
<p>对于关注吞吐量的系统，卡顿是可以接收的，因为这个系统关注长时间的大量任务的执行能力，单次快速的响应并不值得考虑。</p>
<p>响应能力：</p>
<p>响应能力指的是一个程序或者系统对请求是否能够及时响应，比如：</p>
<ul>
<li>一个桌面UI能多快地影响一个时间</li>
<li>一个网站能够多块返回一个页面请求</li>
<li>数据库能够多快返回查询的数据</li>
</ul>
<p>对于这类对响应能力敏感的场景，长时间的停顿是无法接收的。 </p>
<p>G1收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。满足短时间GC停顿的同时达到一个较高的吞吐量。</p>
<p>G1官方文档：<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></p>
<p>G1收集器的设计目标</p>
<ul>
<li>与引用线程同时工作，几乎不需要STW</li>
<li>整理剩余空间，不产生内存碎片（CMS只能在Full GC时，用STW整理内存碎片）</li>
<li>GC停顿更加可控</li>
<li>不牺牲系统的吞吐量</li>
<li>GC不要求额外的内存空间（CMS需要预留空间存储浮动垃圾）</li>
</ul>
<p>heap被划分为一个个相等的不连续的内存区域（regions），每个region都有一个分代的角色：eden、survivor、old</p>
<p>对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化</p>
<p>G1最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域（region）</p>
<p>G1使用了gc停顿可预测的模型，来满足用户设定的gc停顿时间，根据用户设定的目标时间，G1会自动地选择哪些region要清除，一次清除多少个region</p>
<p>G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存（Copying收集算法）</p>
<p>特点：G1使用的copying算法不会造成内存碎片，并且只是针对特定的region进行整理，因此不会导致gc停顿的时间过长。</p>
<p>G1并非一个实时的收集器，与PS一样，对gc停顿时间的设置并不是绝对生效，只是G1有较高的几率保证不超过设定的gc停顿时间。与之前的gc收集器对比，G1会根据用户设定的gc停顿时间，只能评估哪几个region需要被回收可以满足用户的设定。</p>
<p>G1将整个堆分成了相同大小的分区（Region）：</p>
<p>每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，这样方便复用之前分代框架的逻辑。</p>
<p>在物理上不需要连续，则带来了额外的好处——有的分区内垃圾对象也别多，有的分区内垃圾对象很少，G1会优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即首先收集垃圾最多的分区。</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>依然是在新生代满了的时候，对整个新生代进行回收——整个新生代中的对象，要么被回收，要么晋升，至于新生代也采取分区机制的原因，则是因为这样跟老年代的策略统一，方便调整代的大小。</p>
<p>G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩。</p>
<p>收集集合（CSet）：一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自eden空间、survivor空间或者老年代。</p>
<p>已记忆集合（RSet）：Rset记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象），RSet的价值在于使得垃圾收集器不需要扫描整个堆到谁引用了当前分区中的对象，只需要扫描RSet即可。</p>
<p>G1 GC是在points-out的card table之上再加了一层结构来构成points-into RSet：每个region会记录下到底哪些别的region有指向自己的指针，而这些指针分别在哪些card的范围内；</p>
<p>RSet其实是一个hash table，key是别的region的其实地址，value是一个集合，里面的元素是card table和index。举例来说，如果region A的RSet里面有以想的key是region B，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以堆region A来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。</p>
<p>SATB（Snapshot-At-The-Begining）:是G1在并发标记阶段使用的增量式的标记算法；</p>
<p>并发标记式并发多线程的，但并发线程在同一时刻只扫描一个分区；</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>Humongous（巨大的）：如果某一个对象的大小超过了region区域大小的50%，就被放置到humongous区域当中，humongous是eden、survivor、old generation其中一个。巨型对象默认直接会被分配在老年代，如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>不要求堆空间连续。</p>
<p>对于老年代的收集：</p>
<p><img src="assets/clipboard.png" alt="img"></p>
<p>Full GC不是由G1完成的。</p>
<p>G1提供了两种GC模式，Young GC和Mixed GC，两者都需要STW</p>
<p>Young GC：选定所有年轻代的Region。通过控制年轻代的Region个数，即年轻代内存大小，来控制Young GC的时间开销</p>
<p>Mixed GC：选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</p>
<p>Mixed GC不是Full GC，它只能回收部分老年代的Region，如果Mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（Full GC）来收集整个GC heap。所以本质上，G1是不提供Full GC的。</p>
<p>global concurrent marking的执行过程类似CMS，但是不同的是，在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节</p>
<p>global concurrent marking共分为如下四个步骤：</p>
<p>初始标记（initial mark，STW）：它标记了从GC Root开始直接可达的对象</p>
<p>并发标记（Concuurent Marking）:这个阶段从GC Root开始对heap中的对象进行标记，标记线程与应用程序线程并发执行，并且收集各个Region的存活对象信息</p>
<p>重新标记：（Remark，STW）:标记那些在并发标记阶段发生变化的对象，将被回收</p>
<p>清理（Cleanup）:清除空Region（没有存活对象的），加入到free list。</p>
<p>第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用root scan操作，所以可以说global concurrent marking是伴随Young GC而发生的，</p>
<p>第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。</p>
<p>G1在运行过程中的主要模式</p>
<ol>
<li>YGC（不同于CMS）</li>
<li>并发阶段</li>
<li>混合模式</li>
<li>Full GC（一般是G1出现问题时发生）</li>
</ol>
<p>G1 YGC在Eden充满时触发，在回收之后所有之前属于Eden的区块全部变成空白，即不属于任何一个分区（Eden、Survivor、Old）</p>
<p>Mixed GC由一些参数控制，另外也控制着哪些老年代Region会被选入CSet（收集集合）</p>
<p>G1HeapWastePercent：在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</p>
<p>G1MixedGCLiveThresholdPercent：old genration region中存活对象的占比，只有在此参数之下，才会被选入CSet。</p>
<p>G1MixedGCCountTarget：一次gloal concurrent marking之后，最多执行Mixed GC的次数</p>
<p>G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet的最多old generation region数量。</p>
<p>每次GC时，所有新生代都会被扫描，所以无需记录新生代之间的记录引用，只需要记录老年代到新生代之间的引用即可。</p>
<p>如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这问题，在G1中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组小标来标识每个分区的空间地址）</p>
<p>Young GC的阶段：</p>
<p>阶段1：根扫描</p>
<ul>
<li>静态和本地对象被扫描</li>
</ul>
<p>阶段2：更新RS</p>
<ul>
<li>处理dirty card队列更新RS</li>
</ul>
<p>阶段3：处理RS</p>
<ul>
<li>检测从年轻代指向老年代的对象</li>
</ul>
<p>阶段4：对象拷贝</p>
<ul>
<li>拷贝存活的对象到survivor/old区域</li>
</ul>
<p>阶段5：处理引用队列</p>
<ul>
<li>软引用，，弱引用。虚引用处理</li>
</ul>
<p>Mixed GC</p>
<ul>
<li>全局并发标记（global concurrent marking）</li>
<li>拷贝存活对象（evacuation）</li>
</ul>
<p>三色标记算法</p>
<p>描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性。</p>
<p>我们将对象分成三种类型：</p>
<ol>
<li>黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有的field也被标记完了）</li>
<li>灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的field还没有被标记或标记完）</li>
<li>白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象（对象没有被标记到）</li>
</ol>
<p>遍历了所有可达的对象后，所有可达的对象都变成了黑色，不可达的对象即为白色，需要被清理。</p>
<p>如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p>
<p>三色标记带来了两个问题，一个是新创建的对象的问题，另一个就是对象丢失的问题</p>
<p>SATB的步骤：</p>
<ol>
<li>在开始标记的时候生成一个快照图，标记存活对象</li>
<li>在并发标记的时候所有被改变的对象入队（在write barrier里所有旧的引用所指向的对象都变成非白的）</li>
<li>可能存在浮动垃圾，将在下次被收集</li>
</ol>
<p>新生代使用分区机制的主要是因为便于调整代的大小。</p>
<p>在GC收集的时候，新生代的对象也认为是活的对象，除此之外其他不可达的对象都是认为是垃圾对象。</p>
<p>解决两个问题的方式：</p>
<p>1、如何找到在GC过程中分配的对象呢？每个region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。通常这种方式我们就找到了在GC过程中新分配的对象，并把这些对象认为是活的对象。</p>
<p>2、G1通过Write Barrier对引用字段进行赋值做了额外处理。通过Write Barrier就可以了解到那些引用对象发生了什么样的变化。</p>
<ol>
<li>对black新引用了一个white对象，然后又从gray对象中删除了对改white对象的引用，这样会造成了该white对象漏标记</li>
<li>对black新引用了一个white对象，然后从gray对象删了一个引用该white对象的white对象，这样也会造成了该white对象漏标记</li>
<li>对black新引用了一个刚new出来的white对象，没有其他gray对象引用该white对象，这样也会造成了该white对象漏标记</li>
</ol>
<p>SATB在marking阶段中，对于从gray对象移除的目标引用对象标记为gray，对于black引用的新产生的对象标记为black，由于是在开始时进行的snapshot，因而可能存在浮动垃圾。</p>
<p>误标没什么关系，顶多造成浮动垃圾，在下次gc还是可以回收的，但是漏标的后果是致命的，把本应该存活的对象给回收了，从而影响程序的正确性。</p>
<p>漏标的情况只会发生在白色对象中，且满足以下任意一个条件：</p>
<ol>
<li>并发标记时，应用线程给一个黑色对象的引用类型字段赋值了该白色对象</li>
<li>并发标记时，应用线程删除所有灰色对象到该白色对象的引用（可能存在黑色对象引用的情况）</li>
</ol>
<p>解决方案：</p>
<ol>
<li>利用post-write barrier记录所有新增的引用关系，然后根据这些引用关系为根重新扫描一遍</li>
<li>利用post-write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根重新扫描一遍</li>
</ol>
<p>设置停顿时间：</p>
<p>-XX:MaxGCPauseMillis=x    // 设置启动应用程序暂停时间，一般情况下是100ms-200ms </p>
<p>停顿时间不是越短越好，设置的时间越短意味着每次收集的CSet就越小，导致垃圾逐步积累变多，最终不得不退化程Serial GC，停顿时间设置的过长那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间。</p>
<p>CSet里面总是具有所有年轻代里面的Region</p>
<p>CSet = 年轻代所有的Region + 全局并发阶段标记出来的收益高的老年代Region</p>
<p>当Mixed GC赶不上对象产生的速度的时候就退化成Full GC，这一点是需要重点调优的地方。</p>
<p>G1会在Young GC和Mixed GC之间不断地切换，同时定期地做全局并发标记，在实在赶不上对象创建速度的情况下使用Full GC（Serial GC）</p>
<p>G1收集器在运行的时候会自动调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间的目标值。</p>
<p>设置了新生代大小相当于放弃了G1为我们做的自动调优，我们只需要设置整个堆内存大小即可。</p>
<p>Evacuation Failure：类似CMS晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，于是不得不退化成Full GC来做一次全局范围内的垃圾收集。</p>
<p>每个Region默认按照512Kb划分成多个Card</p>
<p>RSet：<a href="https://www.jianshu.com/p/870abddaba41">https://www.jianshu.com/p/870abddaba41</a></p>
<p>JDK网页：<a href="https://openjdk.java.net/">https://openjdk.java.net</a></p>
<p>-verbose:gc -Xms10m -Xmx10m -XX:+UseG1GC   // 使用GC垃圾收集器 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:MaxGCPauseMillis=200m  // 最大停顿时间 </p>
<p>ZGC</p>
<p>使用java实现jvm：<a href="https://github.com/fuzhengwei/itstack-demo-jvm">https://github.com/fuzhengwei/itstack-demo-jvm</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>面试题精选</title>
    <url>/2020/10/07/Interview/</url>
    <content><![CDATA[<p>==面试==</p>
<span id="more"></span>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>Java 语⾔有哪些特点?</p>
<ul>
<li>简单易学</li>
<li>面向对象（封装、继承、多态）</li>
<li>跨平台</li>
<li>可靠性</li>
<li>安全性</li>
<li>支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程设计，Java提供了多线程支持）</li>
<li>支持网络编程</li>
<li>编译与解释并存</li>
</ul>
</li>
<li><p>JVM、JDK 和 JRE 联系与区别？</p>
<p> JVM（Java虚拟机）是运行Java字节码的虚拟机，JVM针对于不同的操作系统有不同的实现（Windows,Linux,Mac os），在不同的操作系统上使用相同的字节码文件可以得到相同的结果。</p>
<p> Java程序从源代码到运行一般经历下面3个步骤：</p>
<p> <img src="./assets/1602514407754.png" alt="1602514407754"></p>
<p> JDK（Java Development Kit）是功能齐全的Java SDK，它不止有JRE，还有编译器（Javac）和工具（例如Java doc 和Jdb），它可以创建和编译程序。</p>
<p> JRE是Java运行时环境，它是运行已经编译的Java程序所需的内容的集合，包括Java虚拟机、Java类库、Java命令和其他的一些基础构件，但是，它不能用来创建新的程序。</p>
</li>
<li><p>Java 和 C++的区别?</p>
<ul>
<li>都是面向对象的语言，都具有继承、封装、多态的特性</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，但接口可以多继承，C++支持多重继承</li>
<li>Java有自动内存管理机制，C++需要手动释放无用的内存</li>
</ul>
</li>
<li><p>构造器 Constructor 是否可被 override?</p>
<p> 构造器无法被重写，但可以重载。</p>
</li>
<li><p>重载和重写的区别</p>
<p> 重载发生在同一个类中，方法名必须相同，参数类型、个数、顺序不同，方法返回值和修饰值可以不同。下面是《Java核心技术》对于重载的介绍：</p>
<p> <img src="./assets/1602518952457.png" alt="1602518952457"></p>
</li>
<li><p>Java ⾯向对象编程三⼤特性: 封装 继承 多态</p>
<ul>
<li>封装</li>
</ul>
<p> 封装是把一个对象的属性私有化，根据需要提供一些可以被外界访问属性的方法。</p>
<ul>
<li>继承</li>
</ul>
<p> 继承是使用已经存在的类的定义作为基础建立新的类，新类的定义可以增加新的数据或功能，也可以使用父类的功能，子类拥有父类所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，子类可以拥有自己的属性和方法，即子类可以对父类进行扩展，子类也可以重写父类的方法。</p>
<ul>
<li>多态</li>
</ul>
<p> 多态是值程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须是在程序运行期间才能决定。</p>
</li>
<li><p>String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</p>
<ul>
<li>String：不可变字符序列</li>
<li>StringBuffer：可变字符序列，效率低，线程安全</li>
<li>StringBuilder：可变字符序列，效率高，线程不安全</li>
</ul>
</li>
<li><p>深拷贝和浅拷贝的区别？</p>
<p> 浅拷贝：对于基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝；</p>
<p> 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
</li>
<li><p>接口和抽象类的区别</p>
<ul>
<li><p>接口的方法默认都是public，所有的方法在接口中不能有实现；</p>
</li>
<li><p>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定；</p>
</li>
<li><p>一个类可以实现多个接口，但只能实现一个抽象类。但接口本身可以多继承。</p>
</li>
<li><p>接口方法的默认修饰符是public，抽象类的方法的修复可以是public、protected和default这些修饰符（不能是private）；</p>
</li>
<li><p>从设计的层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p>
<p>  以上对JDK8之前的定义和规范，从JDK8开始接口的概念有了一些变化：</p>
</li>
</ul>
<p> 在JDK7或更早的版本中，接口里面只能由常量、变量和抽象方法，实现接口类必须重写接口中的抽象方法，JDK8接口中增加了默认方法和静态方法，JDK9接口中增加了私有方法和私有静态方法。</p>
</li>
<li><p>构造方法有哪些特性？</p>
<ul>
<li><p>名称与类名相同</p>
</li>
<li><p>没有返回值，但不能用void声明构造方法</p>
</li>
<li><p>生成类的对象时自动执行，无需调用</p>
</li>
<li><p>默认有一个不带参数的构造方法</p>
</li>
<li><p>如果显式的指定了带参的构造方法，默认不再提供无参的构造方法</p>
<p>  <img src="./assets/20180209005040443.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>⾃动装箱与拆箱</p>
<p>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<p>在JDK5之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>JDK5之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>基本数据类型对应的包装类型：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>int(4字节)</td>
<td>Integer</td>
</tr>
<tr>
<td>byte(1字节)</td>
<td>Byte</td>
</tr>
<tr>
<td>short(2字节)</td>
<td>Short</td>
</tr>
<tr>
<td>long(8字节)</td>
<td>Long</td>
</tr>
<tr>
<td>float（4字节）</td>
<td>Float</td>
</tr>
<tr>
<td>double（8字节）</td>
<td>Double</td>
</tr>
<tr>
<td>char（2字节）</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol>
<li><p>List、Set、Map三者的区别？</p>
<p> List用来存储一组不唯一（可以重复），有序的对象；</p>
<p> Set用来存储不允许重复的集合，不会有多个元素引用相同集合的对象；</p>
<p> Map是用来存储键值对的，Map会维护与Key有关联的值，两个不同的Key可以引用相同的对象，Key不能重复。</p>
</li>
</ol>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ol>
<li><p>Java如何开启线程？怎么保证线程安全？</p>
<p>  这里首先得明确一下线程和进程的区别，进程是操作系统进行资源分配的最小单位，线程是操作系统任务分配的最小单位，线程隶属于进程。</p>
<p>  开启线程的具体方式：</p>
<pre><code>1. 继承Thread类，重写run方法
2. 实现Runnable接口，实现run方法
3. 实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程执行的返回值
4. 通过线程池来开启线程
</code></pre>
<p> 那么如何保证线程安全呢？</p>
<p>采用加锁的方式：使用JVM提供的Synchronized关键字或者JDK提供的各种锁Lock。</p>
</li>
<li><p>volatile和Synchronized有什么区别？</p>
<p>Synchronized关键是用来加锁，volatile只是保持变量的线程可见性，通常适用于一个线程写，多个线程读的场景。</p>
</li>
<li><p>volatile能不能保证线程安全？</p>
<p>不能。volatile关键字只能保证线程可见性，不能保证原子性，相关的示例：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static boolean flag = true;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>DCL(Double Check Lock)单例为什么加volatile？</p>
<p>volatile防止指令重排，在DCL中，防止高并发情况，指令重排造成的线程安全问题，相关示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> SingleDemo singleDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"><span class="comment">//        if (null == this.singleDemo) &#123;</span></span><br><span class="line"><span class="comment">//            synchronized (SingleDemo.class) &#123;</span></span><br><span class="line"><span class="comment">//                if (null == this.singleDemo) &#123;</span></span><br><span class="line"><span class="comment">//                    singleDemo = new SingleDemo();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        singleDemo = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">        <span class="keyword">return</span> singleDemo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>Java线程锁机制是怎样的？偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？<ol start="2">
<li>Java的锁就是在对象的MarkWord中记录一个锁状态、无锁、偏向锁、轻量级锁、重量级锁对应不同锁状态<ol start="3">
<li>Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>  偏向锁、轻量级锁、重量级锁及锁机制具体如下图：</p>
<p>  <img src="./Interview.assets/1623338377030.png" alt="1623338377030"></p>
<ol start="6">
<li>谈谈你对AQS的理解，AQS如何实现可重入锁？</li>
</ol>
<p>  AQS是一个Java线程同步的框架，是JDK中很多锁工具的核心实现框架，在AQS中，维护了一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列，  其中这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行的，在不同的场景下，有不用的意义。</p>
<p>  在可重入锁这个场景下，state就用来表示枷锁的次数，0标识加锁的次数，每加一次锁，state就加1，释放锁state就减1。</p>
<p>  <img src="./Interview.assets/1623338441636.png" alt="1623338441636"></p>
<ol start="7">
<li>有A、B、C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？如何保证三个线程有序交错进行？</li>
</ol>
<p>  可以使用三大工具：CountDownLatch，CylicBarrier，Semaphore</p>
<ul>
<li>保证三个线程同时执行的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">        ThreadSafeDemo threadSafeDemo = <span class="keyword">new</span> ThreadSafeDemo();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(System.currentTimeMillis());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>保证三个线程依次执行的示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderThread2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> ticket = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;a&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;b&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;c&quot;</span> + i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保证三个线程有序交错进行的示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用信号量来限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s3 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s1.acquire();</span><br><span class="line">            s2.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s1.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                s2.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s2.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                s3.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s3.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                s1.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>如何对一个字符串快速进行排序？</li>
</ol>
<p>  可以使用Fork/Join框架来完成，相关示例：</p>
<h2 id="Java网络通信"><a href="#Java网络通信" class="headerlink" title="Java网络通信"></a>Java网络通信</h2><ol>
<li><p>TCP和UDP有什么区别？</p>
<p> TCP（Transfer Control Protocol）是一种面向连接的、可靠的、传输层通讯协议。</p>
<p> TCP的特点：类似打电话，面向连接的、点对点的通信、高可靠的，效率比较低，占用的系统资源比较多。</p>
<p> UDP（User Datagram Protocol）是一种无连接的、不可靠的、传输层的通讯协议。</p>
<p> UDP的特点：类似广播，不需要连接，发送方不管接受方有没有准备好，直接发消息，可以进行广播发送的，传输不可靠，有可能丢失消息，效率比较高，协议比较简单，占用的系统资源比较少。</p>
</li>
<li><p>TCP为什么是三次握手，而不是两次？</p>
</li>
</ol>
<p>  TCP建立连接三次握手，断开连接四次挥手。 如果是两次握手，可能会造成连接资源浪费的情况，server端会建立通道一直等待连接，但是client端会认为连接失败，放弃本次通信。</p>
<p>  <img src="./Interview.assets/1623338572945.png" alt="1623338572945"></p>
<ol start="3">
<li>Java有哪几种IO模型？有什么区别？</li>
</ol>
<p>  有BIO 同步阻塞IO、NIO 同步非阻塞IO、AIO异步非阻塞IO模型。</p>
<p>  这里的同步、异步针对请求，阻塞和非阻塞针对客户端。</p>
<p>  在一个网络请求中，客户端会发一个请求到服务端：</p>
<ul>
<li><p>客户端发了请求后，就一直等着服务端响应，客户端：阻塞。请求：同步</p>
</li>
<li><p>客户端发了请求后，就去干别的事情了，是不是的过来检查服务端是否给出了响应，客户端：非阻塞，请求：同步</p>
</li>
<li><p>换成异步请求，客户端发了请求后，就坐在椅子上，等着服务端返回响应。客户端：阻塞，请求：异步。 </p>
</li>
<li><p>客户端发了请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。客户端：非阻塞。请求：异步</p>
</li>
</ul>
<p>  具体区别如下：</p>
<p>  BIO模式：可靠性差，吞吐量低，适用于连接比较少且比较固定的场景，JDK1.4之前唯一的选择。编程模型最简单。</p>
<p>  <img src="./Interview.assets/1623338605138.png" alt="1623338605138"></p>
<p>  NIO模型：可靠性比较好，吞吐量比较高，适用于连接多，并且连接比较短（轻操作），例如聊天室，JDK1.4开始支持，变成模型最复杂。</p>
<p>  <img src="./Interview.assets/1623338629356.png" alt="1623338629356"></p>
<p>  AIO模型：可靠性是最好的，吞吐量也是最高的，适用于连接比较多，并且连接比较长（重操作），例如相册服务器，JDK7开始支持的，变成模型相对简单，但是需要操作系统支持。</p>
<p>  <img src="./Interview.assets/1623338646312.png" alt="1623338646312"></p>
<ol start="4">
<li>Java NIO的几个核心组件是什么？分别有什么作用？</li>
</ol>
<p>  Java NIO的几个核心组件有：Channel、Buffer、Selector</p>
<p>  <img src="./Interview.assets/1623338667701.png" alt="1623338667701"></p>
<p>  Channel类似于流，每个Channel对应一个Buffer缓冲区，Channel会注册到Selector，Selector会根据Channel上发生的读写时间，将请求交由某个空闲的线程处理，Selector对应一个或者多个线程。Buffer和Channel都是可读可写的。</p>
<ol start="5">
<li>select、poll、epoll有什么区别？</li>
</ol>
<p>  他们是NIO中多路复用的三种实现机制，是由linux操作系统提供的。</p>
<p>  用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两个部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间。</p>
<p>  文件描述符 File Descriptor（FD）：是一个抽象的概念，形式上是一个整数，实际上是一个索引值。指向内核中为每个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD，Unix、Linux。</p>
<ul>
<li>select机制：会维护一个FD的结合fd_set。将fd_set从用户空间复制到内核空间，激活socket。</li>
</ul>
<ul>
<li>poll机制：和select机制差不多的。把fd_set结构进行了优化，FD集合的大小就突破了操作系统的限制，poll fd结构来代替fd_set，通过链表实现</li>
</ul>
<ul>
<li>epoll(Event poll)：epoll中不再扫描所有的FD，而是只将用户关心的FD的事件存放到内核的一个事件表当中。这样就可以减少用户空间与内核空间之前需要拷贝的数据。 </li>
</ul>
<p>  总结如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>操作方式</th>
<th>底层实现</th>
<th>最大连接数</th>
<th>IO效率</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>遍历</td>
<td>数组</td>
<td>受限于内核</td>
<td>一般</td>
</tr>
<tr>
<td>poll</td>
<td>遍历</td>
<td>链表</td>
<td>无上限</td>
<td>一般</td>
</tr>
<tr>
<td>epoll</td>
<td>事件回调</td>
<td>红黑树</td>
<td>无上限</td>
<td>高</td>
</tr>
</tbody></table>
<p>  那Java的NIO当中时使用的哪种机制呢？</p>
<p>  与操作系统有关，在windows下，WindowsSelectorProvider。而linux下，根据linux的内核版本，2.6内核版本以上，就是EpollSelectorProvider，默认使用的是PollSelectorProvider</p>
<ol start="6">
<li>描述下HTTP和HTTPS的区别？</li>
</ol>
<p>  HTTP：是互联网上应用最为广泛的一种网络通信协议，基于TCP协议，可以使用浏览器工作更为高效，减少网络传输。</p>
<p>  HTTPS：是HTTP的加强版，可以认为是HTTP + SSL（Secure Socket Layer）。在HTTP的基础上增加了一系列的安全机制，一方面保证数据传输安全，另一方面对访问者增加了验证机制。是目前现行架构下，最为安全的解决方案。</p>
<p>  主要区别：</p>
<ol>
<li>HTTP的连接时简单无状态的，HTTPS的数据传输时经过证书加密的，安全性更高。</li>
<li>HTTP是免费的，而HTTPS需要申请证书，而证书通常是收费的，并且费用一般不低。</li>
<li>他们的传输协议不同，所以他们使用的端口也是不一样的，HTTP默认端口是80，而HTTPS默认是443端口</li>
</ol>
<p>  HTTPS的缺点：</p>
<ol>
<li>HTTPS的握手协议比较费时，所以会影响服务的响应速度以及吞吐量。</li>
<li>HTTPS也并不是完全安全的，他的证书体系并不是完全安全的。  并且HTTPS在面对DDOS这样的攻击时，几乎起不到任何作用。</li>
<li>证书不免费，并且功能越强大的证书费用越高。</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li><p>JVM内存模型</p>
<p> <img src="./Interview.assets/1623340505687.png" alt="1623340505687"></p>
<p> <img src="./Interview.assets/1623340525614.png" alt="1623340525614"></p>
</li>
<li><p>Java类加载的全过程是怎么样的？什么是双亲委派机制？有什么作用？一个对象从加载到JVM，再到GC清楚，都经历了什么过程？</p>
<p> Java的类加载器：AppClassLoader -&gt; ExtClassLoader -&gt; BootStrapClassLoader</p>
<p> 每一种类加载器都有自己的加载目录，</p>
<p> Java中的AppClassLoader、ExtClassLoader 都继承了URLClassLoader，URLClassLoader继承了SecureClassLoader，SecureClassLoader又继承了ClassLoader</p>
<p> 每个类加载器对他加载过的类，都是有一个缓存的</p>
<p> <img src="./Interview.assets/1623340553847.png" alt="1623340553847"></p>
<p> 双亲委派：向上委托查找，向下委托，作用：保护Java的层的类不会被应用程序覆盖</p>
<p> 核心代码：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 类加载过程：加载 -&gt; 连接 -&gt; 初始化</p>
<ol>
<li>加载：把Java的字节码数据加载到JVM内存当中，并映射成JVM认可的数据结构</li>
<li>连接：分为三个小的阶段：1、验证：检查加载到的字节码信息是否符合JVM规范 2、准备：创建类或接口的静态变量，并赋初始值，半初始化状态 3、把符号引用转为直接引用</li>
<li>初始化：创建对象</li>
</ol>
<p>  详细步骤说明：</p>
<ol>
<li>用户创建一个对象，JVM首先需要到方法区去找对象的类型信息，然后再创建对象。</li>
<li>JVM要实例化一个对象，首先要在堆中先创建一个对象 -&gt; 半初始化状态</li>
<li>对象首先会分配在堆内存中新生代的Eden区，然后经过一次Minor GC，对象如果存活，就会进入S区，在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1，年龄最大值是15，默认就是最大年龄是15。超过年龄先之后，对象转入老年代。</li>
<li>当方法执行结束后，栈中的指针会先移除掉。</li>
<li>堆中的对象，经过Full GC就会被标记为垃圾，然后被GC线程清理掉。</li>
</ol>
</li>
<li><p>怎么样确定一个对象不是垃圾？什么是GC Root？</p>
<p> 有两种定位垃圾的方式：</p>
<ol>
<li>引用计数法：这种方式是给堆内存当中的每个对象记录一个引用个数，引用个数为0的就认为是垃圾。这是早期JDK采用的方式，引用计数无法解决循环引用的问题</li>
<li>根可达算法：这种方式是在内存中，从引用根对象向下一直找引用，找不到的对象就是垃圾。</li>
</ol>
</li>
</ol>
<p>哪些是GC root？stack -&gt; JVM stack Native 、class类。run-time constant pool 常量池、static reference静态变量。</p>
<ol start="4">
<li><p>JVM有哪些垃圾回收算法？</p>
<p> MarkSweep 标记清除算法</p>
<p> <img src="./Interview.assets/1623340629869.png" alt="1623340629869"></p>
<p> 这个算法分为两个阶段，标记阶段：把垃圾内存表及出来，清楚阶段：直接将垃圾内存回收。存在为题：会产生大量的内存碎片。</p>
<p> Copying 拷贝算法</p>
<p> 为了解决标记清除算法的内存碎片问题，就产生了拷贝算法。</p>
<p> <img src="./Interview.assets/1623340652710.png" alt="1623340652710"></p>
<p> 拷贝算法将内存分为大小相等的两半，每次只使用其中的一半，垃圾回收时，将当前这一块的存活对象全部拷贝到另一半，然后当前这一半内存就可以直接清楚。</p>
<p> 这种算法没有内存碎片，但是浪费了内存的空间，并且效率与存活的对象个数有关。</p>
<p> MarkCompack 标记压缩算法</p>
<p> <img src="./Interview.assets/1623340685282.png" alt="1623340685282"></p>
<p> 这种算法在标记阶段跟标记清除算法是一样的，但是在完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将端边界以外的所有内存直接清除。</p>
<p> 这三个算法各有利弊，各自有各自的适合场景。</p>
</li>
<li><p>JVM有哪些垃圾回收器？他们都是怎么工作的？什么是STW？他都发生在哪些阶段？什么是三色标记？</p>
<p> STW：stop the world，是在垃圾晖收算法执行过程当中，需要将JVM内存冻结的一种状态，在STW状态下，Java所有的线程都是停止执行的，GC线程除外，只有native方法可以执行，但是，不能与JVM交互，GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</p>
<p> <img src="./Interview.assets/1623340722723.png" alt="1623340722723"></p>
<p> Serial 串行</p>
<p> <img src="./Interview.assets/1623340748278.png" alt="1623340748278"></p>
<p> 整体过程比较简单，需要GC时，直接暂停，GC完了再继续，这个垃圾收集器，时早期垃圾回收器，只有一个线程执行GC操作，在多CPU架构下，性能就会下降严重，只适用于几十兆的内存空间。</p>
<p>  parallel并行</p>
<p> <img src="./Interview.assets/1623340766008.png" alt="1623340766008"></p>
<p> 在串行基础上，增加多线程GC，PS + PO这种组合是JDK1.8默认的垃圾收集器，在多CPU架构下，性能会比Serial高很多。</p>
<p> CMS</p>
<p> 核心思想：就是将STW打散。让一部分GC线程与用户线程并发执行。</p>
<p> <img src="./Interview.assets/1623340788395.png" alt="1623340788395"></p>
<p> 整个GC过程分为四个阶段：</p>
<p> 1、初始标记阶段：STW 只标记出根对象直接引用的对象</p>
<p> 2、并发标记：继续标记其他对象，与应用程序时并发执行</p>
<p> 3、重新标记：STW对并发执行阶段的对象进行重新标记</p>
<p> 4、并发清楚：并行。将产生的垃圾清除。清除过程中，应用程序又会不断的产生新的垃圾，叫做浮动垃圾。这些垃圾就要留到下一次GC过程中清除。</p>
<p> G1 垃圾优先</p>
<p> 他的内存模型是实际不分代，但是逻辑上是分代的，对于堆内内存就不再区分老年代和新生代，而划分成一个一个的小内存块，叫做Region，每个Region可以隶属于不同的年代</p>
<p> 第一：初始标记，标记出GC　ROOT直接引用的对象，STW</p>
<p> 第二：标记Region，通过Rset标记出上一个阶段标记的Region引用到的OLD区Region</p>
<p> 第三：并发标记阶段：跟CMS的步骤是差不多的，只是遍历的范围不再是整个OLD区，而只需要遍历第二步标记出来的Region</p>
<p> 第四：重新标记，跟CMS中的重新标记过程是差不多的</p>
<p> 第五：垃圾清理：与CMS不同的是，G１可以采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region，而这个阶段，G１只选择垃圾较多的Region来清理。并不是完全清理，</p>
<p> CMS的核心算法就是三色标记。</p>
<p> 三色标记：是一种逻辑上的抽象，将每个内存对象分成三种颜色：黑色：表示自己和成员变量都已经标记完毕。灰色：自己标记完了，但是成员变量还没有完全标记完。白色：自己未标记完。</p>
<p> CMS通过增量标记increment update的方式来解决漏标的问题。</p>
<p> 在G1当中采用SATB的方式来避免错标和漏标的情况。</p>
</li>
<li><p>如何进行JVM调优？JVM参数有哪些？怎么查看一个Java进程的JVM参数，谈谈你了解的JVM参数。如果一个Java程序每次运行一段时间后，就变得非常卡顿，你准备如何对他进行优化？</p>
</li>
</ol>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ol>
<li><p>ＭＱ有什么用？有哪些具体的使用场景？</p>
<p> 队列是一种FIFO先进先出的数据结构，而MQ（Message Queue）即消息队列消息，主要作用就是由生产者发送到ＭＱ进行排队，然后由消费者对消息进行处理，具体使用场景如下：</p>
<ol>
<li>异步：作用能提高系统的响应速度和吞吐量。</li>
</ol>
</li>
<li><p>解耦：服务之间解耦，可以减少服务之间的影响，提高系统的稳定性和可扩展性，另外，解耦之后可以实现数据分发，生产者发送一个消息后，可以由多个消费者来处理。</p>
<ol start="3">
<li>削峰：以稳定的系统资源应对突发的流量冲击。 </li>
</ol>
<p> ＭＱ也有一些缺点：</p>
<ol>
<li>系统的可用性降低：一旦ＭＱ宕机，整个服务就会产生影响。</li>
</ol>
</li>
<li><p>系统的复杂度提高：引入ＭＱ之后，数据链路就会变得很复杂，并伴随着很多的问题，例如如何保证消息不丢失？消息不会重复调用？怎么保证消息的顺序性？　．．．</p>
</li>
<li><p>数据一致性：Ａ系统发消息，需要B、Ｃ两个系统一同处理。如果Ｂ系统处理成功，Ｃ系统处理失败，这就会造成数据一致性的问题。</p>
</li>
<li><p>如何进行产品选型？</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Kafka</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>吞吐量非常大，性能非常好，集群高可用</td>
<td>消息可靠性高，功能全面</td>
<td>高吞吐，高性能，高可用，功能非常全面</td>
</tr>
<tr>
<td>缺点</td>
<td>会丢数据，功能比较单一</td>
<td>吞吐量比较低，消息积累会严重影响性能</td>
<td>开源版功能不如云上商业版。官方文档和周边生态还不够成熟。客户端只支持Java</td>
</tr>
<tr>
<td>适用场景</td>
<td>日志分析、大数据采集</td>
<td>小规模场景</td>
<td>几乎是全场景</td>
</tr>
</tbody></table>
<ol start="3">
<li>如何保证消息不丢失？</li>
</ol>
<p>  这个问题主要分为两个方面，第一，哪些环节会造成消息丢失？第二，在这些可能会造成消息丢失的场景下，如何保证不丢失。</p>
<p>  总的来说，消息传递过程中如果存在跨网络的请求，或者由IO操作，就有可能会造成消息丢失，具体如下图：</p>
<p>  <img src="./Interview.assets/1623338875139.png" alt="1623338875139"></p>
<p>  那么如何保证消息不丢失呢？需要按照上面不同场景来单独处理</p>
<ol>
<li><p>生产者发送消息不丢失</p>
<table>
<thead>
<tr>
<th>产品类型</th>
<th>保证生产者发送消息不丢失策略</th>
</tr>
</thead>
<tbody><tr>
<td>kafka</td>
<td>消息发送+回调</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>事务消息</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>消息发送+回调</td>
</tr>
<tr>
<td></td>
<td>手动事务：Channel：txSelect()开启事务，Channel.txCommit()提交事务，Channel.txRollback()回滚事务，这种方式对channel是会产生阻塞的，造成吞吐量下降</td>
</tr>
<tr>
<td></td>
<td>publisher confirms。整个处理流程跟RocketMQ的事务消息，基本是一样的。</td>
</tr>
</tbody></table>
<p>具体如下图：</p>
<p><img src="assets/1623338892939.png" alt="1623338892939"></p>
</li>
<li><p>MQ主从消息同步不丢失</p>
<table>
<thead>
<tr>
<th>产品类型</th>
<th>主从消息不丢失策略</th>
</tr>
</thead>
<tbody><tr>
<td>RoctMQ</td>
<td>在普通集群中，同步同步、异步同步。异步同步效率更高，但是有丢消息的风险，同步同步就不会丢消息</td>
</tr>
<tr>
<td>Rabbit MQ</td>
<td>普通集群：消息是分散存储的，节点之间不会主动进行消息同步，是有可能丢失消息的</td>
</tr>
<tr>
<td></td>
<td>镜像集群：镜像集群会在节点之间主动进行数据同步，这样数据安全性得到提高。</td>
</tr>
<tr>
<td>Kafka</td>
<td>通常都是用在允许消息少量丢失的场景，可以通过参数配置：acks：0，1，all</td>
</tr>
</tbody></table>
</li>
<li><p>MQ消息存盘不丢失</p>
<p>RocketMQ：同步刷盘、异步刷盘：异步刷盘效率更高，但是有可能丢消息，同步刷盘消息安全性更高，但是效率会降低。</p>
<p>RabbitMQ：将队列配置成持久化队列</p>
</li>
<li><p>消费者消费消息不丢失</p>
<p>RocketMQ:使用默认的方式消费就行，不要采用异步方式</p>
<p>RabbitMQ：autoCommit</p>
<p>Kafka：手动提交offset</p>
</li>
<li><p>如何保证消费幂等性?</p>
<p>其实就是要防止消费者重复消费的问题。</p>
<p>所有MQ产品都没有提供主动解决幂等性的机制，需要由消费者自行控制。</p>
</li>
</ol>
<p>   RocketMQ：给每个消息分配了MessagesID，这个MessagesID可以作为消费者判断幂等的依据，这种方式不太建议。</p>
<p>  最好的方式就是自己带一个有业务标识的id，来进行幂等判断，例如在订单中OrderID</p>
<p>  还可以统一ID分配。</p>
<ol start="4">
<li>MQ如何保证消息顺序?</li>
</ol>
<p>  全局有序和局部有序，MQ只需要保证局部有序，不需要保证全局有序。</p>
<p>  <img src="./Interview.assets/1623338951040.png" alt="1623338951040"></p>
<p>  Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p>
<p>  Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p>
<p>  RocketMQ当中使用Mmap方式对它的文件进行读写。</p>
<p>  在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p>
<ol start="6">
<li><p>如何保证消息的高效读写?</p>
<p> 零拷贝：Kafka和RocketMQ都是通过零拷贝技术来优化文件读写。</p>
<p> 传统文件复制方式：需要对文件在内存中进行四次拷贝。</p>
<p> <img src="./Interview.assets/1623340880885.png" alt="1623340880885"></p>
<p> 零拷贝：有两种方式：mmap和   transfile</p>
<p> <img src="./Interview.assets/1623340901903.png" alt="1623340901903"></p>
<p> Java当中对零拷贝进行了封装，Mmap方式通过MappedByteBuffer对象进行操作，而transfer通过FileChannel来进行操作。</p>
<p> Mmap适合比较小的文件，通常文件大小不要超过1.5G-2G，transfile没有文件大小限制。</p>
<p> RocketMQ当中使用Mmap方式对它的文件进行读写。</p>
<p> 在Kafka当中，它的index日志文件也是通过Mmap的方式来读写的。在其他的日志文件当中，并没有使用零拷贝的方式，Kafka使用transfile方式将硬盘数据加载到网卡。</p>
</li>
<li><p>使用MQ如何保证分布式事务的最终一致性？</p>
<p> 分布式事务指的是业务相关的多个操作，保证他们同时成功或者同时失败。最终一致性指的是保证事务在最后阶段，能够达到一致性即可，与之对应的就是强一致性。</p>
<p> MQ中要保护事务的最终一致性，就需要做到两点：</p>
<ol>
<li>生产者要保证100%的消息投递（使用事务消息机制）</li>
</ol>
</li>
<li><p>消费者这一段需要保证幂等消费（唯一ID + 业务自己实现幂等）</p>
<p> 分布式MQ的三种语义：at least once、at most once、exactly once</p>
<p> Rocket MQ并不能保证exactly once，商业版本中提供了exactly once的实现机制。</p>
<p> Kafka：在最新版本的饿源码当中，提供了exactly once的demo。</p>
<p> RabbitMQ：使用erlang语言天生就成为了一种屏障</p>
</li>
<li><p>如何设计一个MQ？</p>
<p> 两个误区：1、放飞自我，漫无边际 2、纠结技术细节。</p>
<p> 好的方式：1、从整理到细节，从业务场景到技术实现。2、以现产品为基础。</p>
<p> 具体的设计思路：</p>
<ol>
<li>实现单机的队列的数据结构。高效，可扩展</li>
<li>将单机队列扩展成为分布式队列。分布式集群管理</li>
<li>基于Topic定制消息路由策略</li>
<li>实现高效的网络通信 netty - http</li>
<li>规划日志文件，实现文件告诉读写，零拷贝，顺序写，服务重启后，快速还原运行现场</li>
<li>定制高级功能，死信队列、延迟队列、事务消息等等，注意贴合实际。</li>
</ol>
</li>
</ol>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol>
<li><p>为什么使用缓存？</p>
<p> 1、高性能</p>
<p> 2、高可用</p>
<p> ​    <img src="./Interview.assets/1623339151379.png" alt="1623339151379"></p>
</li>
<li><p>什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？</p>
</li>
</ol>
<p>  1）缓存穿透：缓存中查不多，数据库中也查询不到。</p>
<p>  解决方案：1.对参数进行合法性校验 2.将数据库中没有查到的结果的数据也写入到缓存，这时要注意为了防止Redis被无用的key占满，这一类缓存的有效期要设置得短一点。3.引入布隆过滤器，在访问Redis之前判断数据是否存在。要注意布隆过滤器存在一定的误判率，并且，不空过滤器只能加数据不能删数据。</p>
<p>  <img src="./Interview.assets/1623339191238.png" alt="1623339191238"></p>
<p>  2）缓存击穿：缓存中没有，数据库中有，一般是出现在数据初始化以及key过期了的情况，他的问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，给DB造成了很大的压力。</p>
<p>  解决方案：1、设置这个热点缓存永不过期，这时要注意在value 当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。2、在加载DB的时候，要防止并发，只通过一个线程将数据库中的数据加载到缓存当中，从而减少数据库的并发访问量。</p>
<p>  3）缓存雪崩：缓存大面积过期，导致请求都被转发DB，</p>
<p>  解决方案：1、把缓存的失效时间分散开，例如，在原有的统一失效时间基础上，增加一个随机值。</p>
<ol start="3">
<li><p>如何保证Redis与数据库的数据一致？</p>
<p> 当我们对数据进行修改的时候，到底是先删缓存，还是先写数据库？</p>
<p> 1）如果是先删缓存，再写数据库：在高并发场景下，当第一个线程删除了缓存，还没有来得及的写数据库，第二个线程来独去数据，会发现缓存中的数据为空，那就会去读数据库中的数据（旧值、脏数据）读完之后，把读到的结果写入缓存（此时，第一个线程已经将新的值写到缓存里面了），这样缓存中的值就会被覆盖为修改前的脏数据。</p>
<p> 总结：在这种方式下，通常要求写操作不会太频繁。</p>
<p> 解决方案：1、先操作缓存，但是不删除缓存，将缓存修改为一个特殊值（-999），客户端读缓存时，发现是默认直，就休眠一小会，再去查一次Redis，特殊值对业务有侵入，可能会多次重复</p>
<p> 2、延时双删，先删除缓存，再写数据库，休眠一小会，再次删除缓存。如果数据写操作很频繁，同样还是会有脏数据的问题。</p>
<p> 2）先写数据库，再删缓存，如果数据库写完了之后，缓存删除失败，数据就会不一致， </p>
<p> 总结：始终只能保证一定时间内的最终一致性。 </p>
<p> 解决方案：1、给缓存设置一个过期时间，问题：过期时间内，缓存数据不会更新。</p>
<p> 2、引入MQ，保证原子操作。将热点数据缓存设置为永不过期，但是在value当中写入一个逻辑上的过期时间，另起一个后台线程，扫描这些key，对于已逻辑上过期的缓存，进行删除。</p>
</li>
<li><p>如何设计一个分布式锁？如何对锁性能进行优化？</p>
<p> 分布式锁的本质：就是在所有进程都能访问到的一个地方，设置一个锁资源，让这些进程都来竞争锁的资源，数据库、zookeeper、Redis，通常对于分布式锁，会要求响应快、性能高与业务无关。</p>
<p> Redis实现分布式锁：SETNX key value 当key不存在时，就将key设置为value，并返回1，如果key存在就返回0。EXPIRE key locktime 设置key的有效市场，DEL key 删除。 GETSET key value 先GET，再SET，先返回key对应的值，如果没有就返回空，然后再将key设置成value。</p>
<p> 1）最简单的分布式锁：SETNX 加锁。DEL解锁。问题：如果获取到锁的进程执行失败，他就永远不会主动解锁，那这个锁就被锁死了。</p>
<p> 2）给锁设置过期时长。问题：SETNX和EXPIRE并不是原子性的，所以获取到锁的进程有可能还没有执行EXPIRE指令，就挂了，这时锁还是会被锁死。</p>
<p> 3）将锁的内容设置为过期时间（客户端时间+过期时长），SETNX获取锁失败时，拿这个时间跟当前时间比对，如果是过期的锁，就先删除锁，再重新上锁。问题：在高并发场景下，会产生多个进程同时拿到锁的情况</p>
<p> 4）setNX失败后，获取锁上的时间戳，然后用getset，将自己的过期时间更新上去，并获取旧值，如果这个旧值，跟之前获得的时间戳是不一致的，就表示这个锁已经被其他进程占用了，自己要放弃竞争锁。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(RedisConnection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> newTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> expireTime = nowTime + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(conn.SETNX(<span class="string">&quot;mykey&quot;</span>),<span class="string">&quot;1&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        conn.EXPIRE(<span class="string">&quot;mykey&quot;</span>,<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> oldVal = conn.get(<span class="string">&quot;mykey&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(oldVal == <span class="keyword">null</span> &amp;&amp; oldVal &lt; nowTime) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentVal = conn.GETSET(<span class="string">&quot;mykey&quot;</span>,expireTime)</span><br><span class="line">            <span class="keyword">if</span>(oldVal == currentVal) &#123;</span><br><span class="line">                conn.EXPIRE(<span class="string">&quot;mykey&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 5）上面就形成了一个比较高效的分布式锁。分析一下，上面优化的各种问题，在于SETNX和EXPIRE两个指令无法保证原子性。Redis2.6提供了直接执行lua脚本的方式，通过lua脚本来保证原子性，redission。</p>
</li>
<li><p>Redis如何让配置key的过期时间？他的实现原理是什么？</p>
<p> redis设置key的过期时间 1、EXPIRE| 2、SETEX</p>
<p> 实现原理：1、定期删除：每隔一段时间，执行一次删除过期key的操作，平衡执行效率和执行时长。定期删除会遍历每个database（默认16个），检查当前库中指定个数的key（默认是20个），随机抽查这些key，如果有过期的，就删除。程序中有一个全局变量扫描到了哪个数据库。</p>
<p> 2、懒汉式删除：当使用get、getset等指令去获取数据时，判断key是否过期，过期后，就先把key删除，再执行后面的操作。</p>
<p> Redis是将两种方式结合来使用的。</p>
</li>
<li><p>海量数据下，如何快速查找一条记录？</p>
<p> 1、使用布隆过滤器，快速过滤不存在的记录，使用Redis的bitmap结构来实现布隆过滤器。</p>
<p> 2、在Redis中建立缓存 </p>
<p> 3、查询优化。自己实现槽位计算，找到记录应该分配在哪台集器上，然后直接去目标机器上找。</p>
</li>
</ol>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ol>
<li>谈谈你对微服务的理解，微服务有哪些优缺点？</li>
</ol>
<p>  微服务是由Martin Flowler大师提出的。微服务是一种架构风格，通过将大型的单体应用划分为比较小的服务单元，从而降低整个系统的复杂度。</p>
<p>  具有以下优点：</p>
<ul>
<li>服务部署更灵活：每个应用都可以是一个独立的项目，可以独立部署，不依赖其他服务，耦合性降低。</li>
<li>技术选型更加灵活，在大型大体应用中，技术要进行更新，往往是非常困难的。而微服务可以根据业务特点，灵活选择技术栈。</li>
<li>应用的性能得到提高，大型单体应用中，往往启动就会成为一个很大的难关，而采用微服务之后，整个系统的性能是能够提高的。</li>
<li>更容易组合专门的团队，在单体应用中，团队成员往往需要对系统的各个部分都要有深入的了解，门槛是很高的。而采用微服务之后，可以给每个微服务组件专门的团队</li>
<li>代码复用：很多底层服务可以以REST API的方式对外提供统一的服务，所有基础服务可以在整个微服务系统中调用。 </li>
</ul>
<p>  对应的有以下缺点：</p>
<ul>
<li>服务调用的复杂性提高了，面临网络问题、容错问题、负载问题、高并发等等问题</li>
<li>分布式事务，尽量不要使用微服务的分布式事务</li>
<li>测试的难度提升了</li>
<li>运维的难度提升了，单体架构只要维护一个环节，而到了微服务是很多个环境，并且运维方式还都不一样。所以对部署、监控、告警等要求就会变得非常困难</li>
</ul>
<ol start="2">
<li><p>SpringCloud和SpringCloudAlibaba有哪些组件？都解决了什么问题？</p>
<p> 1、SpringCloud：提供了构建微服务系统所需要的一组通用开发模式以及一系列快速实现这些开发模式的工具。</p>
<p> 通常所说的SpringCloud是指SpringCloud NetFlix，他和SpringCloudAlibaba都是SpringCloud这一系列开发模式的具体实现。</p>
<p> SpringCloud NetFlix:</p>
<p> <img src="./Interview.assets/1623339510473.png" alt="1623339510473"></p>
<p> SpringCloudAlibaba:</p>
<p> <img src="./Interview.assets/1623339540507.png" alt="1623339540507"></p>
</li>
<li><p>分布式事务如何处理？怎么保证事务一致性？</p>
<p> 强一致性（刚性事务）。误区：分布式事务=Seata</p>
<p> 分布式事务：就是要将不同节点上的事务操作，提供操作的原子性保证，同时成功或者同时失败。</p>
<p> 分布式事务的第一个要点就是要在原本没有直接关联的事务之间建立联系。</p>
<p> 1）HTTP连接：最大努力通知 –事后补偿</p>
<p> 2）MQ：事务消息机制</p>
<p> 3）Redis：也可以定制出分布式事务机制。</p>
<p> 4）Seata：是通过TC来在多个事务之间建立联系的。</p>
<p> 两阶段：AT XA 核心在于要锁资源，数据库提供了对于事务和锁良好的支持，因此使用AT模式的前题是要应用能够访问到数据库。</p>
<p> 三阶段：TCC 在两阶段的基础上增加一个准备阶段，在准备阶段是不锁资源的，只是表示初始化连接。</p>
<p> SAGA模式：类似于熔断。业务自己实现正向操作和补偿的逻辑。只保证了事务的最终一致性</p>
</li>
<li><p>怎么拆分微服务？怎样设计出高内聚、低耦合的微服务？有没有了解通过DDD领域驱动设计？什么是中台？中台和微服务有什么关系？</p>
<p> 1）拆分微服务的时候，为了保证微服务的稳定，会有一些基本的准则：</p>
<p> 1、微服务之间尽量不要有业务交叉。</p>
<p> 2、微服务之间只能通过接口进行服务调用，而不能绕过接口直接访问对方的数据</p>
<p> 3、高内聚，低耦合。</p>
<p> 高内聚低耦合，是一种从上而下指导微服务设计的方法。·实现高内聚低耦合的工具主要有同步的接口调用和异步的事件驱动（MQ）两种方式。</p>
<p> 什么是DDD：在2004年，由Eric Evans提出的，DDD是面对软件复杂之道。Domain-Driven-Design</p>
<p> Martin Flowler - 贫血模型 - 贫血失忆症 充血模型</p>
<p> MVC架构 -&gt; 领域优先的四层架构</p>
<p> <img src="./Interview.assets/1623339588730.png" alt="1623339588730"></p>
<p> 大泥团：不利于微服务的拆分，大泥团结构拆分出来的微服务就是泥团结构，当服务业务逐渐复杂，这个泥团又会膨胀成为大泥团。</p>
<p> DDD只是一种方法论，没有一个稳定的技术框架。DDD要求领域是跟技术无关、跟存储无关、跟通信无关。</p>
<p> 2）中台这个概念是阿里在2015年提出“小前台、大中台”战略思想。</p>
<p> 所谓中台，就是将各个业务线中可以复用的一些功能抽取出来，剥离个性，提取共性，形成一些可以可复用的组件，例如：盒马鲜生、团购。</p>
<p> 大体上，中台可以分为三类：业务中台、数据中台和技术中台。数据中台、收银中台、支付风控中台。</p>
<p> 中台跟DDD解合：DDD会通过限界上下文将系统拆分成一个一个领域，而这种限界上下文，天生就成了中台之间的逻辑屏障。</p>
<p> DDD在技术与资源调度方面都能够给中台建设提供不错的指导。上层的战略设计能够很好的指导中台划分，下层的战术设计能够很好的指导微服务搭建。</p>
<p> 在目前阶段，DDD还大都处在小范围实验的阶段。</p>
</li>
<li><p>你的项目中是怎么保证微服务敏捷开发的？微服务的链路追踪、持续集成、AB发布要怎么做？</p>
<p> 开发运维一体化。</p>
<p> 敏捷开发：目的就是为了提高团队的交付效率，快速迭代，快速试错。</p>
<p> 每个月固定发布新版本，以分支的形式保存到代码仓库中，快速入职。任务面板、站立会议。团队人员灵活流动，同时形成各个专家代表。测试环境 -&gt; 开发测试环境 -&gt; 集成测试环境 -&gt; 压测环境 -&gt; 预投产环境 -&gt; 生产环境。文档优先。晨会、周会、需求拆分会。</p>
<p> 链路追踪：1、基于日志，形成全局事务ID，落地到日志文件。filebeat -logstash- Elaticsearch形成大型报表。 2、基于MQ，往往需要架构支持，经过流式计算形成一些可视化的结果。</p>
<p> 持续集成：SpringBoot maven pom -&gt; build -&gt; shell；jenkins。</p>
<p> AB发布：1、蓝绿发布、红黑发布。老版本和新版本是同时存在的。2、灰度发布。金丝雀发布。</p>
</li>
</ol>
<h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><ol>
<li><p>Spring框架中Bean的创建过程是怎样的？</p>
<p> 首先，简单来说，Spring框架中的Bean经历过四个阶段：实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p> 然后，具体来说Spring中Bean经过了以下几个步骤：</p>
<ol>
<li>实例化：new **()两个时机，1、当客户端向容器申请一个Bean时，2、当容器在初始化一个Bean时还需要依赖一个Bean，BeanDefinition对象保存。</li>
</ol>
</li>
<li><p>设置对象属性（依赖注入）：Spring通过BeanDefinition找到对象依赖的其他对象，并将这些对象赋予当前对象。</p>
<ol start="3">
<li>处理Aware接口，Spring会检测对象是否实现了***Aware接口，如果实现了，就会调用对应的方法。BeanNameAware、BeanClassLoaderAware、BeanFactoryAware、ApplicationContextAware。</li>
</ol>
</li>
<li><p>BeanPostProcess，Bean创建的前置处理。调用BeanPostProcess的初始化前的方法。</p>
<ol start="5">
<li>InitializingBean：Spring检测对象如果实现了这个接口，就会执行afterPropertiesSet()方法</li>
</ol>
</li>
<li><p>init-method：自定义的初始化回调方法</p>
<ol start="7">
<li>BeanPorcess的后处理的方法，到这里，这个Bean创建过程就完成了，Bean就可以正常使用了。</li>
</ol>
</li>
<li><p>DisposableBean，当Bena实现了这个接口，在对象销毁前就会调用destory()方法。</p>
<ol start="9">
<li>destory-method：自定义Bean销毁的回调方法。</li>
</ol>
</li>
<li><p>Spring框架中的Bean是线程安全的吗？如果线程不安全，如何处理？</p>
<p> Spring容器本身没有提供Bean的线程安全策略，因此，也可以说Spring容器中的Bean不是线程安全的。</p>
<p> 要如何人处理线程安全问题。就要分情况来分析。</p>
<p> Spring中的作用域：1、Sington 2、prototype：为每个Bean请求创建给实例。3、request为每一个请求创建一个实例，请求完成后失败 4、session：与request是类似的 5、global-session：全局作用域。</p>
<p> 对于线程安全问题：</p>
<p> 1、对于prototype作用域，每次都生成一个新的对象，所以不存在线程安全问题。</p>
<p> 2、对于sington作用域，默认就是线程不安全的。但是对于开发中大部分的Bean，其实是无状态的，不需要保证线程安全</p>
<p> 无状态表示这个实例没有属性对象，不能保存数据，是不变的，比如：controller、service、dao</p>
<p> 有状态表示实例有属性对象，可以保存数据，是线程不安全的，比如POJO</p>
<p> 如果要保证线程安全，可以将Bean的作用改为prototype。也可以采用ThreadLocal来解决线程安全的问题，ThreadLocal为每一个线程保存一个副本变量，每个线程只操作自己的副本变量。</p>
</li>
<li><p>Spring是如何处理循环依赖问题的？</p>
<p> 一种是使用@Lazy注解，另一种是使用三级缓存。</p>
<p> 循环依赖：多个对象之间存在循环的引用关系。在初始化过程中，就会出现”先有蛋还是先有鸡“的问题。</p>
<p> @Lazy注解：解决构造方法造成的循环依赖问题</p>
<p> 对于对象之前的普通引用，二级缓存会保存new出来的不完整对象，这样当单例池中找不到依赖的属性时，就可以先从二级缓存中获取到不完整对象，完成对象的创建，在后续的依赖注入过程中，将单例池中对象的引用关系调整完成。</p>
<p> 三级缓存：如果引用的对象配置了AOP，那在单例池中最终就会需要注入动态代理对象，而不是原对象，而生成动态代理是要在对象初始化完成之后才开始的。于是Spring增加了三级缓存，保存所有对象的动态代理配置信息，在发现有循环依赖时，将这个对象的动态代理信息获取出来，提前进行AOP，生成动态代理。</p>
<p> <img src="./Interview.assets/1623339719343.png" alt="1623339719343"></p>
</li>
<li><p>Spring如何处理事务?</p>
<p> Spring当中支持编程式事务管理和声明式事务管理两种方式。</p>
<p> 1、编程式事务可以用TransactionTemlate</p>
<p> 2、声明式事务：是Spring在AOP基础上提供的事务实现机制，他的最大优点是不需要在业务代码中添加事务管理的代码，只需要在配置文件中做相关的事务规则声明就可以了，但是声明式事务只能针对方法级别，无法控制代码级别的事务管理。Spring中对事务定义了不同的传播级别：Propagation</p>
<p> 1、PROPAGATION_REQUIRED：默认传播行为。如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入到事务中。</p>
<p> 2、PROPAGATION_SUPPORTS：如果当前存在事务，就加入到该事务，如果当前不存在事务，就以非事务方式运行。</p>
<p> 3、PROPAGATION_MANDATORY:如果当前存在事务，就加入到该事务，如果当前不存在事务，就抛出异常。</p>
<p> 4、PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。</p>
<p> 5、PROPAGATION_NOT_SUPPORTS：以非事务方式运行，如果当前存在事务，就将当前事务挂起。</p>
<p> 6、PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，就抛出异常。</p>
<p> 7、PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。</p>
<p> Spring中事务的隔离级别：</p>
<p> 1）ISOLATIUON_DEFAULT：使用数据库默认的事务隔离级别。</p>
<p> 2）ISOLATION_READ_UNCOMMITED：读未提交，允许事务在执行过程中，读取其他事务未提交的数据</p>
<p> 3）ISOLATION_READ_COMMITED：读已提交，允许事务在执行过程中，独去其他事务已经提交的数据</p>
<p> 4）ISOLATION_REPEATABLE_UNCOMMITED：可重复度，在同一个事务内，任意时刻的查询结果是一致的。</p>
<p> 5）ISOLATION_READ_SERIALIZABLE：所有事务依次执行。</p>
</li>
<li><p>Spring MVC中的控制器是不是单例模式？如果是，如何保证线程安全？</p>
<p> 控制器是单例模式，单例模式下就会有线程安全问题。</p>
<p> Spring中保证线程安全的方法</p>
<p> 1、将scope设置成singleton，propotype，request。</p>
<p> 2、最好的方式是将控制器设计成无状态模式。在控制器中不要携带数据，但是可以引用无状态的service和dao。</p>
</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol>
<li>MySQL有哪几种数据存储引擎?</li>
</ol>
<p>  可以使用SQL查看支持的数据存储引擎：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> ENGINES;</span><br></pre></td></tr></table></figure>

<p>  其中最为常用的是InnoDB和MyISAM两种，</p>
<p>  MyISAM和InnoDB的区别：</p>
<ol>
<li><p>存储文件，MyISAM每个表有两个文件，MYD和MyISAM文件，MYD是数据文件，MYI是索引文件，而InnoDB每个表只有一个文件，idb</p>
</li>
<li><p>InnoDB支持事务，支持行锁，支持外键。</p>
</li>
<li><p>InnoDB支持XA事务。</p>
</li>
<li><p>InnoDB支持事务的savePoints</p>
</li>
<li><p>什么是脏读、不可重复读、幻读。</p>
</li>
</ol>
<p>  脏读、不可重复读、幻读的概念：</p>
<ol>
<li>脏读：在事务进行过程中，读到了其他事务未提交的数据。</li>
<li>不可重复读：在一个事务过程中，多次查询的结果不一致。（update）</li>
<li>幻读：在同一个事务中，用同样的操作查询数据，得到的记录数不相同。(insert)</li>
</ol>
<p>  处理的方式有很多种：加锁、事务隔离、MVCC，这里只介绍使用加锁来解决这些问题：</p>
<ol>
<li><p>脏读：在修改时加排他锁，直到事务提交提交才释放，读取时加共享锁，读完释放锁</p>
</li>
<li><p>不可重复读，读数据时加共享锁，写数据时加排他锁</p>
</li>
<li><p>幻读，加范围锁</p>
</li>
<li><p>事务的基本特性和隔离级别。</p>
</li>
</ol>
<p>  事务：表示多个数据操作组成一个完整的事务单元，这个事务内的所有数据操作要么同时成功，要么同时失败。</p>
<p>  事务的特性：ACID</p>
<ul>
<li>原子性：事务是不可分割的，要么完全成功，要么完全失败。</li>
<li>一致性：事务无论是完成还是失败。都必须保持事务内操作的一致性。当失败是，都要对前面的操作进行会滚，不管中途是否成功。</li>
<li>隔离性：当多个事务操作一个数据的时候，为防止数据损坏，需要将每个事务进行隔离，互相不干扰</li>
<li>持久性：事务开始就不会终止，他的结果不受其他外在因素的影响</li>
</ul>
<p>  在MySQL中可以设置事务的隔离级别：</p>
<table>
<thead>
<tr>
<th>SQL语句</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SHOW VARIABLES like ‘%transaction’</td>
<td>显示事务的隔离级别</td>
</tr>
<tr>
<td>set transction level **</td>
<td>设置隔离级别</td>
</tr>
<tr>
<td>set session transaction level **</td>
<td>当前会话的事务隔离级别</td>
</tr>
<tr>
<td>set global transaction level **</td>
<td>当前全局的事务隔离级别</td>
</tr>
</tbody></table>
<p>  MySQL当中有五种隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>具体含义</th>
</tr>
</thead>
<tbody><tr>
<td>NONE</td>
<td>不使用事务</td>
</tr>
<tr>
<td>READ UNCOMMITED</td>
<td>允许脏读</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>防止脏读，是最常用的隔离级别</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>防止脏读和不可重复读，MySQL默认</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>事务串行，可以防止脏读、幻读、不可重复度</td>
</tr>
</tbody></table>
<p>  五种隔离级别，级别越高，事务的安全性是更高的，但是，事务的并发性能也会越低。</p>
<ol start="4">
<li>MySQL的锁有哪些？什么是间隙锁？</li>
</ol>
<p>  从锁的粒度来区分：</p>
<p>  1）行锁：加锁粒度小，但是加锁的资源开销比较大。InnoDB支持</p>
<p>  共享锁：读锁，表示多个事务可以对同一个数据共享同一把锁，持有锁的事务都可以访问数据，但是只读不能修改。 select ** LOCK IN SHARE MODE。</p>
<p>  排他锁：写锁，只有一个事务能够获得排他锁，其他事务都不能获取该行的锁。InnoDB会对update，delete、insert语句自动添加排他锁。select ** for update。</p>
<p>  自增锁：通常是针对MySQL当中的自增字段。如果有事务会滚这种情况，数据会回滚，但是自增序列不会回滚。</p>
<p>  2）表锁：加锁粒度大，加锁资源开销比较小，MyIAM和InnoDB都支持。</p>
<p>  表共享读锁，表排他写锁</p>
<p>  意向锁：是InnoDB自动添加的一种锁，不需要用户干预。</p>
<p>  3）全局锁：Flush tables with read lock，加锁之后整个数据库实例都处于只读状态，所有的数据变更操作都会被挂起，一般用于全库备份的时候。</p>
<p>  常见的锁算法：</p>
<p>  1、记录锁：锁一条具体的数据。</p>
<p>  2、间隙锁：RR隔离级别下，会加间隙锁。锁一定的范围，而不是锁具体的记录，是为了防止产生幻读。</p>
<p>  3、Next-key：间隙锁 + 右记录锁。 </p>
<ol start="5">
<li>MySQL索引结构是什么样的？聚簇索引和非聚簇索引又是什么</li>
</ol>
<p>  二叉树 -&gt; AVL树 -&gt; 红黑树 -&gt; B-树 -&gt; B+树</p>
<p>  二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。</p>
<p>  AVL:树中任意节点的两个子树的高度差最大为1.</p>
<p>  红黑树：1、每个节点都是红色或者黑色 2、根节点是黑色 3、每个叶子节点都是黑色的空节点。4、红色节点的父子节点都必须是黑色。5、从任一节点到其中每个叶子节点的所有路径都包含相同的黑色节点。</p>
<p>  B-树：1、B-树的每个非叶子节点的子节点个数都不会超过D（这个D就是B-树的阶）2、所有的叶子节点都在同一层 3、所有节点关键字都是按照递增顺序排列。</p>
<p>  B+树：1、非叶子节点不存储数据，只进行数据索引 2、所有数据都存储在叶子节点当中 3、每个叶子节点都存有相邻叶子节点的指针 4、叶子节点按照本身关键字从小到大排序。</p>
<p>  聚簇索引：数据和索引是在一起。</p>
<p>  非聚簇索引：数据和索引不在一起。</p>
<p>  MyISAM使用的非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址，InnoDB采用的是聚簇索引，树的叶子节点上的data就是数据本身。</p>
<p>  聚簇索引的数据是物理存放顺序和索引顺序是一致的，所以一个表中只能有一个聚簇索引，而非聚簇索引可以有多个。</p>
<p>  InnoDB中，如果表定义了PK，那PK就是聚簇索引，如果没有PK，就会找一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。</p>
<p>  MySQL的索引覆盖和回表</p>
<p>  如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度就可以更快。</p>
<p>  实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。</p>
<ol start="6">
<li>MySQL集群是如何搭建的？读写分离是怎么做的？</li>
</ol>
<p>  MySQL主从结构原理：</p>
<p>  <img src="./Interview.assets/1623339952421.png" alt="1623339952421"></p>
<p>  MySQL通过将主节点的Binlog同步给从节点完成主从之间的数据同步。</p>
<p>  MySQL的主从集群只会讲Binlog从主节点同步到从节点，而不会反过来同步问题。</p>
<p>  因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。</p>
<p>   这种方式有丢失数据的风险，可以采用半同步的方式：</p>
<p>  <img src="./Interview.assets/1623339978966.png" alt="1623339978966"></p>
<ol start="7">
<li>谈谈如何对MySQL进行分库分表？多大数据量需要进行分库分表？分库分表的方式和分片策略由哪些？分库分表后，SQL语句执行流程是怎样的？</li>
</ol>
<p>  什么是分库分表：就是当表中的数据量过大时，整个查询效率就会降低的非常明显，这是为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。</p>
<p>  数据分片的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分到不同的表中，能够解决数据库数据文件过大的问题，但是不能从根本上解决查询问题。水平分片就是从数据角度将一个表中的数据拆分到不同的库或者表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。</p>
<p>  常见的分片策略有：</p>
<ul>
<li><p>  取余/取模：优点：均匀存放数据，缺点，扩容非常麻烦</p>
</li>
<li><p>按照范围分片：比较好扩容，数据分布不够均匀</p>
</li>
<li><p>按照时间分片：比较容易将热点数据区分出来</p>
</li>
<li><p>按照枚举值分片：例如按地区分片</p>
</li>
<li><p>按照目标字段前缀指定进行分区：自定义业务规则分片</p>
<p>建议：一个表的数据量超过500W或者数据文件超过2G，就要考虑分库分表了。</p>
<p>分库分表最常用的组件：MyCat、ShardingSphere</p>
<p>ShardingSphere分库分表的执行流程：</p>
<p><img src="./Interview.assets/1623340013484.png" alt="1623340013484"></p>
<p>与之相关的会衍生出一系列的问题，例如一个user表，按照userid进行了分片，然后我需要按照sex字段去查，这样怎么查？强制指定只查一个数据库，要怎么做？查询结果按照userid来排序，要怎么排？</p>
</li>
</ul>
<p> 分库分表也并不是完美的，在解决了一些问题的同时，也带来了一定的缺点：</p>
<ul>
<li>  事务一致性问题</li>
<li>跨节点关联查询问题</li>
<li>跨节点分页、排序函数</li>
<li>主键避重</li>
</ul>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ol>
<li><p>什么是倒排索引？有什么好处？</p>
<p> 索引：从id到内容。</p>
<p> 倒排索引：从内容到id。好处：比较适合做关键字检索。可以控制数据的总量。提高查询效率。</p>
<p> 搜索引擎为什么MySQL查询快？lucence是es的底层框架</p>
<p> 文章 -&gt; term -&gt;排序 term dictionary （这里类似新华字典 目录）-&gt; term index（a开头的拼音） -&gt; Posting List -&gt; 文章ID，[在文章中出现的偏移量]，权重（TFIDF）</p>
</li>
<li><p>ES了解多少？说说你们公司的ES集群架构。</p>
<p> 是一个基于Lucene框架（是一个非常高效的全文检索引擎框架）的搜索引擎产品，you know for search,提供了restful风格的操作接口。</p>
<p> ES包含了一些核心概念：</p>
<ul>
<li>索引 index：类似关系型数据库中的table</li>
</ul>
</li>
</ol>
<ul>
<li>文档 document：row<ul>
<li>字段 field text\keyword\byte：列</li>
</ul>
</li>
<li>映射Mapping：Schema<ul>
<li>查询方式：DSL（ES的新版本也支持SQL）</li>
</ul>
</li>
<li>分片sharding和副本replicas：index都是由sharding组成的。每个sharding都有一个或者多个备份。</li>
</ul>
<p>另外关于ES的使用场景：ES可以用在大数量的搜索场景下，另外ES也有很强大的计算能力，可以用在用户画像等场景。</p>
<ol start="3">
<li><p>如何进行中文分词？</p>
<p> IK分词器。HanLp中文分词器。</p>
</li>
<li><p>ES写入数据与查询数据的原理。</p>
<p> 写入数据的原理：</p>
<ol>
<li>客户端发写数据的请求是，可以发往任意节点，这个节点就会成为coordinating node 协调节点</li>
</ol>
</li>
<li><p>计算的点文档要写入的分片：计算时就采用hash取模的方式计算</p>
<ol start="3">
<li>协调节点就会进行路由，将请求转发给对应的primary sharding所在的datanode。</li>
</ol>
</li>
<li><p>datanode节点上的primary sharding处理请求，写入数据到索引库，并且将数据同步到对应的replica sharding</p>
<ol start="5">
<li>等promary sharding 和 replica sharding都保存好文档了之后，返回客户端响应</li>
</ol>
<p> <img src="./Interview.assets/1623340159941.png" alt="1623340159941"></p>
<p> 查询数据的原理：</p>
<ol>
<li>客户端发送请求可发给任意节点，这个节点就成为协调节点；</li>
<li>协调节点将查询请求广播到每一个数据节点，这些数据节点的分片就会处理该查询请求；</li>
<li>每个分片进行数据查询，将符合条件的数据放在一个队列当中，并将这些数据的文档ID、节点信息、分片信息都返回给协调节点；</li>
<li>由协调节点将所有的返回结果进行汇总，并排序；</li>
<li>协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据整合返回给客户端。</li>
</ol>
</li>
<li><p>ES部署时，要如何进行优化？</p>
<ol>
<li>集群部署优化</li>
<li>调整ES的一些重要参数。path.data尽量使用固态硬盘，定制JVM堆内存大小，ES的参数，实际上大部分情况下是不需要调优的，如果有性能问题，最好的办法是安排更合里的sharding布局并且增加节点数据。</li>
<li>更合理的sharding布局，让sharding对应的replica sharding尽量在同一个机房。</li>
<li>Linux服务器上一些优化策略，不要用root用户：修改虚拟内存大小，修改普通用户可以创建的最大线程数。</li>
</ol>
</li>
</ol>
<p> ES生态：ELK日志收集解决方案：filebeat -&gt; logstash -&gt; elaticsearch -&gt; kibana。</p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ol>
<li><p>什么是认证和授权？如何设计一个权限认证框架？</p>
<p>  认证：就是对系统访问者的身份进行确认（用户名密码登录、二维码登录、指纹、刷脸…）。</p>
<p> 授权：就是对系统访问者的行为进行控制，授权通常是在认证之后，对系统内的隐私数据进行保护，后台接口访问权限，前台控件的访问权限。</p>
<p> 通常情况下我们通过RBAC模型，也就是用户关联角色 ，而角色访问不同的资源，从而控制用户访问系统的行为。</p>
<p> 认证和授权也是对一个权限认证框架进行评估的两个主要的方面。</p>
</li>
<li><p>cookie和session有什么区别？如果没有Cookie、Seesion还能进行身份验证吗？</p>
<p> 当服务器tomcat第一次接收到客户端的请求时，会开辟一块独立的session空间，建立一个session对象，同时会生成session id，通过响应头的方式保存到客户端浏览器的cookie当中，以后客户端的每次请求，都会在请求头部带上这个session id，这样就可以对应上服务端的一些会话信息，比如用户的登录状态。</p>
<p>   如果没有客户端的cookie，session时无法进行身份验证的。</p>
<p>   当服务端从单体应用升级为分布式之后，cookie + session要如何扩展？</p>
<ul>
<li>session黏贴，在负载均衡中，通过某种机制，保证同一个客户端的所有请求都会转发到同一个tomcat实例当中。当这个tomcat实例出现问题之后，请求就会被转发到其他实例，这时候用户的session用户信息就丢失了。</li>
<li>session复制：当一个tomcat实例上保存了session信息后，主动将session复制到集群中的其他实例。问题：复制是需要时间的，在复制的过程中，容器产生session信息丢失。</li>
<li>session共享，就是将服务端的session信息保存到一个第三方中，比如Redis</li>
</ul>
</li>
<li><p>什么是CSRF攻击？如何防止？</p>
<p> CSRF：Cross Site Request Forgery 跨站请求伪造。</p>
<p> 一个正常的请求会将合法用户的session id保存到浏览器的cookie，这时候，如果用户在浏览器中打开另一个Tab页，那这个tab页也是可以获得浏览器的cookie，黑客就可以利用这个cookie信息进行攻击</p>
<p> 攻击过程：</p>
<ol>
<li><p>某银行网站A可以以GET请求的方式发起转账操作。<a href="http://www.xxx.com/transfor.do?accountNum=100&amp;money=1000">www.xxx.com/transfor.do?accountNum=100&amp;money=1000</a> accountNum表示目标账户，这个请求肯定是需要登录才可以正常访问的，</p>
</li>
<li><p>攻击者在某个论坛或者网站上上传一个图片，链接地址是<a href="http://www.xxx.com/transfor.do?accountNum=100&amp;money=1000%EF%BC%8C%E5%85%B6%E4%B8%ADaccountNum%E5%B0%B1%E6%98%AF%E6%94%BB%E5%87%BB%E8%80%85%E8%87%AA%E5%B7%B1%E7%9A%84%E9%93%B6%E8%A1%8C%E8%B4%A6%E6%88%B7%E3%80%82">www.xxx.com/transfor.do?accountNum=100&amp;money=1000，其中accountNum就是攻击者自己的银行账户。</a></p>
</li>
<li><p>如果有一个用户，登录了银行网站，然后又打开浏览器的另一个Tab页，点击了这个图片，这时，银行就会受理到一个带了正确的cookie的请求，就会完成转账，用户的钱就被盗了。</p>
</li>
</ol>
<p>  防止CSRF的方式：</p>
<ol>
<li><p>尽量使用POST请求，限制GET请求，POST请求可以带请求体，攻击者就不容易伪造出请求。</p>
</li>
<li><p>将cookie设置为HttpOnly：response.setHeader(“Set-Cookie”,”cookiename=cookievalue;HttpOnly”)。</p>
</li>
<li><p>增加token：在请求中放入一个攻击者无法伪造的信息，并且该信息不存在于cookie当中。</p>
</li>
<li><p>增加一个额外的隐藏信息<code>&lt;input type=&#39;hidden&#39; value=&#39;demo&#39;&gt;</code>这也是Spring Security框架中采用的防范方式。</p>
</li>
</ol>
</li>
<li><p>什么是OAuth2？有哪几种认证方式？什么是JWT令牌？和普通令牌有什么区别？</p>
</li>
</ol>
<p>OAuth2.0是一个开放标准，允许用户授权在第三方应用程序访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用分享他们数据的所有内容。</p>
<p>OAuth2.0的协议认证流程，简单理解，就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保。</p>
<p>OAuth2.0协议有四种模式：</p>
<p>授权码模式：</p>
<p><img src="./Interview.assets/1623340322241.png" alt="1623340322241"></p>
<p>简化模式：</p>
<p><img src="./Interview.assets/1623340341140.png" alt="1623340341140"></p>
<p>密码模式：</p>
<p><img src="./Interview.assets/1623340368298.png" alt="1623340368298"></p>
<p>客户端模式：</p>
<p><img src="./Interview.assets/1623340385478.png" alt="1623340385478"></p>
<p>在梳理OAuth2.0协议流程的过程中，其实有一个主线，就是三方参与者的信任程度。</p>
<p>普通令牌只是一个普通的字符串，没有特殊的意义，这就意味着，当客户端带上令牌去访问应用的接口时，应用本身无法判断这个令牌是否正确，他就需要到授权服务器上去拍段令牌是否有效，在高并发的场景下，检查令牌的网络请求就有可能成为一个性能瓶颈。</p>
<p>改良的方式就是JWT令牌，将令牌对应的相关信息全部冗余到令牌本身，这样资源服务器就不再需要发送求请给授权服务器去检查令牌了，他自己就可以读取到令牌的授权信息。JWT令牌的本质就是一个加密的字符串。</p>
<ol>
<li>什么是SSO？与OAuth2.0有什么关系？</li>
</ol>
<p>  OAuth2.0的使用场景通常称为联合登录，一处注册，多处使用。</p>
<p>  SSO：Single Sign ON：一处登录，多处同时登录。</p>
<p>  SSO的实现关键是将Seesion信息几种存储，通常使用Spring Security实现</p>
<ol start="2">
<li>如何设计一个开放授权平台？</li>
</ol>
<p>  开发授权平台页可以按照认证和授权两个方向来梳理。</p>
<ol>
<li><p>认证：就可以按照OAuth2.0协议来规划认证的过程</p>
</li>
<li><p>授权，首先需要待接入的第三方应用在开放授权平台进行注册，注册需要提供几个必要的信息：clintID，消息推送地址（一堆公私钥），私钥由授权平台自己保存，公钥分发给第三方应用。然后，第三方应用引导可户发起请求时，采用公钥进行参数加密，然后授权开放平台使用对应的私钥解密。接下来，授权开放平台同步响应第三方应用的只是消息是否处理成功的结果，而真正的业务数据由授权开放平台异步推送给第三方应用预留的推送地址。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出Redis</title>
    <url>/2021/04/07/Redis/</url>
    <content><![CDATA[<p>==Redis==</p>
<span id="more"></span>
<h2 id="一、Nosql概述"><a href="#一、Nosql概述" class="headerlink" title="一、Nosql概述"></a>一、Nosql概述</h2><h3 id="为什么使用Nosql"><a href="#为什么使用Nosql" class="headerlink" title="为什么使用Nosql"></a>为什么使用Nosql</h3><blockquote>
<p>1、单机Mysql时代</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020082010365930.png#pic_center" alt="在这里插入图片描述"></p>
<p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p>
<ol>
<li>数据量增加到一定程度，单机数据库就放不下了</li>
<li>数据的索引（B+ Tree）,一个机器内存也存放不下</li>
<li>访问量变大后（读写混合），一台服务器承受不住。</li>
</ol>
<blockquote>
<p>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</p>
</blockquote>
<p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p>
<p><img src="https://img-blog.csdnimg.cn/20200820103713734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>优化过程经历了以下几个过程：</p>
<ol>
<li>优化数据库的数据结构和索引(难度大)</li>
<li>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</li>
<li>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</li>
</ol>
<blockquote>
<p>3、分库分表 + 水平拆分 + Mysql集群</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200820103739584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>4、如今最近的年代</p>
</blockquote>
<p> 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p>
<blockquote>
<p>目前一个基本的互联网项目</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200820103804572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>为什么要用NoSQL ？</p>
</blockquote>
<p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！<br>这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p>
<h3 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h3><p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p>
<p>Not Only Structured Query Language</p>
<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>
<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>
<p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p>
<h3 id="Nosql特点"><a href="#Nosql特点" class="headerlink" title="Nosql特点"></a>Nosql特点</h3><ol>
<li><p>方便扩展（数据之间没有关系，很好扩展！）</p>
</li>
<li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p>
</li>
<li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p>
</li>
<li><p>传统的 RDBMS 和 NoSQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统的 RDBMS(关系型数据库)</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Nosql</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE</span><br><span class="line">- 高性能，高可用，高扩展</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>了解：3V + 3高</p>
</blockquote>
<p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p>
<ol>
<li>海量Velume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ol>
<p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p>
<ol>
<li>高并发</li>
<li>高可扩</li>
<li>高性能</li>
</ol>
<p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p>
<h3 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h3><p>推荐阅读：阿里云的这群疯子<a href="https://yq.aliyun.com/articles/653511">https://yq.aliyun.com/articles/653511</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200820103829446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="1"></p>
<p><img src="https://img-blog.csdnimg.cn/20200820103851613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 商品信息</span></span><br><span class="line">- 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品描述、评论(文字居多)</span></span><br><span class="line">- 文档型数据库：MongoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片</span></span><br><span class="line">- 分布式文件系统 FastDFS</span><br><span class="line">- 淘宝：TFS</span><br><span class="line">- Google: GFS</span><br><span class="line">- Hadoop: HDFS</span><br><span class="line">- 阿里云: oss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品关键字 用于搜索</span></span><br><span class="line">- 搜索引擎：solr,elasticsearch</span><br><span class="line">- 阿里：Isearch 多隆</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品热门的波段信息</span></span><br><span class="line">- 内存数据库：Redis，Memcache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品交易，外部支付接口</span></span><br><span class="line">- 第三方应用</span><br></pre></td></tr></table></figure>

<h3 id="Nosql的四大分类"><a href="#Nosql的四大分类" class="headerlink" title="Nosql的四大分类"></a>Nosql的四大分类</h3><blockquote>
<p><strong>KV键值对</strong></p>
</blockquote>
<ul>
<li>新浪：<strong>Redis</strong></li>
<li>美团：Redis + Tair</li>
<li>阿里、百度：Redis + Memcache</li>
</ul>
<blockquote>
<p><strong>文档型数据库（bson数据格式）：</strong></p>
</blockquote>
<ul>
<li><strong>MongoDB</strong>(掌握)<ul>
<li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li>
<li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li>
</ul>
</li>
<li>ConthDB</li>
</ul>
<blockquote>
<p><strong>列存储数据库</strong></p>
</blockquote>
<ul>
<li><strong>HBase</strong>(大数据必学)</li>
<li>分布式文件系统</li>
</ul>
<blockquote>
<p><strong>图关系数据库</strong></p>
</blockquote>
<p>用于广告推荐，社交网络</p>
<ul>
<li><strong>Neo4j</strong>、InfoGrid</li>
</ul>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>Examples举例</strong></th>
<th><strong>典型应用场景</strong></th>
<th><strong>数据模型</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>键值对（key-value）</strong></td>
<td>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td>
<td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td>
<td>Key 指向 Value 的键值对，通常用hash table来实现</td>
<td>查找速度快</td>
<td>数据无结构化，通常只被当作字符串或者二进制数据</td>
</tr>
<tr>
<td><strong>列存储数据库</strong></td>
<td>Cassandra, HBase, Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td><strong>文档型数据库</strong></td>
<td>CouchDB, MongoDb</td>
<td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td>
<td>Key-Value对应的键值对，Value为结构化数据</td>
<td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td>查询性能不高，而且缺乏统一的查询语法。</td>
</tr>
<tr>
<td><strong>图形(Graph)数据库</strong></td>
<td>Neo4J, InfoGrid, Infinite Graph</td>
<td>社交网络，推荐系统等。专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群</td>
</tr>
</tbody></table>
<h2 id="二、Redis入门"><a href="#二、Redis入门" class="headerlink" title="二、Redis入门"></a>二、Redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Redis是什么？</p>
</blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务。</p>
<p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p>
<p>与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<blockquote>
<p>Redis能该干什么？</p>
</blockquote>
<ol>
<li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li>
<li>高效率、用于高速缓冲</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器(eg：浏览量)</li>
<li>。。。</li>
</ol>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li><p>多样的数据类型</p>
</li>
<li><p>持久化</p>
</li>
<li><p>集群</p>
</li>
<li><p>事务</p>
<p>…</p>
</li>
</ol>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官网：<a href="https://redis.io/">https://redis.io/</a></p>
<p>推荐使用Linux服务器学习。</p>
<p>windows版本的Redis已经停更很久了…</p>
<h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p><a href="https://github.com/dmajkic/redis">https://github.com/dmajkic/redis</a></p>
<ol>
<li>解压安装包<br><img src="https://img-blog.csdnimg.cn/20200820103922318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>开启redis-server.exe</li>
<li>启动redis-cli.exe测试<img src="https://img-blog.csdnimg.cn/20200820103950934.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><ol>
<li><p>下载安装包！<code>redis-5.0.8.tar.gz</code></p>
</li>
<li><p>解压Redis的安装包！程序一般放在 <code>/opt</code> 目录下</p>
<p><img src="https://img-blog.csdnimg.cn/20200820104016426.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>基本环境安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"><span class="comment"># 然后进入redis目录下执行</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 然后执行</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200820104048327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p>redis默认安装路径 <code>/usr/local/bin</code><img src="https://img-blog.csdnimg.cn/20200820104140692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>将redis的配置文件复制到 程序安装目录 <code>/usr/local/bin/kconfig</code>下</p>
<p><img src="https://img-blog.csdnimg.cn/20200820104157817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hxvGQ47d-1597890996509)(狂神说 Redis.assets/image-20200813114000868.png)]"></p>
</li>
<li><p>redis默认不是后台启动的，需要修改配置文件！</p>
<p><img src="https://img-blog.csdnimg.cn/20200820104213706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dDdKTUgd-1597890996510)(狂神说 Redis.assets/image-20200813114019063.png)]"></p>
</li>
<li><p>通过制定的配置文件启动redis服务</p>
<p><img src="https://img-blog.csdnimg.cn/20200820104228556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jOypL57Z-1597890996511)(狂神说 Redis.assets/image-20200813114030597.png)]"></p>
</li>
<li><p>使用redis-cli连接指定的端口号测试，Redis的默认端口6379</p>
<p><img src="https://img-blog.csdnimg.cn/20200820104243223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LnDaISQ4-1597890996512)(狂神说 Redis.assets/image-20200813114045299.png)]"></p>
</li>
<li><p>查看redis进程是否开启</p>
<p><img src="https://img-blog.csdnimg.cn/20200820104300532.png#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PhN1jC1-1597890996513)(狂神说 Redis.assets/image-20200813114103769.png)]"></p>
</li>
<li><p>关闭Redis服务 <code>shutdown</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200820104314297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Y54EuOYm-1597890996514)(狂神说 Redis.assets/image-20200813114116691.png)]"></p>
</li>
<li><p>再次查看进程是否存在</p>
</li>
<li><p>后面我们会使用单机多Redis启动集群测试</p>
</li>
</ol>
<h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><p><strong>redis-benchmark：</strong>Redis官方提供的性能测试工具，参数选项如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214125892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>简单测试：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试：100个并发连接 100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200820104343472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-plMshjFg-1597890996515)(狂神说 Redis.assets/image-20200813114143365.png)]"></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote>
<p>redis默认有16个数据库</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200820104357466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-v2S3n3Si-1597890996516)(狂神说 Redis.assets/image-20200813114158322.png)]"></p>
<p>默认使用的第0个;</p>
<p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases <span class="comment"># 命令行查看数据库数量databases</span></span><br><span class="line">1) <span class="string">&quot;databases&quot;</span></span><br><span class="line">2) <span class="string">&quot;16&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; select 8 <span class="comment"># 切换数据库 DB 8</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize <span class="comment"># 查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SELECT 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name <span class="comment"># db8中并不能获取db0中的键值对。</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; SELECT 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">3) <span class="string">&quot;name&quot;</span></span><br><span class="line">4) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;myset:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DBSIZE <span class="comment"># size和key个数相关</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>

<p><code>keys *</code> ：查看当前数据库中所有的key。</p>
<p><code>flushdb</code>：清空当前数据库中的键值对。</p>
<p><code>flushall</code>：清空所有数据库的键值对。</p>
<blockquote>
<p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p>
</blockquote>
<p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p>
<p>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</p>
<blockquote>
<p><strong>Redis为什么单线程还这么快？</strong></p>
</blockquote>
<ul>
<li>误区1：高性能的服务器一定是多线程的？</li>
<li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li>
</ul>
<p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p>
<h2 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h2><p> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库</strong>，<strong>高速缓存</strong>和<strong>消息队列代理</strong>。它支持<a href="https://www.redis.net.cn/tutorial/3508.html">字符串</a>、<a href="https://www.redis.net.cn/tutorial/3509.html">哈希表</a>、<a href="https://www.redis.net.cn/tutorial/3510.html">列表</a>、<a href="https://www.redis.net.cn/tutorial/3511.html">集合</a>、<a href="https://www.redis.net.cn/tutorial/3512.html">有序集合</a>，<a href="https://www.redis.net.cn/tutorial/3508.html">位图</a>，<a href="https://www.redis.net.cn/tutorial/3513.html">hyperloglogs</a>等数据类型。内置复制、<a href="https://www.redis.net.cn/tutorial/3516.html">Lua脚本</a>、LRU收回、<a href="https://www.redis.net.cn/tutorial/3515.html">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a href="https://www.redis.net.cn/tutorial/3524.html">分区</a>。</p>
<h3 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h3><blockquote>
<p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p>
</blockquote>
<p>下面学习的命令：</p>
<ul>
<li><code>exists key</code>：判断键是否存在</li>
<li><code>del key</code>：删除键值对</li>
<li><code>move key db</code>：将键值对移动到指定数据库</li>
<li><code>expire key second</code>：设置键值对的过期时间</li>
<li><code>type key</code>：查看value的数据类型</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看当前数据库所有key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name qinjiang <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; move age 1 <span class="comment"># 将键值对移动到指定数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age <span class="comment"># 判断键是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; del age <span class="comment"># 删除键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 删除个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 <span class="comment"># 设置键值对的过期时间</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 设置成功 开始计数</span></span><br><span class="line">127.0.0.1:6379&gt; ttl age <span class="comment"># 查看key的过期剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2 <span class="comment"># -2 表示key过期，-1表示key未设置过期时间</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get age <span class="comment"># 过期的key 会被自动delete</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name <span class="comment"># 查看value的数据类型</span></span><br><span class="line">string</span><br></pre></td></tr></table></figure>

<p>关于<code>TTL</code>命令</p>
<p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p>
<ol>
<li>当前key没有设置过期时间，所以会返回-1.</li>
<li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li>
<li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li>
</ol>
<p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p>
<ul>
<li><code>RENAME key newkey</code>修改 key 的名称</li>
<li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li>
</ul>
<p>更多命令学习：<a href="https://www.redis.net.cn/order/">https://www.redis.net.cn/order/</a></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)]</p>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><p>普通的set、get直接略过。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>APPEND key value</code></td>
<td>向指定的key的value后追加字符串</td>
<td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td>
</tr>
<tr>
<td><code>DECR/INCR key</code></td>
<td>将指定key的value数值进行+1/-1(仅对于数字)</td>
<td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td>
</tr>
<tr>
<td><code>INCRBY/DECRBY key n</code></td>
<td>按指定的步长对数值进行加减</td>
<td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td>
</tr>
<tr>
<td><code>INCRBYFLOAT key n</code></td>
<td>为数值加上浮点型数值</td>
<td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td>
</tr>
<tr>
<td><code>STRLEN key</code></td>
<td>获取key保存值的字符串长度</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td>
</tr>
<tr>
<td><code>GETRANGE key start end</code></td>
<td>按起止位置获取字符串（闭区间，起止位置都取）</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td>
</tr>
<tr>
<td><code>SETRANGE key offset value</code></td>
<td>用指定的value 替换key中 offset开始的值</td>
<td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td>
</tr>
<tr>
<td><code>GETSET key value</code></td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
<td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td>
</tr>
<tr>
<td><code>SETNX key value</code></td>
<td>仅当key不存在时进行set</td>
<td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td>
</tr>
<tr>
<td><code>SETEX key seconds value</code></td>
<td>set 键值对并设置过期时间</td>
<td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td>
</tr>
<tr>
<td><code>MSET key1 value1 [key2 value2..]</code></td>
<td>批量set键值对</td>
<td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td>
</tr>
<tr>
<td><code>MSETNX key1 value1 [key2 value2..]</code></td>
<td>批量设置键值对，仅当参数中所有的key都不存在时执行</td>
<td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td>
</tr>
<tr>
<td><code>MGET key1 [key2..]</code></td>
<td>批量获取多个key保存的值</td>
<td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td>
</tr>
<tr>
<td><code>PSETEX key milliseconds value</code></td>
<td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td>
<td></td>
</tr>
<tr>
<td><code>getset key value</code></td>
<td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td>
<td></td>
</tr>
</tbody></table>
<p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量：uid:123666：follow 0</li>
<li>粉丝数</li>
<li>对象存储缓存</li>
</ul>
<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><blockquote>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
</blockquote>
<p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等</p>
<p><img src="https://img-blog.csdnimg.cn/20200820104440398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RERERlbmdf,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VPvbIltc-1597890996518)(狂神说 Redis.assets/image-20200813114255459.png)]"></p>
<p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LPUSH/RPUSH key value1[value2..]</code></td>
<td>从左边/右边向列表中PUSH值(一个或者多个)。</td>
</tr>
<tr>
<td><code>LRANGE key start end</code></td>
<td>获取list 起止元素==（索引从左往右 递增）==</td>
</tr>
<tr>
<td><code>LPUSHX/RPUSHX key value</code></td>
<td>向已存在的列名中push值（一个或者多个）</td>
</tr>
<tr>
<td>`LINSERT key BEFORE</td>
<td>AFTER pivot value`</td>
</tr>
<tr>
<td><code>LLEN key</code></td>
<td>查看列表长度</td>
</tr>
<tr>
<td><code>LINDEX key index</code></td>
<td>通过索引获取列表元素</td>
</tr>
<tr>
<td><code>LSET key index value</code></td>
<td>通过索引为元素设值</td>
</tr>
<tr>
<td><code>LPOP/RPOP key</code></td>
<td>从最左边/最右边移除值 并返回</td>
</tr>
<tr>
<td><code>RPOPLPUSH source destination</code></td>
<td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td>
</tr>
<tr>
<td><code>LTRIM key start end</code></td>
<td>通过下标截取指定范围内的列表</td>
</tr>
<tr>
<td><code>LREM key count value</code></td>
<td>List中是允许value重复的 <code>count &gt; 0</code>：从头部开始搜索 然后删除指定的value 至多删除count个 <code>count &lt; 0</code>：从尾部开始搜索… <code>count = 0</code>：删除列表中所有的指定value。</td>
</tr>
<tr>
<td><code>BLPOP/BRPOP key1[key2] timout</code></td>
<td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td><code>BRPOPLPUSH source destination timeout</code></td>
<td>和<code>RPOPLPUSH</code>功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 <span class="comment"># LPUSH mylist=&gt;&#123;1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 <span class="comment"># LPUSH mylist=&gt;&#123;2,1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 <span class="comment"># RPUSH mylist=&gt;&#123;2,1,3&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist <span class="comment"># 普通的get是无法获取list值的</span></span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 <span class="comment"># LRANGE 获取起止位置范围内的元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 <span class="comment"># 获取全部元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 <span class="comment"># list不存在 LPUSHX失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2  </span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 <span class="comment"># 向mylist中 左边 PUSH k4 k5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 <span class="comment"># 在k2元素后 插入ins_key1</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist <span class="comment"># 查看mylist的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 <span class="comment"># 获取下标为3的元素</span></span><br><span class="line"><span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 <span class="comment"># 将下标3的元素 set值为k6</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k6&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist <span class="comment"># 左侧(头部)弹出</span></span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist <span class="comment"># 右侧(尾部)弹出</span></span><br><span class="line"><span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist <span class="comment"># 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span></span><br><span class="line"><span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 <span class="comment"># 截取mylist中的 0~1部分</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 <span class="comment"># 从头部开始搜索 至多删除3个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 <span class="comment">#从尾部开始搜索 至多删除2个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line"></span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 <span class="comment"># 从newlist中弹出第一个值，mylist作为候选</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span> <span class="comment"># 弹出</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span> <span class="comment"># 由于newlist空了 从mylist中弹出</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) <span class="comment"># 超时了</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 <span class="comment"># 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span></span><br><span class="line">2) <span class="string">&quot;test&quot;</span></span><br><span class="line">(12.54s)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>list实际上是一个链表，before Node after , left, right 都可以插入值</li>
<li><strong>如果key不存在，则创建新的链表</strong></li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li>
</ul>
<p><strong>应用：</strong></p>
<p><strong>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</strong></p>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><blockquote>
<p>Redis的Set是<strong>string类型</strong>的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD key member1[member2..]</code></td>
<td>向集合中无序增加一个/多个成员</td>
</tr>
<tr>
<td><code>SCARD key</code></td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td><code>SMEMBERS key</code></td>
<td>返回集合中所有的成员</td>
</tr>
<tr>
<td><code>SISMEMBER key member</code></td>
<td>查询member元素是否是集合的成员,结果是无序的</td>
</tr>
<tr>
<td><code>SRANDMEMBER key [count]</code></td>
<td>随机返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><code>SPOP key [count]</code></td>
<td>随机移除并返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><code>SMOVE source destination member</code></td>
<td>将source集合的成员member移动到destination集合</td>
</tr>
<tr>
<td><code>SREM key member1[member2..]</code></td>
<td>移除集合中一个/多个成员</td>
</tr>
<tr>
<td><code>SDIFF key1[key2..]</code></td>
<td>返回所有集合的差集 key1- key2 - …</td>
</tr>
<tr>
<td><code>SDIFFSTORE destination key1[key2..]</code></td>
<td>在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！</td>
</tr>
<tr>
<td><code>SINTER key1 [key2..]</code></td>
<td>返回所有集合的交集</td>
</tr>
<tr>
<td><code>SINTERSTORE destination key1[key2..]</code></td>
<td>在SINTER的基础上，存储结果到集合中。覆盖</td>
</tr>
<tr>
<td><code>SUNION key1 [key2..]</code></td>
<td>返回所有集合的并集</td>
</tr>
<tr>
<td><code>SUNIONSTORE destination key1 [key2..]</code></td>
<td>在SUNION的基础上，存储结果到及和张。覆盖</td>
</tr>
<tr>
<td><code>SSCAN KEY [MATCH pattern] [COUNT count]</code></td>
<td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 <span class="comment"># 向myset中增加成员 m1~m4</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset <span class="comment"># 获取集合的成员数目</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset <span class="comment"># 获取集合中所有成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 <span class="comment"># 查询m5是否是myset的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不是，返回0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 是，返回1</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 <span class="comment"># 随机返回3个成员</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机返回1个成员</span></span><br><span class="line"><span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 <span class="comment"># 随机移除并返回2个成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m4&quot;</span></span><br><span class="line"><span class="comment"># 将set还原到&#123;m1,m2,m3,m4&#125;</span></span><br><span class="line"></span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 <span class="comment"># 将myset中m3成员移动到newset集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m2&quot;</span></span><br><span class="line">3) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">1) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 <span class="comment"># 从newset中移除m3元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span></span><br><span class="line"><span class="comment"># setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;</span></span><br><span class="line"></span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz <span class="comment"># 等价于setx-sety-setz</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety <span class="comment"># setx - sety</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx <span class="comment"># sety - setx</span></span><br><span class="line">1) <span class="string">&quot;m5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line"><span class="comment"># 共同关注（交集）</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz <span class="comment"># 求 setx、sety、setx的交集</span></span><br><span class="line">1) <span class="string">&quot;m6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety <span class="comment"># 求setx sety的交集</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz <span class="comment"># setx sety setz的并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m3&quot;</span></span><br><span class="line">4) <span class="string">&quot;m2&quot;</span></span><br><span class="line">5) <span class="string">&quot;m1&quot;</span></span><br><span class="line">6) <span class="string">&quot;m5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety <span class="comment"># setx sety 并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">5) <span class="string">&quot;m5&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><blockquote>
<p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HSET key field value</code></td>
<td>将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</td>
</tr>
<tr>
<td><code>HMSET key field1 value1 [field2 value2..]</code></td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td><code>HSETNX key field value</code></td>
<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td><code>HEXISTS key field</code></td>
<td>查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td><code>HGET key field value</code></td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td><code>HMGET key field1 [field2..]</code></td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td><code>HGETALL key</code></td>
<td>获取在哈希表key 的所有字段和值</td>
</tr>
<tr>
<td><code>HKEYS key</code></td>
<td>获取哈希表key中所有的字段</td>
</tr>
<tr>
<td><code>HLEN key</code></td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td><code>HVALS key</code></td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td><code>HDEL key field1 [field2..]</code></td>
<td>删除哈希表key中一个/多个field字段</td>
</tr>
<tr>
<td><code>HINCRBY key field n</code></td>
<td>为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</td>
</tr>
<tr>
<td><code>HINCRBYFLOAT key field n</code></td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 n。</td>
</tr>
<tr>
<td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td>
<td>迭代哈希表中的键值对。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura <span class="comment"># 将studentx哈希表作为一个对象，设置name为sakura</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc <span class="comment"># 重复设置field进行覆盖，并返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 <span class="comment"># 设置studentx的age为20</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 <span class="comment"># 设置sex为1，tel为15623667886</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc <span class="comment"># HSETNX 设置已存在的field</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name <span class="comment"># name字段在studentx中是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line"></span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name <span class="comment"># 获取studentx中name字段的value</span></span><br><span class="line"><span class="string">&quot;gyc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel <span class="comment"># 获取studentx中name、age、tel字段的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx <span class="comment"># 获取studentx中所有的field及其value</span></span><br><span class="line"> 1) <span class="string">&quot;name&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;gyc&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;age&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;20&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;sex&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;1&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;tel&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;email&quot;</span></span><br><span class="line">10) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx <span class="comment"># 查看studentx中所有的field</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;sex&quot;</span></span><br><span class="line">4) <span class="string">&quot;tel&quot;</span></span><br><span class="line">5) <span class="string">&quot;email&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx <span class="comment"># 查看studentx中的字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx <span class="comment"># 查看studentx中所有的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;1&quot;</span></span><br><span class="line">4) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">5) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel <span class="comment"># 删除studentx 中的sex、tel字段</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;email&quot;</span></span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 <span class="comment"># studentx的age字段数值+1</span></span><br><span class="line">(<span class="built_in">integer</span>) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 <span class="comment"># 非整数字型字段不可用</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 <span class="comment"># weight字段增加0.6</span></span><br><span class="line"><span class="string">&quot;90.8&quot;</span></span><br></pre></td></tr></table></figure>

<p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！<strong>Hash更适合于对象的存储，Sring更加适合字符串存储！</strong></p>
<h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><blockquote>
<p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>score相同：按字典顺序排序</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member1 [score2 member2]</code></td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td><code>ZCOUNT key min max</code></td>
<td>计算在有序集合中指定区间score的成员数</td>
</tr>
<tr>
<td><code>ZINCRBY key n member</code></td>
<td>有序集合中对指定成员的分数加上增量 n</td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td><code>ZRANGE key start end</code></td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td><code>ZRANGEBYLEX key min max</code></td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max</code></td>
<td>通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()==</td>
</tr>
<tr>
<td><code>ZLEXCOUNT key min max</code></td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td><code>ZREM key member1 [member2..]</code></td>
<td>移除有序集合中一个/多个成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYLEX key min max</code></td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYRANK key start stop</code></td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td><code>ZREMRANGEBYSCORE key min max</code></td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td><code>ZREVRANGE key start end</code></td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td><code>ZREVRANGEBYSCORRE key max min</code></td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td><code>ZREVRANGEBYLEX key max min</code></td>
<td>返回有序集中指定字典区间内的成员，按字典顺序倒序</td>
</tr>
<tr>
<td><code>ZREVRANK key member</code></td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code></td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</td>
</tr>
<tr>
<td><code>ZUNIONSTORE destination numkeys key1 [key2..]</code></td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code></td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 <span class="comment"># 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset <span class="comment"># 获取有序集合的成员数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 <span class="comment"># 获取score在 [0,1]区间的成员数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 <span class="comment"># 将成员m2的score +5</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 <span class="comment"># 获取成员m1的score</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line"></span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 <span class="comment"># 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 <span class="comment"># 获取索引在 0~1的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 <span class="comment"># 获取全部成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span></span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + <span class="comment"># 返回所有成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">5) <span class="string">&quot;back&quot;</span></span><br><span class="line">6) <span class="string">&quot;java&quot;</span></span><br><span class="line">7) <span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 <span class="comment"># 分页 按索引显示查询结果的 0,1,2条记录</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 <span class="comment"># 显示 3,4,5条记录</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple <span class="comment"># 显示 (-,apple] 区间内的成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java <span class="comment"># 显示 [apple,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 <span class="comment"># 返回score在 [1,10]之间的的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc <span class="comment"># 移除成员abc</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java <span class="comment"># 移除字典区间[apple,java]中的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 <span class="comment"># 移除排名0~1的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 <span class="comment"># 移除score在 [0,3]的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span></span><br><span class="line"><span class="comment"># myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span></span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 <span class="comment"># 按score递减排序，然后按索引，返回结果的 0~3</span></span><br><span class="line">1) <span class="string">&quot;m9&quot;</span></span><br><span class="line">2) <span class="string">&quot;m7&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">4) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 <span class="comment"># 返回排序结果的 索引的2~4</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 <span class="comment"># 按score递减顺序 返回集合中分数在[2,6]之间的成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add <span class="comment"># 按字典倒序 返回集合中(add,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;java&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;apple&quot;</span></span><br><span class="line">4) <span class="string">&quot;amaze&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 <span class="comment"># 按score递减顺序，返回成员m7索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span></span><br><span class="line"><span class="comment"># enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span></span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore <span class="comment"># 将mathscore enscore进行合并 结果存放到sumscore</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores <span class="comment"># 合并后的score是之前集合中所有score的和</span></span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;160&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;177&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;188&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN <span class="comment"># 取两个集合的成员score最小值作为结果的</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;70&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;87&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;93&quot;</span></span><br></pre></td></tr></table></figure>

<p>应用案例：</p>
<ul>
<li>set排序 存储班级成绩表 工资表排序！</li>
<li>普通消息，1.重要消息 2.带权重进行判断</li>
<li>排行榜应用实现，取Top N测试</li>
</ul>
<h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><blockquote>
<p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td>
<td>将具体经纬度的坐标存入一个有序集合</td>
</tr>
<tr>
<td><code>geopos key member [member..]</code></td>
<td>获取集合中的一个/多个成员坐标</td>
</tr>
<tr>
<td><code>geodist key member1 member2 [unit]</code></td>
<td>返回两个给定位置之间的距离。默认以米作为单位。</td>
</tr>
<tr>
<td>`georadius key longitude latitude radius m</td>
<td>km</td>
</tr>
<tr>
<td><code>GEORADIUSBYMEMBER key member radius...</code></td>
<td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td>
</tr>
<tr>
<td><code>geohash key member1 [member2..]</code></td>
<td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td>
</tr>
</tbody></table>
<p><strong>有效经纬度</strong></p>
<blockquote>
<ul>
<li>有效的经度从-180度到180度。</li>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
</blockquote>
<p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<p><strong>关于GEORADIUS的参数</strong></p>
<blockquote>
<p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p>
<p>withcoord:带上坐标</p>
<p>withdist:带上距离，单位与半径单位相同</p>
<p>COUNT n : 只显示前n个(按距离递增排序)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----------------georadius---------------------</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist <span class="comment"># 查询经纬度(120,30)坐标500km半径内的成员</span></span><br><span class="line">1) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.4151&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;120.20000249147415&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.199999888333501&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">   2) <span class="string">&quot;205.3611&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;121.40000134706497&quot;</span></span><br><span class="line">      2) <span class="string">&quot;31.400000253193539&quot;</span></span><br><span class="line">     </span><br><span class="line">------------geohash---------------------------</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city yichang shanghai <span class="comment"># 获取成员经纬坐标的geohash表示</span></span><br><span class="line">1) <span class="string">&quot;wmrjwbr5250&quot;</span></span><br><span class="line">2) <span class="string">&quot;wtw6ds0y300&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><blockquote>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p>
<p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>其底层使用string数据类型</p>
</blockquote>
<p><strong>什么是基数？</strong></p>
<blockquote>
<p>数据集中不重复的元素的个数。</p>
</blockquote>
<p><strong>应用场景：</strong></p>
<p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p>
<blockquote>
<p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PFADD key element1 [elememt2..]</code></td>
<td>添加指定元素到 HyperLogLog 中</td>
</tr>
<tr>
<td><code>PFCOUNT key [key]</code></td>
<td>返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k <span class="comment"># 添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myelemx <span class="comment"># hyperloglog底层使用String</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemx <span class="comment"># 估算myelemx的基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemy</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy <span class="comment"># 合并myelemx和myelemy 成为myelemz</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemz <span class="comment"># 估算基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 17</span><br></pre></td></tr></table></figure>

<p>如果允许容错，那么一定可以使用Hyperloglog !</p>
<p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p>
<h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><blockquote>
<p>使用位存储，信息状态只有 0 和 1</p>
<p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
</blockquote>
<p><strong>应用场景</strong></p>
<p>签到统计、状态统计</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>setbit key offset value</code></td>
<td>为指定key的offset位设置值</td>
</tr>
<tr>
<td><code>getbit key offset</code></td>
<td>获取offset位的值</td>
</tr>
<tr>
<td><code>bitcount key [start end]</code></td>
<td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td>
</tr>
<tr>
<td><code>bitop operration destkey key[key..]</code></td>
<td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td>
</tr>
<tr>
<td><code>BITPOS key bit [start] [end]</code></td>
<td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1 <span class="comment"># 设置sign的第0位为 1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1 <span class="comment"># 设置sign的第2位为 1  不设置默认 是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2 <span class="comment"># 获取第2位的数值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4 <span class="comment"># 未设置默认是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign <span class="comment"># 统计sign中为1的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>

<p><strong>bitmaps的底层</strong></p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\我\MyBlog\狂神说 Redis.assets\image-20200803234336175.png)]</p>
<p>这样设置以后你能get到的值是：<strong>\xA2\x80</strong>，所以bitmaps是一串从左到右的二进制串</p>
<h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p>
<blockquote>
<p>Redis事务本质：一组命令的集合。</p>
<p>—————– 队列 set set set 执行 ——————-</p>
<p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p>
<ul>
<li>一次性</li>
<li>顺序性</li>
<li>排他性</li>
</ul>
<hr>
<ol>
<li>Redis事务没有隔离级别的概念</li>
<li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li>
</ol>
</blockquote>
<h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ul>
<li>开启事务（<code>multi</code>）</li>
<li>命令入队</li>
<li>执行事务（<code>exec</code>）</li>
</ul>
<p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1 <span class="comment"># 命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2 <span class="comment"># ..</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 事务执行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br><span class="line">4) OK</span><br><span class="line">5) 1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">   2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">   3) <span class="string">&quot;k1&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>取消事务(<code>discurd</code>)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD <span class="comment"># 放弃事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXEC </span><br><span class="line">(error) ERR EXEC without MULTI <span class="comment"># 当前未开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 <span class="comment"># 被放弃事务中命令并未执行</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><blockquote>
<p>代码语法错误（编译时异常）所有的命令都不执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; error k1 <span class="comment"># 这是一条语法错误命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `error`, with args beginning with: `k1`, <span class="comment"># 会报错但是不影响后续命令入队 </span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. <span class="comment"># 执行报错</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 </span><br><span class="line">(nil) <span class="comment"># 其他命令并没有被执行</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** &gt;&gt;&gt; 所以不保证事务原子性</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1 <span class="comment"># 这条命令逻辑错误（对字符串进行增量）</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 运行时报错</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span> <span class="comment"># 其他命令正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</span></span><br><span class="line"><span class="comment"># 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span></span><br></pre></td></tr></table></figure>

<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p>
<blockquote>
<p>正常执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 设置余额:100</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> use 0 <span class="comment"># 支出使用:0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money (上锁)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 监视值没有被中途修改，事务正常执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p>
</blockquote>
<p>我们启动另外一个客户端模拟插队线程。</p>
<p>线程1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># money上锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; 	<span class="comment"># 此时事务并没有执行</span></span><br></pre></td></tr></table></figure>

<p>模拟线程插队，线程2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 <span class="comment"># 修改了线程一中监视的money</span></span><br><span class="line">(<span class="built_in">integer</span>) 600</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>回到线程1，执行事务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC <span class="comment"># 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span></span><br><span class="line">(nil) <span class="comment"># 没有结果，说明事务执行失败</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money <span class="comment"># 线程2 修改生效</span></span><br><span class="line"><span class="string">&quot;600&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get use <span class="comment"># 线程1事务执行失败，数值没有被修改</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解锁获取最新值，然后再加锁进行事务。</p>
<p><code>unwatch</code>进行解锁。</p>
</blockquote>
<p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p>
<h2 id="六、Jedis"><a href="#六、Jedis" class="headerlink" title="六、Jedis"></a>六、Jedis</h2><p>使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。</p>
<ol>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jredis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编码测试</p>
<ul>
<li><p>连接数据库</p>
<ol>
<li><p>修改redis的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/bin/myconfig/redis.conf</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将只绑定本地注释</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)]</p>
</li>
<li><p>保护模式改为 no</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)]</p>
</li>
<li><p>允许后台运行</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)]</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>开放端口6379</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanet</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>重启防火墙服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ol>
<li><p>阿里云服务器控制台配置安全组</p>
</li>
<li><p>重启redis-server</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@AlibabaECS bin]<span class="comment"># redis-server myconfig/redis.conf </span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<ul>
<li><p>操作命令</p>
<p><strong>TestPing.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.xx.xxx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        String response = jedis.ping();</span><br><span class="line">        System.out.println(response); <span class="comment">// PONG</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>断开连接</p>
</li>
</ul>
<ol>
<li><p><strong>事务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;39.99.xxx.xx&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        Transaction multi = jedis.multi();</span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line">        <span class="comment">// jedis.watch(result)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line">            <span class="comment">// 执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 放弃事务</span></span><br><span class="line">            multi.discard();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七、SpringBoot整合"><a href="#七、SpringBoot整合" class="headerlink" title="七、SpringBoot整合"></a>七、SpringBoot整合</h2><ol>
<li>导入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</p>
<blockquote>
<p>jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p>
<p>lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式</p>
</blockquote>
<p>我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214531573.png" alt="在这里插入图片描述"></p>
<p>那么就一定还存在一个RedisProperties类</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214554661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。</p>
<p>先看Jedis:</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214607475.png" alt="在这里插入图片描述"></p>
<p>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p>
<p>然后再看Lettuce：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214618179.png" alt="在这里插入图片描述"></p>
<p>完美生效。</p>
<p>现在我们回到RedisAutoConfiguratio</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321462777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>只有两个简单的Bean</p>
<ul>
<li><strong>RedisTemplate</strong></li>
<li><strong>StringRedisTemplate</strong></li>
</ul>
<p>当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p>
<p>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</p>
<p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214638238.png" alt="在这里插入图片描述"></p>
<p>这是一些基本的配置属性。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214649380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214700372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p>编写配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">39.99.xxx.xx</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用RedisTemplate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForHah</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接对象</span></span><br><span class="line">        <span class="comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line">        <span class="comment">//connection.flushDb();</span></span><br><span class="line">        <span class="comment">//connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试结果</p>
<p><strong>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200513214734520.png" alt="在这里插入图片描述"></p>
<p> 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p>
<p>我们转到看那个默认的RedisTemplate内部什么样子：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214746506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在最开始就能看到几个关于序列化的参数。</p>
<p>默认的序列化器是采用JDK序列化器</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214757247.png" alt="在这里插入图片描述"></p>
<p>而默认的RedisTemplate中的所有序列化器都是使用这个序列化器：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214809494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>后续我们定制RedisTemplate就可以对其进行修改。</p>
<p><code>RedisSerializer</code>提供了多种序列化方案：</p>
<ul>
<li><p>直接调用RedisSerializer的静态方法来返回序列化器，然后set</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214818682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>自己new 相应的实现类，然后set</p>
<p><img src="https://img-blog.csdnimg.cn/20200513214827233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
<li><p><strong>定制RedisTemplate的模板：</strong></p>
<p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="comment">// 将template 泛型设置为 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        <span class="comment">// 连接工厂，不必修改</span></span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 序列化设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// key、hash的key 采用 String序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// value、hash的value 采用 Jackson 序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)]</p>
</li>
</ol>
<h2 id="八、自定义Redis工具类"><a href="#八、自定义Redis工具类" class="headerlink" title="八、自定义Redis工具类"></a>八、自定义Redis工具类</h2><p>使用RedisTemplate需要频繁调用<code>.opForxxx</code>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p>
<p>工具类参考博客：</p>
<p><a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html">https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html</a></p>
<p><a href="https://www.cnblogs.com/zhzhlong/p/11434284.html">https://www.cnblogs.com/zhzhlong/p/11434284.html</a></p>
<h2 id="九、Redis-conf"><a href="#九、Redis-conf" class="headerlink" title="九、Redis.conf"></a>九、Redis.conf</h2><blockquote>
<p>容量单位不区分大小写，G和GB有区别</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020051321485460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>可以使用 include 组合多个配置问题</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214902552.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>网络配置</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214912813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>日志输出级别</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214923678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>日志输出文件</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214933713.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>持久化规则</p>
</blockquote>
<p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p>
<p>持久化方式：</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200513214944964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>RDB文件相关</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214955679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215006207.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>主从复制</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215016371.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Security模块中进行密码设置</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215026143.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>客户端连接相关</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxclients 10000  最大客户端数量</span><br><span class="line">maxmemory &lt;bytes&gt; 最大内存限制</span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到限制值的处理策略</span></span><br></pre></td></tr></table></figure>

<p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p>
<p><strong>设置方式</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> maxmemory-policy volatile-lru </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="maxmemory-policy-六种方式"><a href="#maxmemory-policy-六种方式" class="headerlink" title="maxmemory-policy 六种方式"></a><strong>maxmemory-policy 六种方式</strong></h4><p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p>
<p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p>
<p><strong>3、volatile-random：</strong>随机删除即将过期key</p>
<p><strong>4、allkeys-random：</strong>随机删除</p>
<p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p>
<p><strong>6、noeviction ：</strong> 永不过期，返回错误</p>
<blockquote>
<p>AOF相关部分</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215037918.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215047999.png" alt="在这里插入图片描述"></p>
<h2 id="十、持久化—RDB"><a href="#十、持久化—RDB" class="headerlink" title="十、持久化—RDB"></a>十、持久化—RDB</h2><p>RDB：Redis Databases</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)]</p>
<h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><hr>
<p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215126515.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr>
<p>在进行 <strong><code>RDB</code></strong> 的时候，**<code>redis</code>** 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p>
<ol>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215141519.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><hr>
<ol>
<li>save的规则满足的情况下，会自动触发rdb原则</li>
<li>执行flushall命令，也会触发我们的rdb原则</li>
<li>退出redis，也会自动产生rdb文件</li>
</ol>
<h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p>
<blockquote>
<p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215150892.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p><code>flushall</code> 命令也会触发持久化 ；</p>
<h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件 ；</p>
<blockquote>
<p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215205970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215220858.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321523151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>bgsave和save对比</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞？</td>
<td>是</td>
<td>是（阻塞发生在fock()，通常非常快）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外的内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fock子进程，消耗内存</td>
</tr>
</tbody></table>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li>
<li>fork进程的时候，会占用一定的内容空间。</li>
</ol>
<h2 id="十一、持久化AOF"><a href="#十一、持久化AOF" class="headerlink" title="十一、持久化AOF"></a>十一、持久化AOF</h2><p><strong>Append Only File</strong></p>
<p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)]</p>
<blockquote>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
</blockquote>
<h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p> 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p>
<p>如果要使用AOF，需要修改配置文件：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215247113.png" alt="在这里插入图片描述"></p>
<p><code>appendonly no yes</code>则表示启用AOF</p>
<p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p>
<p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p>
<p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p>
<blockquote>
<p>优点和缺点</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会sync 消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync 可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ol>
<li>每一次修改都会同步，文件的完整性会更加好</li>
<li>没秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li>
<li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li>
</ol>
<h2 id="十二、RDB和AOP选择"><a href="#十二、RDB和AOP选择" class="headerlink" title="十二、RDB和AOP选择"></a>十二、RDB和AOP选择</h2><h3 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h3><table>
<thead>
<tr>
<th>RDB</th>
<th>AOF</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody></table>
<h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p>
<h2 id="十三、Redis发布与订阅"><a href="#十三、Redis发布与订阅" class="headerlink" title="十三、Redis发布与订阅"></a>十三、Redis发布与订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)]</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215523258.png" alt="在这里插入图片描述"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321553483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PSUBSCRIBE pattern [pattern..]</code></td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><code>PUNSUBSCRIBE pattern [pattern..]</code></td>
<td>退订一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><code>PUBSUB subcommand [argument[argument]]</code></td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td><code>PUBLISH channel message</code></td>
<td>向指定频道发布消息</td>
</tr>
<tr>
<td><code>SUBSCRIBE channel [channel..]</code></td>
<td>订阅给定的一个或多个频道。</td>
</tr>
<tr>
<td><code>SUBSCRIBE channel [channel..]</code></td>
<td>退订一个或多个频道</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------订阅端----------------------</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE sakura <span class="comment"># 订阅sakura频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit) <span class="comment"># 等待接收消息</span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> <span class="comment"># 订阅成功的消息</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello world&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello world&quot;</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 接收到来自sakura频道的消息 &quot;hello i am sakura&quot;</span></span><br><span class="line">2) <span class="string">&quot;sakura&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello i am sakura&quot;</span></span><br><span class="line"></span><br><span class="line">--------------消息发布端-------------------</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello world&quot;</span> <span class="comment"># 发布消息到sakura频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH sakura <span class="string">&quot;hello i am sakura&quot;</span> <span class="comment"># 发布消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">-----------------查看活跃的频道------------</span><br><span class="line">127.0.0.1:6379&gt; PUBSUB channels</span><br><span class="line">1) <span class="string">&quot;sakura&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321554964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。</li>
<li>这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）</li>
<li>多人在线聊天室。</li>
</ol>
<p>稍微复杂的场景，我们就会使用消息中间件MQ处理。</p>
<h2 id="十四、Redis主从复制"><a href="#十四、Redis主从复制" class="headerlink" title="十四、Redis主从复制"></a>十四、Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p>
<p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li>
<li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li>
</ol>
<h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限。</li>
</ol>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p>
<p>查看当前库的信息：<code>info replication</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>

<p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p>
<ul>
<li>端口号</li>
<li>pid文件名</li>
<li>日志文件名</li>
<li>rdb文件名</li>
</ul>
<p>启动单机多服务集群：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215610163.png" alt="在这里插入图片描述"></p>
<h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p>==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！</p>
<p>认老大！一主（79）二从（80，81）</p>
<p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215637483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后主机上也能看到从机的状态：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215645778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215654634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol>
<li><p>从机只能读，不能写，主机可读可写但是多用于写。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;sakura&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
</li>
<li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p>
</li>
<li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p>
</blockquote>
<p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p>
<h2 id="十五、哨兵模式"><a href="#十五、哨兵模式" class="headerlink" title="十五、哨兵模式"></a>十五、哨兵模式</h2><p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p>
<p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong>这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。</p>
<p>单机单个哨兵</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2ENYVAPp-1597890996527)(狂神说 Redis.assets/image-20200818233231154.png)]</p>
<p>哨兵的作用：</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>多哨兵模式</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ga1RyfVc-1597890996528)(狂神说 Redis.assets/image-20200818233316478.png)]</p>
<p>哨兵的核心配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<ul>
<li>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</li>
</ul>
<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-sentinel xxx/sentinel.conf</span><br></pre></td></tr></table></figure>

<p>成功启动哨兵模式</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215752444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>此时哨兵监视着我们的主机6379，当我们断开主机后：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215806972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>哨兵模式优缺点</p>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li>哨兵集群，基于主从复制模式，所有主从复制的优点，它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多配置项</li>
</ol>
<blockquote>
<p>哨兵模式的全部配置</p>
</blockquote>
<p>完整的哨兵模式配置文件 sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port </span></span><br><span class="line"><span class="comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span></span><br><span class="line"><span class="comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span></span><br><span class="line"><span class="comment">#一个是事件的类型，</span></span><br><span class="line"><span class="comment">#一个是事件的描述。</span></span><br><span class="line"><span class="comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">  sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>

<h2 id="十六、缓存穿透与雪崩"><a href="#十六、缓存穿透与雪崩" class="headerlink" title="十六、缓存穿透与雪崩"></a>十六、缓存穿透与雪崩</h2><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote>
<p>概念</p>
</blockquote>
<p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215824722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>缓存空对象</strong></p>
<p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215836317.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote>
<p>概念</p>
</blockquote>
<p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
<p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><p><strong>设置热点数据永不过期</strong></p>
<p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
</li>
<li><p><strong>加互斥锁(分布式锁)</strong></p>
<p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>概念</p>
</blockquote>
<p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215850428.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ul>
<li><p>redis高可用</p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p>
</li>
<li><p>限流降级</p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
</li>
<li><p>数据预热</p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>db</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2020/10/05/Concurrency/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>并发编程相比于Java中其他知识点的学习门槛要高很多，从而导致很多人望而却步，但无论是职场面试，还是高并发/高流量系统的实现，却都离不开并发编程。</p>
<span id="more"></span>
<p>全文大致共分为三个部分，第一部分为Java并发编程基础篇，主要讲解Java并发编程的基础知识、线程有关的知识和并发编程中的其他概念，这些知识在后续的章节中都会用到。第二部分为Java并发编程的高级篇，讲解Java并发包中的核心组件的实现原理。第三部分为Java并发编程实践篇，主要讲解并发组件的使用方法，以及一些注意事项。</p>
<p>本文主要结合张龙老师的视频：<a href="https://www.bilibili.com/video/BV1qK4y1t78Z?from=search&seid=2031440298446612503">精通Java并发</a>，以及《Java并发编程之美》，系统而全面的介绍Java并发的方方面面。</p>
<h1 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h1><h2 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h2><p>在正式开始并发编程的基础内容的学习之前，有必要讨论两个核心的问题，第一是什么是并发编程，第二为什么要学习并发编程。</p>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><p>在讨论什么是线程前有必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。<br>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程一个执行路径，一个<br>进程中至少有一个线程，进程中的多个线程共享进程的资源。</p>
<h2 id="Thread和Runnable"><a href="#Thread和Runnable" class="headerlink" title="Thread和Runnable"></a>Thread和Runnable</h2><p>Thread类和Runnable接口无疑是了解Java并发编程的入口，Thread类本身是实现了Runnable接口的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们来阅读以下Thread类的文档说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have </span><br><span class="line">multiple threads of execution running concurrently.</span><br></pre></td></tr></table></figure>

<p>一个thread指的是程序执行中的一个线程，Java虚拟机支持一个应用可以有多个并发执行的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Every thread has a priority. Threads with higher priority are executed in preference to threads with </span><br><span class="line">lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread </span><br><span class="line">creates a new Thread object, the new thread has its priority initially set equal to the priority of the </span><br><span class="line">creating thread, and is a daemon thread if and only if the creating thread is a daemon.</span><br></pre></td></tr></table></figure>

<p>每一个线程都会有一个优先级，拥有高优先级的线程在执行的时候就会比低优先级的线程优先级要高，每一个线程也可以被标记为daemon（后台线程），当运行在某一个线程中的代码创建了一个新的线程，默认情况下，新的线程的优先级会和创建它的线程优先级相同，并且只有创建它的线程是daemon线程时，新的线程才会是daemon。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls </span><br><span class="line">the method named main of some designated class). The Java Virtual Machine continues to execute threads </span><br><span class="line">until either of the following occurs:</span><br></pre></td></tr></table></figure>

<p>当Java虚拟机启动的时候，通常会有一个单个的、非daemon线程（通常情况会调用某一个被指定类的main方法），Java虚拟机会继续执行线程，直到下面的两种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The exit method of class Runtime has been called and the security manager has permitted the exit </span><br><span class="line">operation to take place.</span><br><span class="line">All threads that are not daemon threads have died, either by returning from the call to the run method or </span><br><span class="line">by throwing an exception that propagates beyond the run method.</span><br></pre></td></tr></table></figure>

<ul>
<li>类的Runtime方法被调用，并且安全管理器允许退出操作发生。</li>
<li>所有的非后台线程都已经消亡了，要么是通过run方法的调用返回了，要么是run方法外面抛出了异常。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are two ways to create a new thread of execution. One is to declare a class to be a subclass of </span><br><span class="line">Thread. This subclass should override the run method of class Thread. An instance of the subclass can </span><br><span class="line">then be allocated and started. For example, a thread that computes primes larger than a stated value </span><br><span class="line">could be written as follows:</span><br></pre></td></tr></table></figure>

<p>有两种方式来创建一个新的执行线程，一种是继承Thread类，这个子类应该重写Thread类的run方法，这个子类就可以创建实例并且执行，比如，一个线程计算大于某一个状态值的，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> minPrime;</span><br><span class="line">           PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">               <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">                . . .</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>如下代码将会生成线程并且使用start方法开始执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>

<p>接下来是另外一种创建线程的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The other way to create a thread is to declare a class that implements the Runnable interface. That class </span><br><span class="line">then implements the run method. An instance of the class can then be allocated, passed as an argument </span><br><span class="line">when creating Thread, and started. The same example in this other style looks like the following:</span><br></pre></td></tr></table></figure>

<p>另一种创建线程的方式就是声明一个类并且实现Runnable接口，在这个类实现了run方法之后，就可以创建实例。当创建Thread的时候把这个类作为一个参数传入并启动，相同的例子用这个方式来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> minPrime;</span><br><span class="line">          PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">              <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">               . . .</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>如下代码就会创建一个线程并执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Every thread has a name for identification purposes. More than one thread may have the same name. If a </span><br><span class="line">name is not specified when a thread is created, a new name is generated for it.</span><br><span class="line">Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a </span><br><span class="line">NullPointerException to be thrown.</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个名称用于标识，不同的线程可能会有相同的名称，如果创建线程的时候没有指定名称，就会产生一个新的名称，如无特别说明，将null参数传递给构造方法或者这个类的其他方法就会导致空指针异常。</p>
<p>这里用到了start方法来启动线程，我们来阅读以下start方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread.</span><br><span class="line">The result is that two threads are running concurrently: the current thread (which returns from the call </span><br><span class="line">to the start method) and the other thread (which executes its run method).</span><br><span class="line">It is never legal to start a thread more than once. In particular, a thread may not be restarted once it</span><br><span class="line">has completed execution.</span><br></pre></td></tr></table></figure>

<p>当调用了start方法意味这个这个线程开始执行了，Java虚拟机会调用这个线程的run方法，结果是当前线程（调用start方法所返回的线程）和另外一个线程（执行run方法的线程）会并发的运行，多次启动一个线程是不合法的，特别的，一个线程已经执行完成之后不可以被重新启动。</p>
<p>Runnable接口本身是一个函数式接口，里面有且仅有一个抽象方法run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们阅读以下Runnable接口的文档说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The Runnable interface should be implemented by any class whose instances are intended to be executed by </span><br><span class="line">a thread. The class must define a method of no arguments called run.</span><br><span class="line">This interface is designed to provide a common protocol for objects that wish to execute code while they </span><br><span class="line">are active. For example, Runnable is implemented by class Thread. Being active simply means that a thread </span><br><span class="line">has been started and has not yet been stopped.</span><br></pre></td></tr></table></figure>

<p>任何一个执行线程的类都应该实现Runnable接口，这个类必须定义一个无参的run方法。设计这个接口是为了，给执行处在激活状态的代码的时候，提供一种公共的协议，比如说，Runnable是被Thread类所实现出来了。处于激活状态表示一个线程被启动了，而且没有停止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In addition, Runnable provides the means for a class to be active while not subclassing Thread. A class </span><br><span class="line">that implements Runnable can run without subclassing Thread by instantiating a Thread instance and </span><br><span class="line">passing itself in as the target. In most cases, the Runnable interface should be used if you are only </span><br><span class="line">planning to override the run() method and no other Thread methods. This is important because classes </span><br><span class="line">should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior</span><br><span class="line">of the class.</span><br></pre></td></tr></table></figure>

<p>此外，Runnable提供了让一个类处在激活状态同时又没有子类化的方式，一个类实现了Runnable可以不用通过子类化来运行，这是通过初始化一个Thread实例，然后将它自己作为目标传入，如果你只是计划重写run方法，而不打算重写Thread类其他的方法，一般情况下，都应该使用Runnable，这是非常重要的，除非程序员打算增强或修改一些基础的行为，因为类不应该被子类化。</p>
<p>接下来我们阅读以下run方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When an object implementing interface Runnable is used to create a thread, starting the thread causes the </span><br><span class="line">object&#x27;s run method to be called in that separately executing thread.</span><br><span class="line">The general contract of the method run is that it may take any action whatsoever.</span><br></pre></td></tr></table></figure>

<p>当使用实现了Runnable接口的对象创建了一个线程，启动这个线程，就会在单独执行的线程上执行这个类的run方法，run方法一种通用的锲约是它可以接口任何的动作。</p>
<p>同样的在Thread类中也有一个run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this thread was constructed using a separate Runnable run object, then that Runnable object&#x27;s run </span><br><span class="line">method is called; otherwise, this method does nothing and returns.</span><br><span class="line">Subclasses of Thread should override this method.</span><br></pre></td></tr></table></figure>

<p>如果这个线程是通过单独的Runnable接口对象来构建的话，那么Runnable对象的run方法就会被调用，否则，这个方法什么都不做，直接返回。Thread的子类应该重写这个方法。</p>
<p>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// private Runnable target;</span></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread类的run方法会判断本地的Runnable对象是否已经被赋值，如果已经赋值了就执行里面的run方法。</p>
<p>Thread类的构造方法都会调用init方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先了解以下这个init方法，方法的参数说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程组</span></span><br><span class="line">g – the Thread group</span><br><span class="line"><span class="comment">// 这个对象的run将会被调用</span></span><br><span class="line">target – the object whose run将会被调用() method gets called</span><br><span class="line"><span class="comment">// 新创建的线程的名称</span></span><br><span class="line">name – the name of the <span class="keyword">new</span> Thread</span><br><span class="line"><span class="comment">// 新的线程所需要的栈的大小，0表示这个参数会忽略掉</span></span><br><span class="line">stackSize – the desired stack size <span class="keyword">for</span> the <span class="keyword">new</span> thread, or zero to indicate that <span class="keyword">this</span> parameter is to be ignored.</span><br></pre></td></tr></table></figure>

<h2 id="wait、sleep和notify"><a href="#wait、sleep和notify" class="headerlink" title="wait、sleep和notify"></a>wait、sleep和notify</h2><h3 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h3><p>在Object类中有几个与线程相关的方法：notify、notifyAll、wait，这几个方法非常的重要，接下来我们分析一下这个几个方法，首先从wait方法开始，wait方法又有几个重载的方法，首先来看不带参数的wait方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() </span><br><span class="line">method for this object. In other words, this method behaves exactly as if it simply performs the call </span><br><span class="line">wait(0).</span><br></pre></td></tr></table></figure>

<p>wait方法会导致当前的线程进入等待状态，直到另外一个线程调用了这个对象的notify或者notifyAll方法，换言之，这个方法的行为是与wait(0)是等价的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The current thread must own this object&#x27;s monitor. The thread releases ownership of this monitor and </span><br><span class="line">waits until another thread notifies threads waiting on this object&#x27;s monitor to wake up either through a </span><br><span class="line">call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership</span><br><span class="line">of the monitor and resumes execution.</span><br><span class="line">As in the one argument version, interrupts and spurious wakeups are possible, and this method should </span><br><span class="line">always be used in a loop:</span><br></pre></td></tr></table></figure>

<p>要调用当前对象wait方法，当前线程必须要拥有这个对象的锁，这个线程在调用了wait方法之后，就会释放掉锁的控制权，并且进行等待，直到另外的线程通知在这个锁上等待的所有线程。唤醒的方式要么是通过notify方法或者是notifyAll方法。接下来，这个线程还是会继续等待，直到它可以重新获取锁的有用权，并且恢复执行。对于一个参数的版本来说，终端和一些虚假的唤醒是可能发生的，这个方法应该只在循环当中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">               <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                   obj.wait();</span><br><span class="line">               ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify </span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法应该只是被拥有了这个对象的锁的线程去调用，参考notify方法来查看什么情况下，一个线程可以成为锁的拥有者。</p>
<p>如果没有锁直接调用wait方法会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序就会直接抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br></pre></td></tr></table></figure>

<p>按照给出的示例，我们将程序改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            object.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序并没有抛出异常，而是进入进入了一直等待的状态。在Thread类中有一个sleep方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of</span><br><span class="line">milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not </span><br><span class="line">lose ownership of any monitors.</span><br></pre></td></tr></table></figure>

<p>它会导致当前正在执行的线程进入到休眠的状态（临时的终止执行）一段指定的毫秒数，它会收到系统定时器和调度器的精度的限制，线程并不会失去任何锁的所有权。</p>
<p>这里其实就是wait方法和sleep方法的最明显的区别，调用wait方法之前，线程必须持有对象的锁，在调用wait方法之后，线程就会释放锁，而sleep方法则不会释放掉锁。</p>
<p>前面我们提到过，不带参数的wait方法会调用他的重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait方法本身又有两个重载的方法，我们首先来阅读一下只有一个参数的相关文档：</p>
<p>首先是方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until either another thread invokes the notify() method or the </span><br><span class="line">notifyAll() method for this object, or a specified amount of time has elapsed.</span><br><span class="line">The current thread must own this object&#x27;s monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法会让当前的线程进入等待状态，除非对当前这个对象使用notify或者notifyAll方法，或者已经到了指定的超时时间，当前对象必须要拥有当前对象的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method causes the current thread (call it T) to place itself in the wait set for this object and </span><br><span class="line">then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for </span><br><span class="line">thread scheduling purposes and lies dormant until one of four things happens:</span><br></pre></td></tr></table></figure>

<p>这个方法会导致当前的线程（T），将它自身放置到一个这个对象的等待集合当中，然后放弃任何同步的声明，线程T将无法再进行调度，处在休眠状态，直到下面的四种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen</span><br><span class="line">as the thread to be awakened.</span><br><span class="line">Some other thread invokes the notifyAll method for this object.</span><br><span class="line">Some other thread interrupts thread T.</span><br><span class="line">The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time</span><br><span class="line">is not taken into consideration and the thread simply waits until notified.</span><br></pre></td></tr></table></figure>

<ul>
<li>另外一个线程调用了这个对象的notify方法，当前的线程T碰巧是要被选择唤醒的线程；</li>
<li>其他的线程调用了这个对象的notifyAll方法；</li>
<li>其他的线程中断了T线程</li>
<li>指定的时间已经过去了，不过如果时间设置为0的话，线程会一直进入等待直到被通知，而不会再去计算时间。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It </span><br><span class="line">then competes in the usual manner with other threads for the right to synchronize on the object; once it </span><br><span class="line">has gained control of the object, all its synchronization claims on the object are restored to the status </span><br><span class="line">quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then </span><br><span class="line">returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization </span><br><span class="line">state of the object and of thread T is exactly as it was when the wait method was invoked.</span><br></pre></td></tr></table></figure>

<p>接下来线程T会从对象等待集合中移除掉，然后，重新又可以进行线程的调度了。它会按照通常的方式与其他的线程竞争对于对象的同步权，一旦获得了对象的同步权，所有它的对这个对象同步的声明又会恢复到之前的同步声明状态，也就是说恢复到wait方法被调用的时候所处的状态，接下来线程T就会从wait方法的调用当中去返回，返回的时候，对象的同步状态以及线程T的同步状态与wait方法被调用的时候的状态是一模一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious </span><br><span class="line">wakeup. While this will rarely occur in practice, applications must guard against it by testing for the </span><br><span class="line">condition that should have caused the thread to be awakened, and continuing to wait if the condition is </span><br><span class="line">not satisfied. In other words, waits should always occur in loops, like this one:</span><br></pre></td></tr></table></figure>

<p>一个线程还可以被唤醒无需被通知、中断或者超时，这个称之为虚假的唤醒，虽然这种实际情况下很少发生，但是应用还是应该通过测试条件保证这一点，并且如果条件没有被满足的时候就持续处于等待状态，换句话说，等待总是应该发生在循环当中，就向下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">              <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">                  obj.wait(timeout);</span><br><span class="line">              ... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the current thread is interrupted by any thread before or while it is waiting, then an </span><br><span class="line">InterruptedException is thrown. This exception is not thrown until the lock status of this object has </span><br><span class="line">been restored as described above.</span><br></pre></td></tr></table></figure>

<p>如果当前的线程被别的线程在它等待之前或等待当中的时候被中断了，这个锁状态恢复之后才会被正常的抛出InterruptedException异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Note that the wait method, as it places the current thread into the wait set for this object, unlocks </span><br><span class="line">only this object; any other objects on which the current thread may be synchronized remain locked while </span><br><span class="line">the thread waits.</span><br></pre></td></tr></table></figure>

<p>wait方法会将当前的线程放置到它的等待的对象集合当中，只会解锁当前的对象，当这个线程等待的时候，任何其它的对象对象可能会依然处于锁定的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify </span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法应该只被持有对象锁的线程所调用，请查看notify方法来查看如何让一个线程成为锁的拥有者。</p>
<p>接下来我们查看wait方法另外一个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 底层实现还是调用wait(long timeout)方法</span></span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait方法和notify方法总是成对出现的，notify方法也是一个native方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们来了解一下notify方法的作用：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">Wakes up a single thread that is waiting on this object&#x27;s monitor. If any threads are waiting on this </span><br><span class="line">object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the</span><br><span class="line">implementation. A thread waits on an object&#x27;s monitor by calling one of the wait methods.</span><br></pre></td></tr></table></figure>

<p>它会唤醒正在等待这个对象的锁的单个线程，如果有多个线程都在等待这个对象的锁，那么就会选择其中的一个进行唤醒，选择是随机的，并且是根据实现来决定的，一个线程会通过调用某一个wait方法进入等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The awakened thread will not be able to proceed until the current thread relinquishes the lock on this</span><br><span class="line">object. The awakened thread will compete in the usual manner with any other threads that might be </span><br><span class="line">actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable</span><br><span class="line">privilege or disadvantage in being the next thread to lock this object.</span><br><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. A thread  </span><br><span class="line">becomes the owner of the object&#x27;s monitor in one of three ways:    </span><br></pre></td></tr></table></figure>

<p>被唤醒的线程是无法执行的，直到当前的线程放弃了这个对象的锁，被唤醒的线程会按照常规的方式与其他的线程进行对象同步的竞争，比如说，被唤醒的线程它是没有任何的特权，也没有任何不足的地方，都有可能会获得当前对象的锁。notify方法只能被这个对象的持有者来进行调用，一个线程获取对象锁有以下三种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By executing a synchronized instance method of that object.</span><br><span class="line">By executing the body of a synchronized statement that synchronizes on the object.</span><br><span class="line">For objects of type Class, by executing a synchronized static method of that class.</span><br></pre></td></tr></table></figure>

<ul>
<li>通过执行对象的synchronized实例方法来获取</li>
<li>通过执行这个对象的synchronized语句块来获取</li>
<li>对于Class类型的对象，通过执行这个class中synchronized静态方法来获取</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Only one thread at a time can own an object&#x27;s monitor.  </span><br></pre></td></tr></table></figure>

<p>在某一个时刻只有一个线程拥有一个对象的锁。</p>
<p>同样的，notifyAll方法也是一个本地方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wakes up all threads that are waiting on this object&#x27;s monitor. A thread waits on an object&#x27;s monitor by</span><br><span class="line">calling one of the wait methods.</span><br></pre></td></tr></table></figure>

<p>notifyAll方法会唤醒在这个对象的锁上等待的所有的线程，线程可以通过调用这个对象的wait方法等待这个对象的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The awakened threads will not be able to proceed until the current thread relinquishes the lock on this </span><br><span class="line">object. The awakened threads will compete in the usual manner with any other threads that might be </span><br><span class="line">actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable </span><br><span class="line">privilege or disadvantage in being the next thread to lock this object.</span><br></pre></td></tr></table></figure>

<p>被唤醒的线程只有在当前对象释放掉锁的时候才能继续执行，它会按照通常的方式与其他的线程竞争对象的同步，既没有什么特权，也没有什么缺陷，都有可能是下一个给当前对象上锁的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method should only be called by a thread that is the owner of this object&#x27;s monitor. See the notify</span><br><span class="line">method for a description of the ways in which a thread can become the owner of a monitor.</span><br></pre></td></tr></table></figure>

<p>这个方法只能被持有锁的对象锁调用，查看notify方法获取对象锁的方式。</p>
<p>我们可以用一张表格来总结以下wait、notify、notifyAll方法的区别：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wait</td>
<td align="center">1、当调用wait方法时，首先需要确保wait方法的线程已经持有了对象的锁<br>2、当调用wait后，该线程会释放掉这个对象的锁，然后进入到等待状态（wait set）<br>3、当线程调用了wait后进入等待状态时，它就可以等待线程调用相同对象的notify和notifyAll方法来使得自己被唤醒<br>4、一旦这个线程被其他线程唤醒后，该线程就会与其他线程一同开始竞争这个对象的锁（公平竞争）；只有当该线程获取到了这个对象的锁后，线程才会继续往下执行<br>5、调用wait方法的代码片段需要放在synchronize代码块或者synchronized方法中，这样才可以确保线程在调用wait方法前已经获取到了对象的锁</td>
</tr>
<tr>
<td align="center">notify</td>
<td align="center">1、当调用对象的notify方法时，它会随机唤醒该对象等待集合（wait set）中的任意一个线程，当某个线程被唤醒后，它就会与其他线程一同竞争对象的锁<br>2、在某一时刻只有唯一一个线程可以拥有对象的锁</td>
</tr>
<tr>
<td align="center">notifyAll</td>
<td align="center">1、当调用对象的notifyAll方法时，它会唤醒该对象集合（wait set）中所有的线程，这些线程被唤醒后，又会开始竞争对象的锁</td>
</tr>
</tbody></table>
<h3 id="方法实践"><a href="#方法实践" class="headerlink" title="方法实践"></a>方法实践</h3><p>我们来看一个需要运用并发编程的实际的需求：</p>
<p> 1、存在一个对象，该对象有个int类型的成员变量counter，该成员变量的初始值为0；</p>
<p>2、创建两个线程，其中一个线程对该对象的成员变量counter加1，另一个线程对该对象的成员变量减1；</p>
<p>3、输出该对象成员变量counter每次变化后的值；</p>
<p>4、最终输出的结果应为：1010101010…。</p>
<p>首先是我们需要操作的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要操作的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter--;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加的线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyObject myObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IncreaseThread</span><span class="params">(MyObject myObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myObject = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">             myObject.increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减少的线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecreaseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyObject myObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecreaseThread</span><span class="params">(MyObject myObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myObject = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            myObject.decrease();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用客户端来进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        <span class="comment">// 这里先启动哪个线程结果都是相同的</span></span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序也正如我们所愿，输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :client.main()</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>接下来我们尝试创建多个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        Thread increaseThread = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread increaseThread2 = <span class="keyword">new</span> IncreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        Thread decreaseThread2 = <span class="keyword">new</span> DecreaseThread(myObject);</span><br><span class="line">        increaseThread.start();</span><br><span class="line">        increaseThread2.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">        decreaseThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :client.main()</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line">-2</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line">-4</span><br></pre></td></tr></table></figure>

<p>可以看到这个时候，输入的结果其实已经是没有规律的了。这是因为在之前只有两个线程的时候，调用notify方法一定会唤醒唯一的另外一个方法，而在上面的这个例子中，被唤醒的线程实际上是随机的。</p>
<p>为了避免这种情况的发生，我们应该使用while来进行判断，而不是使用if：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (counter != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter++;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counter--;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized详解"><a href="#synchronized详解" class="headerlink" title="synchronized详解"></a>synchronized详解</h2><h3 id="synchronized简介"><a href="#synchronized简介" class="headerlink" title="synchronized简介"></a>synchronized简介</h3><p>我们首先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 传入的是同一个Runnable实例，都可以访问到成员变量x</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;result: &quot;</span> + x++);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个程序，实际上每次输出的结果都是不相同的，这两个线程实际上共享了成员变量x，如果一个对象有可以被修改的成员变量，我们就认为这个对象是可变的对象，或者称之为有状态的，反之，如果一个对象没有被修改的成员变量，那么我们称这个对象是无状态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread1(myClass);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread2(myClass);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">700</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">400</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyClass myClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myClass.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass myClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(MyClass myClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myClass.world();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :MyThreadTest2.main()</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>如果一个对象有若个synchronized方法，在某一个时刻只会有唯一的一个synchronized方法会被某一个线程访问，原因就在于当前对象的锁只有一个。当方法是static的时候，获取的锁不再是当前对象的锁，而是当前对象的Class的锁。</p>
<h3 id="synchronized字节码分析"><a href="#synchronized字节码分析" class="headerlink" title="synchronized字节码分析"></a>synchronized字节码分析</h3><p>synchronized关键字一般来说可以作用在代码块和方法当中，当作用在代码块的中的时候，一般会使用如下的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到object对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用命令进行反编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -c MyTest2.class</span><br></pre></td></tr></table></figure>

<p>反编译的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrency2</span>.<span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="comment">// 获取当前对象的成员变量</span></span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="comment">// 锁进入</span></span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="comment">// 开始执行代码</span></span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">15</span>: aload_1</span><br><span class="line">      <span class="comment">// 锁退出</span></span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: goto          <span class="number">25</span></span><br><span class="line">      <span class="number">20</span>: astore_2</span><br><span class="line">      <span class="number">21</span>: aload_1</span><br><span class="line">      <span class="comment">// 处理异常退出锁的释放</span></span><br><span class="line">      <span class="number">22</span>: monitorexit</span><br><span class="line">      <span class="number">23</span>: aload_2</span><br><span class="line">      <span class="number">24</span>: athrow</span><br><span class="line">      <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">17</span>    <span class="number">20</span>   any</span><br><span class="line">          <span class="number">20</span>    <span class="number">23</span>    <span class="number">20</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个monitorexit的原因是，无论代码执行是否抛出了异常，都会释放掉锁的对象，这部分是由Java编译器所做的工作。</p>
<p>当我们使用synchronized关键字来修饰代码块时，字节码层面上是通过monitor与monitorexit指令来实现的锁的获取与释放动作，一个monitor可能对应一个或者多个monitorexit，为了说明这一点，我们修改一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到object对象的锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候反编译字节码就会得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">concurrency2</span>.<span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">12</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">3</span>                  <span class="comment">// Field object:Ljava/lang/Object;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String hello world</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">new</span>           #<span class="number">7</span>                  <span class="comment">// class java/lang/RuntimeException</span></span><br><span class="line">      <span class="number">18</span>: dup</span><br><span class="line">      <span class="comment">// RuntimeException的构造方法</span></span><br><span class="line">      <span class="number">19</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: astore_2</span><br><span class="line">      <span class="number">24</span>: aload_1</span><br><span class="line">      <span class="number">25</span>: monitorexit</span><br><span class="line">      <span class="number">26</span>: aload_2</span><br><span class="line">      <span class="number">27</span>: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">26</span>    <span class="number">23</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么只有一个monitorexit呢？因为程序的出口只有一种，或者说程序运行的最终结果一定会抛出异常，这个时候athrow是一定会执行的，因此只有唯一的一个monitorexit。</p>
<p>当线程进入到monitorenter指令后，线程将会持有Monitor对象，退出monitorenter指令后，线程将会释放Moniter对象。</p>
<p>synchronized关键字除了可以作用在代码块上，还可以作用在方法上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样反编译之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;                                                                                                         </span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest3();                                                                          </span><br><span class="line">    descriptor: ()V                                                                                       </span><br><span class="line">    flags: ACC_PUBLIC                                                                                     </span><br><span class="line">    Code:                                                                                                 </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                      </span><br><span class="line">         <span class="number">0</span>: aload_0                                                                                       </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V                     </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>                                                                                        </span><br><span class="line">      LineNumberTable:                                                                                    </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span>                                                                                         </span><br><span class="line">      LocalVariableTable:                                                                                 </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                             </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest3;                                                </span><br><span class="line">                                                                                                          </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;                                                                      </span><br><span class="line">    descriptor: ()V                                                                                       	<span class="comment">// ACC_SYNCHRONIZED表示这是一个synchronized方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED                                                                   </span><br><span class="line">    Code:                                                                                                 	<span class="comment">//默认情况下参数的长度为1，是因为传入了当前对象</span></span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                      </span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;         </span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world                                       </span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V </span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span>                                                                                        </span><br><span class="line">      LineNumberTable:                                                                                    </span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span>                                                                                        </span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span>                                                                                        </span><br><span class="line">      LocalVariableTable:                                                                                 </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                             </span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest3;                                                </span><br><span class="line">&#125;                                                                                                       </span><br></pre></td></tr></table></figure>

<p>synchronized关键字修饰方法与代码块不同的地方是，并没有通过monitorenter与monitorexit指令来描述，而是使用ACC_SYNCHRONIZED表示该方法被synchronized修饰。当方法被调用的时候，JVM会检查该方法是否拥有ACC_SYNCHRONIZED标志，如果有，那么执行线程将会持有方法所在的Monitor对象，然后再去执行方法体，在该方法执行期间，其他线程均无法再获取到这个Monitor对象，当线程执行完该方法后，它会释放掉这个Monitor对象。</p>
<p>synchronized关键字还有可能作用在静态方法上面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;                                                                                                          </span><br><span class="line">  <span class="keyword">public</span> concurrency2.MyTest4();                                                                           </span><br><span class="line">    descriptor: ()V                                                                                        </span><br><span class="line">    flags: ACC_PUBLIC                                                                                      </span><br><span class="line">    Code:                                                                                                  </span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                                                                       </span><br><span class="line">         <span class="number">0</span>: aload_0                                                                                        </span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V                      </span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span>                                                                                         </span><br><span class="line">      LineNumberTable:                                                                                     </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span>                                                                                          </span><br><span class="line">      LocalVariableTable:                                                                                  </span><br><span class="line">        Start  Length  Slot  Name   Signature                                                              </span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lconcurrency2/MyTest4;                                                 </span><br><span class="line">                                                                                                           </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;                                                                </span><br><span class="line">    descriptor: ()V</span><br><span class="line">    <span class="comment">//  ACC_STATIC表示静态的同步方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED                                                        </span><br><span class="line">    Code:                                                                                                  </span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span>                                                                       </span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;          </span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world                                        </span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V  </span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span>                                                                                         </span><br><span class="line">      LineNumberTable:                                                                                     </span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span>                                                                                         </span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span>                                                                                         </span><br><span class="line">&#125;                                                                                                          </span><br></pre></td></tr></table></figure>

<p>可以看到无论是修改实例方法还是静态方法，都是通过ACC_SYNCHRONIZED来实现的，静态方法还会增加ACC_STATIC来表示是静态方法。</p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><h3 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h3><p>JVM中的同步是基于进入与退出监视器对象（管程对象）（Monitor）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象会和Java对象一同创建，一同销毁，Monitor对象是由C++来实现的。</p>
<p>当多个线程同时访问一段同步代码时，这些线程会被方法一个EntryList集合当中，处于阻塞状态的线程都会被方法该列表中。接下来，当线程获取到对象的Monitor时，Monitor是依赖于底层操作系统的mutex lock（互斥锁）来实现互斥的，线程获取mutex成功，则会持有mutex，这时其他线程就无法再获取到该mutex。</p>
<p>如果线程调用了wait方法，那么该线程就会释放掉所持有的mutex，并且该线程会进入到WaitSet集合（等待集合）中，等待下一次被其他线程调用notify/notifyAll唤醒。如果当前线程顺利执行完毕方法，那么它也会释放掉所持有的mutex。</p>
<p>同步锁再这种实现方式当中，因为Monitor是依赖于底层的操作系统实现，因此存在用户态与内核态之间的切换，所以会增加性能开销，通过对象互斥锁的概念来保证共享数据操作的完整性。每个对象都对应于一个可称为互斥锁的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象。</p>
<p>那些处于EntryList与WaitSet中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在linux下是通过pthread_ mutex_lock函数实现的。线程被阻塞之后便会进入到内核调度方法，这会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。</p>
<p>解决上述问题的办法便是自旋（Spin），其原理是：当发生对Monitor的争用时，如果Owner能够在很短的时间内释放掉锁，则那些正在争用的线程就是稍微等待一下（即自旋），在Owner线程释放锁之后，争用线程就有可能会立刻获取到锁，从而避免了系统阻塞。不过，当Owner运行的时间超过了临界值后，争用线程自旋一段时间后依然无法获取到锁，这时争用线程则会停止自旋进入到阻塞状态，所的来说：先自旋，不成功再进入阻塞状态，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有极大的性能提升。显然，自旋在多核心处理器上才有意义。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁的属性：</p>
<ol>
<li>PTHREAD_MUTEX_TIME_NP：这是缺省值，也就是普通锁，当一个线程加锁以后，其余请求锁的线程将会形成一个等待队列，并且在解锁后按照优先级获取到锁。这种策略可以确保资源分配的公平性。</li>
<li>PTHREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许一个线程对同一个锁成功获取多次，并且通过unlock解锁，如果是不同线程请求，则在加锁线程解锁时重新进行竞争。</li>
<li>PTHREAD_MUTEX_ERRORCHECK_NP：检错锁，如果一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIME_NP类型相同，这样就保证了当不允许多次加锁时出现最简单情况下的死锁。</li>
<li>PTHREAD_MUTEX_ADAPTIVE_NP：适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争。</li>
</ol>
<h3 id="Monitor源码分析"><a href="#Monitor源码分析" class="headerlink" title="Monitor源码分析"></a>Monitor源码分析</h3><p>接下来我们通过<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/73f624a2488d/src/share/vm/runtime">openjdk</a>的源代码来分析Monitor底层的实现。</p>
<p>objectMonitor.hpp（头文件）和objectMonitor.cpp（具体的实现）这两个文件是关于Monitor的底层实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARE_VM_RUNTIME_OBJECTMONITOR_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHARE_VM_RUNTIME_OBJECTMONITOR_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/os.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/park.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;runtime/perfData.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞在当前的Monitor上的线程的封装，是一种链表的结构：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span> :</span> <span class="keyword">public</span> StackObj &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">TStates</span> &#123;</span> TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ &#125; ;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Sorted</span>  &#123;</span> PREPEND, APPEND, SORTED &#125; ;</span><br><span class="line">  <span class="comment">// 前一个ObjectWaiter</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _next;</span><br><span class="line">  <span class="comment">// 后一个ObjectWaiter</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _prev;</span><br><span class="line">  Thread*       _thread;</span><br><span class="line">  jlong         _notifier_tid;</span><br><span class="line">  ParkEvent *   _event;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span>  _notified ;</span><br><span class="line">  <span class="keyword">volatile</span> TStates TState ;</span><br><span class="line">  Sorted        _Sorted ;           <span class="comment">// List placement disposition</span></span><br><span class="line">  <span class="keyword">bool</span>          _active ;           <span class="comment">// Contention monitoring is enabled</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ObjectWaiter</span>(Thread* thread);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_begin</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_reenter_end</span><span class="params">(ObjectMonitor *mon)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectMonitor</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    OM_OK,                    <span class="comment">// no error</span></span><br><span class="line">    OM_SYSTEM_ERROR,          <span class="comment">// operating system error</span></span><br><span class="line">    OM_ILLEGAL_MONITOR_STATE, <span class="comment">// IllegalMonitorStateException</span></span><br><span class="line">    OM_INTERRUPTED,           <span class="comment">// Thread.interrupt()</span></span><br><span class="line">    OM_TIMED_OUT              <span class="comment">// Object.wait() timed out</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_offset_in_bytes</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _header);     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">object_offset_in_bytes</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _object);     &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">owner_offset_in_bytes</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _owner);      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count_offset_in_bytes</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _count);      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">recursions_offset_in_bytes</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _recursions); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cxq_offset_in_bytes</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _cxq) ;       &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">succ_offset_in_bytes</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _succ) ;      &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">EntryList_offset_in_bytes</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _EntryList);  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FreeNext_offset_in_bytes</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, FreeNext);    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">WaitSet_offset_in_bytes</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _WaitSet) ;   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Responsible_offset_in_bytes</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _Responsible);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Spinner_offset_in_bytes</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="built_in">offset_of</span>(ObjectMonitor, _Spinner);    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*SpinCallbackFunction)</span><span class="params">(<span class="keyword">intptr_t</span>, <span class="keyword">int</span>)</span> </span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">intptr_t</span> SpinCallbackArgument ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">markOop   <span class="title">header</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_header</span><span class="params">(markOop hdr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span> <span class="title">is_busy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _count|_waiters|<span class="built_in">intptr_t</span>(_owner)|<span class="built_in">intptr_t</span>(_cxq)|<span class="built_in">intptr_t</span>(_EntryList ) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">is_entered</span><span class="params">(Thread* current)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">owner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_owner</span><span class="params">(<span class="keyword">void</span>* owner)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">waiters</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_count</span><span class="params">(<span class="keyword">intptr_t</span> count)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">contentions</span><span class="params">()</span> <span class="keyword">const</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">recursions</span><span class="params">()</span> <span class="keyword">const</span>                                         </span>&#123; <span class="keyword">return</span> _recursions; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JVM/DI GetMonitorInfo() needs this</span></span><br><span class="line">  <span class="function">ObjectWaiter* <span class="title">first_waiter</span><span class="params">()</span>                                         </span>&#123; <span class="keyword">return</span> _WaitSet; &#125;</span><br><span class="line">  <span class="function">ObjectWaiter* <span class="title">next_waiter</span><span class="params">(ObjectWaiter* o)</span>                           </span>&#123; <span class="keyword">return</span> o-&gt;_next; &#125;</span><br><span class="line">  <span class="function">Thread* <span class="title">thread_of_waiter</span><span class="params">(ObjectWaiter* o)</span>                            </span>&#123; <span class="keyword">return</span> o-&gt;_thread; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化Monitor对象，除了semaphore都是简单的对象或者指针</span></span><br><span class="line">  <span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 等待集合</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">     <span class="comment">// 等待集合</span></span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> Add asserts ...</span></span><br><span class="line">   <span class="comment">// _cxq == 0 _succ == NULL _owner == NULL _waiters == 0</span></span><br><span class="line">   <span class="comment">// _count == 0 _EntryList  == NULL etc</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Recycle</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add stronger asserts ...</span></span><br><span class="line">    <span class="comment">// _cxq == 0 _succ == NULL _owner == NULL _waiters == 0</span></span><br><span class="line">    <span class="comment">// _count == 0 EntryList  == NULL</span></span><br><span class="line">    <span class="comment">// _recursions == 0 _WaitSet == NULL</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> assert (is_busy()|_recursions) == 0</span></span><br><span class="line">    _succ          = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList     = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq           = <span class="literal">NULL</span> ;</span><br><span class="line">    _WaitSet       = <span class="literal">NULL</span> ;</span><br><span class="line">    _recursions    = <span class="number">0</span> ;</span><br><span class="line">    _SpinFreq      = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock     = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread  = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">object</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>*     <span class="title">object_addr</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">set_object</span><span class="params">(<span class="keyword">void</span>* obj)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">check</span><span class="params">(TRAPS)</span></span>;       <span class="comment">// true if the thread owns the monitor.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">check_slow</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sanity_checks</span><span class="params">()</span></span>;  <span class="comment">// public for -XX:+ExecuteInternalVMTests</span></span><br><span class="line">                                <span class="comment">// in PRODUCT for -XX:SyncKnobs=Verbose=1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">verify</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">try_enter</span> <span class="params">(TRAPS)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">enter</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">wait</span><span class="params">(jlong millis, <span class="keyword">bool</span> interruptable, TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notify</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">notifyAll</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the following at your own risk</span></span><br><span class="line">  <span class="function"><span class="keyword">intptr_t</span>  <span class="title">complete_exit</span><span class="params">(TRAPS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">reenter</span><span class="params">(<span class="keyword">intptr_t</span> recursions, TRAPS)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">AddWaiter</span> <span class="params">(ObjectWaiter * waiter)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span>    <span class="keyword">void</span> <span class="title">DeferredInitialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ObjectWaiter * <span class="title">DequeueWaiter</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">DequeueSpecificWaiter</span> <span class="params">(ObjectWaiter * waiter)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">EnterI</span> <span class="params">(TRAPS)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ReenterI</span> <span class="params">(Thread * Self, ObjectWaiter * SelfNode)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">UnlinkAfterAcquire</span> <span class="params">(Thread * Self, ObjectWaiter * SelfNode)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TryLock</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">NotRunnable</span> <span class="params">(Thread * Self, Thread * Owner)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_Fixed</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_VaryFrequency</span> <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span>       <span class="title">TrySpin_VaryDuration</span>  <span class="params">(Thread * Self)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ctAsserts</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>      <span class="title">ExitEpilog</span> <span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span>      <span class="title">ExitSuspendEquivalent</span> <span class="params">(JavaThread * Self)</span> </span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectSynchronizer</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// WARNING: this must be the very first word of ObjectMonitor</span></span><br><span class="line">  <span class="comment">// This means this class can&#x27;t use any virtual member functions.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> markOop   _header;       <span class="comment">// displaced object header word - mark</span></span><br><span class="line">  <span class="keyword">void</span>*     <span class="keyword">volatile</span> _object;       <span class="comment">// backward object pointer - strong root</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> SharingPad [<span class="number">1</span>] ;           <span class="comment">// temp to reduce false sharing</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// All the following fields must be machine word aligned</span></span><br><span class="line">  <span class="comment">// The VM assumes write ordering wrt these fields, which can be</span></span><br><span class="line">  <span class="comment">// read from other threads.</span></span><br><span class="line"> <span class="comment">// 锁的持有者</span></span><br><span class="line"> <span class="keyword">protected</span>:                         <span class="comment">// protected for jvmtiRawMonitor</span></span><br><span class="line">  <span class="keyword">void</span> *  <span class="keyword">volatile</span> _owner;          <span class="comment">// pointer to owning thread OR BasicLock</span></span><br><span class="line">  <span class="keyword">volatile</span> jlong _previous_owner_tid; <span class="comment">// thread id of the previous owner of the monitor</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _recursions;   <span class="comment">// recursion count, 0 for first entry</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> OwnerIsThread ;               <span class="comment">// _owner is (Thread *) vs SP/BasicLock</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _cxq ;    <span class="comment">// LL of recently-arrived threads blocked on entry.</span></span><br><span class="line">                                    <span class="comment">// The list is actually composed of WaitNodes, acting</span></span><br><span class="line"> <span class="comment">// 没获取到锁的线程                                   // as proxies for Threads.</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _EntryList ;     <span class="comment">// Threads blocked on entry or reentry.</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Thread * <span class="keyword">volatile</span> _succ ;          <span class="comment">// Heir presumptive thread - used for futile wakeup throttling</span></span><br><span class="line">  Thread * <span class="keyword">volatile</span> _Responsible ;</span><br><span class="line">  <span class="keyword">int</span> _PromptDrain ;                <span class="comment">// rqst to drain cxq into EntryList ASAP</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _Spinner ;           <span class="comment">// for exit-&gt;spinner handoff optimization</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinFreq ;          <span class="comment">// Spin 1-out-of-N attempts: success rate</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinClock ;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _SpinDuration ;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span> _SpinState ;    <span class="comment">// MCS/CLH list of spinners</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO-<span class="doctag">FIXME:</span> _count, _waiters and _recursions should be of</span></span><br><span class="line">  <span class="comment">// type int, or int32_t but not intptr_t.  There&#x27;s no reason</span></span><br><span class="line">  <span class="comment">// to use 64-bit fields for these variables on a 64-bit JVM.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _count;        <span class="comment">// reference count to prevent reclaimation/deflation</span></span><br><span class="line">                                    <span class="comment">// at stop-the-world time.  See deflate_idle_monitors().</span></span><br><span class="line">                                    <span class="comment">// _count is approximately |_WaitSet| + |_EntryList|</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span>  _waiters;      <span class="comment">// number of waiting threads</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 等待集合定义</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _WaitSet; <span class="comment">// LL of threads wait()ing on the monitor</span></span><br><span class="line">    <span class="comment">// 等待队列,简单的自旋锁</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _WaitSetLock;        <span class="comment">// protects Wait Queue - simple spinlock</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _QMix ;                       <span class="comment">// Mixed prepend queue discipline</span></span><br><span class="line">  ObjectMonitor * FreeNext ;        <span class="comment">// Free list linkage</span></span><br><span class="line">  <span class="keyword">intptr_t</span> StatA, StatsB ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span> <span class="params">()</span> </span>;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_ContendedLockAttempts ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_FutileWakeups ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Parks ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_EmptyNotifications ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Notifications ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowEnter ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowExit ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowNotify ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SlowNotifyAll ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_FailedSpins ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_SuccessfulSpins ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_PrivateA ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_PrivateB ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_MonInCirculation ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_MonScavenged ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Inflations ;</span><br><span class="line">  <span class="keyword">static</span> PerfCounter * _sync_Deflations ;</span><br><span class="line">  <span class="keyword">static</span> PerfLongVariable * _sync_MonExtant ;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Knob_Verbose;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> Knob_SpinLimit;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateHeap</span>(size, mtInternal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[] (<span class="keyword">size_t</span> size) <span class="built_in"><span class="keyword">throw</span></span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span> (size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FreeHeap</span>(p, mtInternal);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[] (<span class="keyword">void</span> *p) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TEVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEVENT(nom) &#123;<span class="meta-keyword">if</span> (SyncVerbose) FEVENT(nom); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FEVENT(nom) &#123; static volatile int ctr = 0 ; int v = ++ctr ; <span class="meta-keyword">if</span> ((v &amp; (v-1)) == 0) &#123; ::printf (#nom <span class="meta-string">&quot; : %d \n&quot;</span>, v); ::fflush(stdout); &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  TEVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEVENT(nom) &#123;;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>EntryList、WaitSet采用链表的方式是因为在这个链表中，要根据某一定的规则查找、删除、增加线程比较容易。只有经过wait方法调用的时候，才会进入到WaitSet集合当中。</p>
<h3 id="wait、notify源码分析"><a href="#wait、notify源码分析" class="headerlink" title="wait、notify源码分析"></a>wait、notify源码分析</h3><p>wait方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::wait</span><span class="params">(jlong millis, <span class="keyword">bool</span> interruptible, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">   <span class="built_in">assert</span>(Self-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;Must be Java thread!&quot;</span>);</span><br><span class="line">   JavaThread *jt = (JavaThread *)THREAD;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Throw IMSX or IEX.</span></span><br><span class="line">   <span class="built_in">CHECK_OWNER</span>();</span><br><span class="line"></span><br><span class="line">   EventJavaMonitorWait event;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// check for a pending interrupt</span></span><br><span class="line">   <span class="keyword">if</span> (interruptible &amp;&amp; Thread::<span class="built_in">is_interrupted</span>(Self, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">     <span class="comment">// post monitor waited event.  Note that this is past-tense, we are done waiting.</span></span><br><span class="line">     <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_waited</span>()) &#123;</span><br><span class="line">        <span class="comment">// Note: &#x27;false&#x27; parameter is passed here because the</span></span><br><span class="line">        <span class="comment">// wait was not timed out due to thread interrupt.</span></span><br><span class="line">        JvmtiExport::<span class="built_in">post_monitor_waited</span>(jt, <span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In this short circuit of the monitor wait protocol, the</span></span><br><span class="line">        <span class="comment">// current thread never drops ownership of the monitor and</span></span><br><span class="line">        <span class="comment">// never gets added to the wait queue so the current thread</span></span><br><span class="line">        <span class="comment">// cannot be made the successor. This means that the</span></span><br><span class="line">        <span class="comment">// JVMTI_EVENT_MONITOR_WAITED event handler cannot accidentally</span></span><br><span class="line">        <span class="comment">// consume an unpark() meant for the ParkEvent associated with</span></span><br><span class="line">        <span class="comment">// this ObjectMonitor.</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">       <span class="built_in">post_monitor_wait_event</span>(&amp;event, <span class="keyword">this</span>, <span class="number">0</span>, millis, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Wait - Throw IEX) ;</span><br><span class="line">     <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>());</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">TEVENT</span> (Wait) ;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">assert</span> (Self-&gt;_Stalled == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line">   jt-&gt;<span class="built_in">set_current_waiting_monitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// create a node to be put into the queue</span></span><br><span class="line">   <span class="comment">// Critically, after we reset() the event but prior to park(), we must check</span></span><br><span class="line">   <span class="comment">// for a pending interrupt.</span></span><br><span class="line">   <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span></span>;</span><br><span class="line">   node.TState = ObjectWaiter::TS_WAIT ;</span><br><span class="line">   Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">   OrderAccess::<span class="built_in">fence</span>();          <span class="comment">// ST into Event; membar ; LD interrupted-flag</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Enter the waiting queue, which is a circular doubly linked list in this case</span></span><br><span class="line">   <span class="comment">// but it could be a priority queue or any data structure.</span></span><br><span class="line">   <span class="comment">// _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only</span></span><br><span class="line">   <span class="comment">// by the the owner of the monitor *except* in the case where park()</span></span><br><span class="line">   <span class="comment">// returns because of a timeout of interrupt.  Contention is exceptionally rare</span></span><br><span class="line">   <span class="comment">// so we use a simple spin-lock instead of a heavier-weight blocking lock.</span></span><br><span class="line"></span><br><span class="line">   Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - add&quot;</span>) ;</span><br><span class="line">    <span class="comment">// 将封装好的node对象放到队列中，通过双向链表实现的</span></span><br><span class="line">   <span class="built_in">AddWaiter</span> (&amp;node) ;</span><br><span class="line">   Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">intptr_t</span> save = _recursions; <span class="comment">// record the old recursion count</span></span><br><span class="line">   _waiters++;                  <span class="comment">// increment the number of waiters</span></span><br><span class="line">   _recursions = <span class="number">0</span>;             <span class="comment">// set the recursion level to be 1</span></span><br><span class="line">    <span class="comment">// 释放掉锁</span></span><br><span class="line">   <span class="built_in">exit</span> (<span class="literal">true</span>, Self) ;                    <span class="comment">// exit the monitor</span></span><br><span class="line">   <span class="built_in">guarantee</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The thread is on the WaitSet list - now park() it.</span></span><br><span class="line">   <span class="comment">// On MP systems it&#x27;s conceivable that a brief spin before we park</span></span><br><span class="line">   <span class="comment">// could be profitable.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// TODO-<span class="doctag">FIXME:</span> change the following logic to a loop of the form</span></span><br><span class="line">   <span class="comment">//   while (!timeout &amp;&amp; !interrupted &amp;&amp; _notified == 0) park()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> ret = OS_OK ;</span><br><span class="line">   <span class="keyword">int</span> WasNotified = <span class="number">0</span> ;</span><br><span class="line">   &#123; <span class="comment">// State transition wrappers</span></span><br><span class="line">     OSThread* osthread = Self-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">     <span class="function">OSThreadWaitState <span class="title">osts</span><span class="params">(osthread, <span class="literal">true</span>)</span></span>;</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line">       <span class="comment">// Thread is in thread_blocked state and oop access is unsafe.</span></span><br><span class="line">       jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (interruptible &amp;&amp; (Thread::<span class="built_in">is_interrupted</span>(THREAD, <span class="literal">false</span>) || HAS_PENDING_EXCEPTION)) &#123;</span><br><span class="line">           <span class="comment">// Intentionally empty</span></span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">if</span> (node._notified == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (millis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> () ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> (millis) ;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// were we externally suspended while we were waiting?</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">ExitSuspendEquivalent</span> (jt)) &#123;</span><br><span class="line">          <span class="comment">// TODO-<span class="doctag">FIXME:</span> add -- if succ == Self then succ = null.</span></span><br><span class="line">          jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="comment">// Exit thread safepoint: transition _thread_blocked -&gt; _thread_in_vm</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Node may be on the WaitSet, the EntryList (or cxq), or in transition</span></span><br><span class="line">     <span class="comment">// from the WaitSet to the EntryList.</span></span><br><span class="line">     <span class="comment">// See if we need to remove Node from the WaitSet.</span></span><br><span class="line">     <span class="comment">// We use double-checked locking to avoid grabbing _WaitSetLock</span></span><br><span class="line">     <span class="comment">// if the thread is not on the wait queue.</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Note that we don&#x27;t need a fence before the fetch of TState.</span></span><br><span class="line">     <span class="comment">// In the worst case we&#x27;ll fetch a old-stale value of TS_WAIT previously</span></span><br><span class="line">     <span class="comment">// written by the is thread. (perhaps the fetch might even be satisfied</span></span><br><span class="line">     <span class="comment">// by a look-aside into the processor&#x27;s own store buffer, although given</span></span><br><span class="line">     <span class="comment">// the length of the code path between the prior ST and this load that&#x27;s</span></span><br><span class="line">     <span class="comment">// highly unlikely).  If the following LD fetches a stale TS_WAIT value</span></span><br><span class="line">     <span class="comment">// then we&#x27;ll acquire the lock and then re-fetch a fresh TState value.</span></span><br><span class="line">     <span class="comment">// That is, we fail toward safety.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (node.TState == ObjectWaiter::TS_WAIT) &#123;</span><br><span class="line">         Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - unlink&quot;</span>) ;</span><br><span class="line">         <span class="keyword">if</span> (node.TState == ObjectWaiter::TS_WAIT) &#123;</span><br><span class="line">            <span class="built_in">DequeueSpecificWaiter</span> (&amp;node) ;       <span class="comment">// unlink from WaitSet</span></span><br><span class="line">            <span class="built_in">assert</span>(node._notified == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">            node.TState = ObjectWaiter::TS_RUN ;</span><br><span class="line">         &#125;</span><br><span class="line">         Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// The thread is now either on off-list (TS_RUN),</span></span><br><span class="line">     <span class="comment">// on the EntryList (TS_ENTER), or on the cxq (TS_CXQ).</span></span><br><span class="line">     <span class="comment">// The Node&#x27;s TState variable is stable from the perspective of this thread.</span></span><br><span class="line">     <span class="comment">// No other threads will asynchronously modify TState.</span></span><br><span class="line">     <span class="built_in">guarantee</span> (node.TState != ObjectWaiter::TS_WAIT, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     OrderAccess::<span class="built_in">loadload</span>() ;</span><br><span class="line">     <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">     WasNotified = node._notified ;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Reentry phase -- reacquire the monitor.</span></span><br><span class="line">     <span class="comment">// re-enter contended monitor after object.wait().</span></span><br><span class="line">     <span class="comment">// retain OBJECT_WAIT state until re-enter successfully completes</span></span><br><span class="line">     <span class="comment">// Thread state is thread_in_vm and oop access is again safe,</span></span><br><span class="line">     <span class="comment">// although the raw address of the object may have changed.</span></span><br><span class="line">     <span class="comment">// (Don&#x27;t cache naked oops over safepoints, of course).</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// post monitor waited event. Note that this is past-tense, we are done waiting.</span></span><br><span class="line">     <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_waited</span>()) &#123;</span><br><span class="line">       JvmtiExport::<span class="built_in">post_monitor_waited</span>(jt, <span class="keyword">this</span>, ret == OS_TIMEOUT);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (node._notified != <span class="number">0</span> &amp;&amp; _succ == Self) &#123;</span><br><span class="line">         <span class="comment">// In this part of the monitor wait-notify-reenter protocol it</span></span><br><span class="line">         <span class="comment">// is possible (and normal) for another thread to do a fastpath</span></span><br><span class="line">         <span class="comment">// monitor enter-exit while this thread is still trying to get</span></span><br><span class="line">         <span class="comment">// to the reenter portion of the protocol.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// The ObjectMonitor was notified and the current thread is</span></span><br><span class="line">         <span class="comment">// the successor which also means that an unpark() has already</span></span><br><span class="line">         <span class="comment">// been done. The JVMTI_EVENT_MONITOR_WAITED event handler can</span></span><br><span class="line">         <span class="comment">// consume the unpark() that was done when the successor was</span></span><br><span class="line">         <span class="comment">// set because the same ParkEvent is shared between Java</span></span><br><span class="line">         <span class="comment">// monitors and JVM/TI RawMonitors (for now).</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// We redo the unpark() to ensure forward progress, i.e., we</span></span><br><span class="line">         <span class="comment">// don&#x27;t want all pending threads hanging (parked) with none</span></span><br><span class="line">         <span class="comment">// entering the unlocked monitor.</span></span><br><span class="line">         node._event-&gt;<span class="built_in">unpark</span>();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">       <span class="built_in">post_monitor_wait_event</span>(&amp;event, <span class="keyword">this</span>, node._notifier_tid, millis, ret == OS_TIMEOUT);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">assert</span> (Self-&gt;_Stalled != <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">assert</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     ObjectWaiter::TStates v = node.TState ;</span><br><span class="line">     <span class="keyword">if</span> (v == ObjectWaiter::TS_RUN) &#123;</span><br><span class="line">         <span class="built_in">enter</span> (Self) ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">guarantee</span> (v == ObjectWaiter::TS_ENTER || v == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">ReenterI</span> (Self, &amp;node) ;</span><br><span class="line">         node.<span class="built_in">wait_reenter_end</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Self has reacquired the lock.</span></span><br><span class="line">     <span class="comment">// Lifecycle - the node representing Self must not appear on any queues.</span></span><br><span class="line">     <span class="comment">// Node is about to go out-of-scope, but even if it were immortal we wouldn&#x27;t</span></span><br><span class="line">     <span class="comment">// want residual elements associated with this thread left on any lists.</span></span><br><span class="line">     <span class="built_in">guarantee</span> (node.TState == ObjectWaiter::TS_RUN, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span>    (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span>    (_succ != Self , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   &#125; <span class="comment">// OSThreadWaitState()</span></span><br><span class="line"></span><br><span class="line">   jt-&gt;<span class="built_in">set_current_waiting_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">guarantee</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   _recursions = save;     <span class="comment">// restore the old recursion count</span></span><br><span class="line">   _waiters--;             <span class="comment">// decrement the number of waiters</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Verify a few postconditions</span></span><br><span class="line">   <span class="built_in">assert</span> (_owner == Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   <span class="built_in">assert</span> (_succ  != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">   <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SyncFlags &amp; <span class="number">32</span>) &#123;</span><br><span class="line">      OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// check if the notification happened</span></span><br><span class="line">   <span class="keyword">if</span> (!WasNotified) &#123;</span><br><span class="line">     <span class="comment">// no, it could be timeout or Thread.interrupt() or both</span></span><br><span class="line">     <span class="comment">// check for interrupt event, otherwise it is timeout</span></span><br><span class="line">     <span class="keyword">if</span> (interruptible &amp;&amp; Thread::<span class="built_in">is_interrupted</span>(Self, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">       <span class="built_in">TEVENT</span> (Wait - <span class="keyword">throw</span> IEX from epilog) ;</span><br><span class="line">       <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// <span class="doctag">NOTE:</span> Spurious wake up will be consider as timeout.</span></span><br><span class="line">   <span class="comment">// Monitor notify has precedence over thread interrupt.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notify方法的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::notify</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK_OWNER</span>();</span><br><span class="line">    <span class="comment">// 等待集合为空</span></span><br><span class="line">  <span class="keyword">if</span> (_WaitSet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Empty-Notify) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_PROBE</span>(notify, <span class="keyword">this</span>, <span class="built_in">object</span>(), THREAD);</span><br><span class="line">	<span class="comment">// 不同的调度策略（具体唤醒哪一个线程），使用调度策略将这个ObjectWaiter放置到EntryList</span></span><br><span class="line">  <span class="keyword">int</span> Policy = Knob_MoveNotifyee ;</span><br><span class="line"></span><br><span class="line">  Thread::<span class="built_in">SpinAcquire</span> (&amp;_WaitSetLock, <span class="string">&quot;WaitSet - notify&quot;</span>) ;</span><br><span class="line">  ObjectWaiter * iterator = <span class="built_in">DequeueWaiter</span>() ;</span><br><span class="line">  <span class="keyword">if</span> (iterator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">TEVENT</span> (Notify1 - Transfer) ;</span><br><span class="line">     <span class="built_in">guarantee</span> (iterator-&gt;TState == ObjectWaiter::TS_WAIT, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">guarantee</span> (iterator-&gt;_notified == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> (Policy != <span class="number">4</span>) &#123;</span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">     &#125;</span><br><span class="line">     iterator-&gt;_notified = <span class="number">1</span> ;</span><br><span class="line">     Thread * Self = THREAD;</span><br><span class="line">     iterator-&gt;_notifier_tid = <span class="built_in">JFR_THREAD_ID</span>(Self);</span><br><span class="line"></span><br><span class="line">     ObjectWaiter * List = _EntryList ;</span><br><span class="line">     <span class="keyword">if</span> (List != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (List-&gt;_prev == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (List-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (List != iterator, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">0</span>) &#123;       <span class="comment">// prepend to EntryList</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             List-&gt;_prev = iterator ;</span><br><span class="line">             iterator-&gt;_next = List ;</span><br><span class="line">             iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">1</span>) &#123;      <span class="comment">// append to EntryList</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CONSIDER:  finding the tail currently requires a linear-time walk of</span></span><br><span class="line">            <span class="comment">// the EntryList.  We can make tail access constant-time by converting to</span></span><br><span class="line">            <span class="comment">// a CDLL instead of using our current DLL.</span></span><br><span class="line">            ObjectWaiter * Tail ;</span><br><span class="line">            <span class="keyword">for</span> (Tail = List ; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">            <span class="built_in">assert</span> (Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            Tail-&gt;_next = iterator ;</span><br><span class="line">            iterator-&gt;_prev = Tail ;</span><br><span class="line">            iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">2</span>) &#123;      <span class="comment">// prepend to cxq</span></span><br><span class="line">         <span class="comment">// prepend to cxq</span></span><br><span class="line">         <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span> ;</span><br><span class="line">             _EntryList = iterator ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iterator-&gt;TState = ObjectWaiter::TS_CXQ ;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                ObjectWaiter * Front = _cxq ;</span><br><span class="line">                iterator-&gt;_next = Front ;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (iterator, &amp;_cxq, Front) == Front) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">if</span> (Policy == <span class="number">3</span>) &#123;      <span class="comment">// append to cxq</span></span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_CXQ ;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ObjectWaiter * Tail ;</span><br><span class="line">            Tail = _cxq ;</span><br><span class="line">            <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (iterator, &amp;_cxq, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (Tail-&gt;_next != <span class="literal">NULL</span>) Tail = Tail-&gt;_next ;</span><br><span class="line">                Tail-&gt;_next = iterator ;</span><br><span class="line">                iterator-&gt;_prev = Tail ;</span><br><span class="line">                iterator-&gt;_next = <span class="literal">NULL</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ParkEvent * ev = iterator-&gt;_event ;</span><br><span class="line">        iterator-&gt;TState = ObjectWaiter::TS_RUN ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        ev-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (Policy &lt; <span class="number">4</span>) &#123;</span><br><span class="line">       iterator-&gt;<span class="built_in">wait_reenter_begin</span>(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// _WaitSetLock protects the wait queue, not the EntryList.  We could</span></span><br><span class="line">     <span class="comment">// move the add-to-EntryList operation, above, outside the critical section</span></span><br><span class="line">     <span class="comment">// protected by _WaitSetLock.  In practice that&#x27;s not useful.  With the</span></span><br><span class="line">     <span class="comment">// exception of  wait() timeouts and interrupts the monitor owner</span></span><br><span class="line">     <span class="comment">// is the only thread that grabs _WaitSetLock.  There&#x27;s almost no contention</span></span><br><span class="line">     <span class="comment">// on _WaitSetLock so it&#x27;s not profitable to reduce the length of the</span></span><br><span class="line">     <span class="comment">// critical section.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::<span class="built_in">SpinRelease</span> (&amp;_WaitSetLock) ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iterator != <span class="literal">NULL</span> &amp;&amp; ObjectMonitor::_sync_Notifications != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ObjectMonitor::_sync_Notifications-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁升级与偏向锁"><a href="#锁升级与偏向锁" class="headerlink" title="锁升级与偏向锁"></a>锁升级与偏向锁</h3><p>随着JDK版本的不断更迭，底层对于synchronized关键字的实现方式也不断地在进行调整。在JDK1.5之前，要实现线程同步，只能通过synchronized关键字来实现，Java底层也是通过synchronized关键字来做到数据的原子性维护，synchronized关键字是JVM实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是由JVM帮助我们隐式实现的。从JDK1.5开始，并发包引入了Lock锁，Lock同步锁是基于Java来实现的，因此锁的获取与释放都是通过Java代码来实现与控制的，synchronized是基于底层操作系统Mutex Lock来实现的，每次对锁的获取与释放动作都会带来用户态与内核态之间的切换，这种切换会极大的增加系统的负担。在并发量较高时，也就是说锁的竞争比较激烈的时候，synchronized锁在性能上的表现就非常差。</p>
<p>从JDK1.6开始，synchronized锁的实现发生了很大的变化，JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁、轻量级锁、重量级锁等，从而减少锁的竞争锁带来的用户态与内核态之前的切换，这种锁的优化是通过Java对象头中的一些标志位来去实现的。对于锁的访问与改变，实际上都与Java对象头息息相关。</p>
<p>从JDK1.6开始，对象实例在堆当中会被划分为三个组成部分：对象头、实例数据与对齐填充。</p>
<p>对象头主要由3块内容来构成：</p>
<ol>
<li>Mark Word </li>
<li>指向类的指针</li>
<li>数组的长度</li>
</ol>
<p>其中Mark Word （它记录了对象、锁及垃圾回收相关的信息，在64位的JVM中，其长度也是64bit）的位信息包括了如下的组成部分：</p>
<ol>
<li>无锁标记</li>
<li>偏向锁标记</li>
<li>轻量级锁标记</li>
<li>重量级锁标记</li>
<li>GC标记</li>
</ol>
<p>对于synchronized锁来说，锁的升级主要是通过Mark Word中的锁的标志位与是否是偏向锁标志位来达成的；synchronized关键字锁对应的锁都是从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后则变成了重量级锁。</p>
<p>对于锁的演化来说，它会经历如下阶段：</p>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p>偏向锁：针对于一个线程来说，它的作用就是优化同一个线程多次获取一个锁的情况；如果一个synchronized方法被一个线程访问，那么这个方法所在的对象就会在其Mark Word中将偏向锁进行标记，同时还会有一个字段来存储该线程的ID；当这个线程再次访问同一个synchronized方法时，它会检查这个对象的Mark Word的偏向锁标记以及是否指向了其线程ID，如果是的话，那么该线程就无需进行管程（Monitor）了，而是直接进入到该方法体中。如果是另外一个线程访问这个synchronized方法，那么偏向锁的标记就会被去掉。</p>
<p>轻量级锁：若第一个线程已经获取到了当前对象的锁，这是第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程在争抢时，会发现该对象头中的Mark Word已经是偏向锁，但里面存储的线程ID不是自己（第一个线程），那么它会进行CAS（Compare and Swap），从而获取到锁，这里面存在两种情况：</p>
<ol>
<li>获取锁成功，那么它会直接将Mark Word中的线程ID由第一个线程变成自己（偏向锁标记位保持不变），这样该对象依然会保持偏向锁的状态</li>
<li>获取锁失败，表示这时可能会有多个线程同时在尝试争抢该对象的锁，那么这时偏向锁会进行升级，升级为轻量级锁</li>
</ol>
<p>自旋锁：若自旋失败（依然无法获取到锁），那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到Monitor（即内核态）。自旋最大的一个特点就是避免了线程从用户态进入到内核态。</p>
<p>重量级锁：线程最终从用户态进入到了内核态。</p>
<h3 id="锁粗化与锁消除"><a href="#锁粗化与锁消除" class="headerlink" title="锁粗化与锁消除"></a>锁粗化与锁消除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器对于锁的优化措施：JIT编译器（Just In Time编译器）可以在动态编译同步代码时，使用一种叫做逃逸分析的技术，来通过该项技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散布到其他线程当中，如果情况就是这样的话，那么JIT编译器在编译这个同步代码时就不会生成synchronized关键字所标识的锁的申请与释放机器码，从而消除了锁的使用流程，这就是锁的消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果object是成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下就发生了：锁粗化，JIT编译器在执行动态编译时，若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块合并为一个较大的同步块，这样做的好处在于线程在执行这些代码的时候，就无需频繁的申请与释放锁了，从而达到申请与释放锁一次，就可以执行完全部的同步代码块，从而提升了性能。</p>
<h3 id="死锁及死锁检测"><a href="#死锁及死锁检测" class="headerlink" title="死锁及死锁检测"></a>死锁及死锁检测</h3><ul>
<li>死锁：线程1等待线程2互斥持有的资源，而线程2也在等待线程1互斥持有的资源，两个线程都无法继续执行；</li>
<li>活锁：线程持续重试一个总是失败的操作，导致无法继续执行；</li>
<li>饿死：线程一直被调度器延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总是会有一个高优先级的线程可以执行，饿死也叫做无限延迟。</li>
</ul>
<p>首先来看一下可能会发生死锁的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest7</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myMethod1 invoked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myMethod2 invoked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest7 myTest7 = <span class="keyword">new</span> MyTest7();</span><br><span class="line">        Runnable runnable1 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                myTest7.method1();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable1, <span class="string">&quot;myThread1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                myTest7.method2();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable2, <span class="string">&quot;myThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行一段时间之后就发生死锁的现象，发生死锁之后可以使用JVM自带的一些工具来进行检测。</p>
<p>首先是jvisualvm:</p>
<p><img src="./assets/1605541454922.png" alt="1605541454922"></p>
<p>可以看到，已经检测到死锁的情况，点击线程Dump可以查看详情。</p>
<p><img src="./assets/1605541658677.png" alt="1605541658677"></p>
<p>除了使用可视化界面之外，也可以使用命令行的工具来进行检测死锁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\code\java8\jyc&gt;jps -l</span><br><span class="line">9104</span><br><span class="line">12212 concurrency2.MyTest7</span><br><span class="line">11656 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">16428 org.gradle.launcher.daemon.bootstrap.GradleDaemon</span><br><span class="line">3468 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure>

<p>可以看到运行我们程序的进行号为12212，继续使用jstack来查看当前线程的执行详情：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\code\java8\jyc&gt;jstack 12212</span><br><span class="line">2020-11-16 23:50:41</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.212-b10 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;JMX server connection timeout 18&quot; #18 daemon prio=5 os_prio=0 tid=0x0000000019fca800 nid=0x25ec in Object.wait() [0x000000001b9de000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at com.sun.jmx.remote.internal.ServerCommunicatorAdmin$Timeout.run(ServerCommunicatorAdmin.java:168)</span><br><span class="line">        - locked &lt;0x00000000d8408178&gt; (a [I)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;RMI Scheduler(0)&quot; #17 daemon prio=5 os_prio=0 tid=0x0000000019fc9800 nid=0x36a0 waiting on condition [0x000000001b8df000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000d8410188&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)</span><br><span class="line">        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;RMI TCP Accept-0&quot; #15 daemon prio=5 os_prio=0 tid=0x0000000019f5f000 nid=0x4270 runnable [0x000000001b6df000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.accept0(Native Method)</span><br><span class="line">        at java.net.DualStackPlainSocketImpl.socketAccept(DualStackPlainSocketImpl.java:131)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)</span><br><span class="line">        at java.net.PlainSocketImpl.accept(PlainSocketImpl.java:199)</span><br><span class="line">        - locked &lt;0x00000000d84182b0&gt; (a java.net.SocksSocketImpl)</span><br><span class="line">        at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">        at java.net.ServerSocket.accept(ServerSocket.java:513)</span><br><span class="line">        at sun.management.jmxremote.LocalRMIServerSocketFactory$1.accept(LocalRMIServerSocketFactory.java:52)</span><br><span class="line">        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.executeAcceptLoop(TCPTransport.java:405)</span><br><span class="line">        at sun.rmi.transport.tcp.TCPTransport$AcceptLoop.run(TCPTransport.java:377)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;DestroyJavaVM&quot; #13 prio=5 os_prio=0 tid=0x0000000002a6e000 nid=0x19c0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;myThread2&quot; #12 prio=5 os_prio=0 tid=0x000000001a17e000 nid=0x3290 waiting for monitor entry [0x000000001b58f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at concurrency2.MyTest7.method2(MyTest7.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$1(MyTest7.java:44)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$2/1418481495.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;myThread1&quot; #11 prio=5 os_prio=0 tid=0x000000001a17d800 nid=0x3b8c waiting for monitor entry [0x000000001b48f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at concurrency2.MyTest7.method1(MyTest7.java:15)</span><br><span class="line">        - waiting to lock &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$0(MyTest7.java:32)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$1/471910020.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #10 daemon prio=9 os_prio=0 tid=0x0000000019ebf000 nid=0x3194 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread3&quot; #9 daemon prio=9 os_prio=2 tid=0x0000000019e28800 nid=0x48c0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread2&quot; #8 daemon prio=9 os_prio=2 tid=0x0000000019e28000 nid=0x219c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread1&quot; #7 daemon prio=9 os_prio=2 tid=0x0000000019e26800 nid=0x39c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #6 daemon prio=9 os_prio=2 tid=0x0000000019e1f800 nid=0x22c waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x0000000019e1d800 nid=0x898 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x0000000019e1c800 nid=0x3174 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000019db1000 nid=0x40e4 in Object.wait() [0x000000001a38e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">        - locked &lt;0x00000000d84385e8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000019db0800 nid=0x23e4 in Object.wait() [0x000000001a28e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        - locked &lt;0x00000000d8430758&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=2 tid=0x0000000017fb8800 nid=0x1f84 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000003008000 nid=0x2d74 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x0000000003009800 nid=0x5374 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000300b000 nid=0x21ec runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000300c800 nid=0x4064 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#4 (ParallelGC)&quot; os_prio=0 tid=0x000000000300f000 nid=0x234c runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#5 (ParallelGC)&quot; os_prio=0 tid=0x0000000003011000 nid=0x2ea8 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#6 (ParallelGC)&quot; os_prio=0 tid=0x0000000003014000 nid=0x14a0 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#7 (ParallelGC)&quot; os_prio=0 tid=0x0000000003015800 nid=0x39d4 runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x0000000019ed4000 nid=0x1d40 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 232</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到一个Java级别的死锁</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;myThread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ee6c8 (object 0x00000000d84202f0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread1&quot;</span><br><span class="line">&quot;myThread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00000000030ed228 (object 0x00000000d8420300, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;myThread2&quot;:</span><br><span class="line">        at concurrency2.MyTest7.method2(MyTest7.java:23)</span><br><span class="line">        - waiting to lock &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$1(MyTest7.java:44)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$2/1418481495.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;myThread1&quot;:</span><br><span class="line">        at concurrency2.MyTest7.method1(MyTest7.java:15)</span><br><span class="line">        - waiting to lock &lt;0x00000000d8420300&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d84202f0&gt; (a java.lang.Object)</span><br><span class="line">        at concurrency2.MyTest7.lambda$main$0(MyTest7.java:32)</span><br><span class="line">        at concurrency2.MyTest7$$Lambda$1/471910020.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<h1 id="concurrent并发包"><a href="#concurrent并发包" class="headerlink" title="concurrent并发包"></a>concurrent并发包</h1><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="锁的机制与原理"><a href="#锁的机制与原理" class="headerlink" title="锁的机制与原理"></a>锁的机制与原理</h3><p>Lock是非常重要的顶级接口，接下来我们阅读一下关于它的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock implementations provide more extensive locking operations than can be obtained using synchronized </span><br><span class="line">methods and statements. They allow more flexible structuring, may have quite different properties, and </span><br><span class="line">may support multiple associated Condition objects.</span><br></pre></td></tr></table></figure>

<p>Lock实现了要比使用synchronized关键字修饰的方法及语句用途更为广泛的锁的操作，它们支持更为灵活的结构化，拥有很多不同的属性，支持多种相关联的Condition对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock </span><br><span class="line">provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all </span><br><span class="line">access to the shared resource requires that the lock be acquired first. However, some locks may allow </span><br><span class="line">concurrent access to a shared resource, such as the read lock of a ReadWriteLock.</span><br></pre></td></tr></table></figure>

<p>锁是一种多个线程对于一个共享资源的访问，通常情况下，一个锁会对共享资源提供一种排它性的访问，这意味着在同一个时刻，只能有一个线程获取到锁，其他线程必须要先获取到锁才能访问共享资源。然而，某些锁可以对于共享资源的并发访问，比如读锁中的ReadWriteLock（读写锁）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The use of synchronized methods or statements provides access to the implicit monitor lock associated </span><br><span class="line">with every object, but forces all lock acquisition and release to occur in a block-structured way: when </span><br><span class="line">multiple locks are acquired they must be released in the opposite order, and all locks must be released </span><br><span class="line">in the same lexical scope in which they were acquired.</span><br></pre></td></tr></table></figure>

<p>使用synchronized方法或者synchronized代码块提供了对于每一个对象的所关联的隐式的monitor对象的访问，但是它会强制所有锁的获取和释放都发生在块结构的方式中，当多个锁被获取的时候，必须要以相反的顺序释放，而且所有的锁必须以获取的相同的作用域释放掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While the scoping mechanism for synchronized methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</span><br></pre></td></tr></table></figure>

<p>虽然synchronized方法和代码块的作用域使得我们对于monitor锁的编程更加轻松，而且还会避免与锁相关的编码错误，但是存在一些场景，需要更加灵活的处理锁，比如某些算法需要并发的遍历被访问的数据结构，他们需要需要使用hand-over-hand或者chain locking：你需要首先获取到node A的锁，然后是node B的锁，紧接着释放A，然后获取到C，然后释放掉B，然后获取到D等等，Lock接口的实现使得这种技术的使用成为可能，它可以使得锁的获取和释放不在同一个作用域，也可以不再按照顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">With this increased flexibility comes additional responsibility. The absence of block-structured locking </span><br><span class="line">removes the automatic release of locks that occurs with synchronized methods and statements. In most </span><br><span class="line">cases, the following idiom should be used:</span><br></pre></td></tr></table></figure>

<p>但是如果我们不使用这种块结构的锁的话，就没法再使用synchronized提供的自动释放锁的功能，在大多数情况下按照如下的方式使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line"> l.lock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// access the resource protected by this lock</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   l.unlock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is </span><br><span class="line">executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is </span><br><span class="line">released when necessary.</span><br></pre></td></tr></table></figure>

<p>当加锁和解锁出现在不同的作用域当中，我们必须要非常小心的确保被执行的所有的代码都是在try-finally 或者try-catch的保护当中，从而保证锁在必要的时候可以被释放掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock implementations provide additional functionality over the use of synchronized methods and </span><br><span class="line">statements by providing a non-blocking attempt to acquire a lock (tryLock()), an attempt to acquire the </span><br><span class="line">lock that can be interrupted (lockInterruptibly, and an attempt to acquire the lock that can timeout </span><br><span class="line">(tryLock(long, TimeUnit)).</span><br></pre></td></tr></table></figure>

<p>Lock的实现相比于synchronized方法和语句的实现提供了一些额外的功能，它是通过一种非阻塞的方式获取到锁，并且还提供了获取锁的操作是可以被中断的，可以设置锁的超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Lock class can also provide behavior and semantics that is quite different from that of the implicit </span><br><span class="line">monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection. If an </span><br><span class="line">implementation provides such specialized semantics then the implementation must document those </span><br><span class="line">semantics.</span><br></pre></td></tr></table></figure>

<p>一个Lock的类还可以提供一些与隐式的monitor锁的完全不同的行为和语义，比如可以确保顺序性、可重入的使用或者死锁检测。如果一种实现实现了这种特殊的语气，那么实现就必须将这个语义清楚的记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Note that Lock instances are just normal objects and can themselves be used as the target in a </span><br><span class="line">synchronized statement. Acquiring the monitor lock of a Lock instance has no specified relationship with</span><br><span class="line">invoking any of the lock methods of that instance. It is recommended that to avoid confusion you never</span><br><span class="line">use Lock instances in this way, except within their own implementation.</span><br></pre></td></tr></table></figure>

<p>Lock实例仅仅是一个普通的对象而已，它们本身也可以被synchronized语句修饰，因为每个对象都会有一个与之相关的monitor存在，对于Lock实例对象也不例外，获取到Lock实例的monitor锁，与调用这个Lock方法之间没有什么特殊的关联关系。换言之，我们如果将一个Lock实例作为synchronized使用的对象的话，JVM会获取到Lock实例的monitor对象，它与Lock是两个层面的东西，推荐的做法是避免这种混淆，除了在它们自己的底层实现当中，永远不要通过这种方式使用Lock实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification (17.4 Memory Model) :</span><br></pre></td></tr></table></figure>

<p>所有的Lock的实现都必须强制与内建的monitor锁的内存同步语义是一致的，这一点是在Java语言规范中明确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A successful lock operation has the same memory synchronization effects as a successful Lock action.</span><br><span class="line">A successful unlock operation has the same memory synchronization effects as a successful Unlock action.</span><br></pre></td></tr></table></figure>

<ul>
<li>一个成功的加锁的操作与成功的synchronization拥有相同的同步效果</li>
<li>一个成功的释放锁的操作与成功的synchronization拥有相同的释放锁的效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unsuccessful locking and unlocking operations, and reentrant locking/unlocking operations, do not require any memory synchronization effects.</span><br></pre></td></tr></table></figure>

<p>（可重入的）加锁和释放锁不成功的操作，它们是不要求任何的内存同步的效果的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance </span><br><span class="line">characteristics, ordering guarantees, or other implementation qualities.</span><br></pre></td></tr></table></figure>

<p>获取lock的三种方式（可中断的，非可中断的，基于时间的）在性能上、顺序上的保证还有一些其他的特性上可能有所不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Further, the ability to interrupt the ongoing acquisition of a lock may not be available in a given Lock class. Consequently, </span><br><span class="line">an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, </span><br><span class="line">nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document </span><br><span class="line">the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined </span><br><span class="line">in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on </span><br><span class="line">method entry.</span><br></pre></td></tr></table></figure>

<p>进一步而言，这种能力可以中断锁获取可能不在给定的lock类当中，因此一种实现并不要求精确的定义相同的这种语义针对于这三种实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor </span><br><span class="line">responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after </span><br><span class="line">another action may have unblocked the thread. An implementation should document this behavior.</span><br></pre></td></tr></table></figure>

<p>由于中断通常意味着取消，因此检查这个中断通常不是一个频繁的操作，实现可以对一个中断进行响应，而不是等待一个正常的方法的返回。即便中断可能出现在另外一个动作之后有可能解锁这个线程，实现应该将这种行为记录下来。</p>
<p>以上是Lock接口的说明，接下来我们了解一下其中部分的核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock.</span><br><span class="line">If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until </span><br><span class="line">the lock has been acquired.</span><br></pre></td></tr></table></figure>

<p>该方法用于获取到锁，如果获取不到锁，当前的线程将会无法被用于线程调度，线程会进入睡眠状态，直到获取到锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and </span><br><span class="line">may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that</span><br><span class="line">Lock implementation.</span><br></pre></td></tr></table></figure>

<p>Lock实现可以检测锁的错误的使用，比如可能导致死锁的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock unless the current thread is interrupted.</span><br><span class="line">Acquires the lock if it is available and returns immediately.</span><br><span class="line">If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</span><br></pre></td></tr></table></figure>

<p>如果当前线程没有被中断就尝试获取到锁。如果锁是可以获取，就会立刻返回。如果这个锁是不可用的，那么当前线程也无法进行调度，而且会陷入到睡眠状态，直到下面两种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The lock is acquired by the current thread; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of lock acquisition is supported.</span><br></pre></td></tr></table></figure>

<ul>
<li>当前线程获取到锁</li>
<li>其他的线程中断了当前线程，而且锁获取的过程的是支持的中断的</li>
</ul>
<p>如果当前线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">has its interrupted status set on entry to this method; or</span><br><span class="line">is interrupted while acquiring the lock, and interruption of lock acquisition is supported,</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个方法的入口中拥有自己的被中断的状态</li>
<li>在获取锁的过程被中断了，并且这种在获取锁的时候的中断是被支持的</li>
</ul>
<p>那么 InterruptedException 会被抛出，并且当前线程的状态会被清理掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock only if it is free at the time of invocation.</span><br><span class="line">Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this </span><br><span class="line">method will return immediately with the value false.</span><br><span class="line">A typical usage idiom for this method would be:</span><br></pre></td></tr></table></figure>

<p>调用的时候，只有当可以获取的锁的时候，才获取到锁。如果获取可以获取到锁，就会立刻返回true，如果获取不到，就会立刻返回false，一中典型的使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"> <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// manipulate protected state</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// perform alternative actions</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This usage ensures that the lock is unlocked if it was acquired, and doesn&#x27;t try to unlock if the lock was not acquired.</span><br></pre></td></tr></table></figure>

<p>这种用法可以保证如果锁被获取了，那么锁是会被释放掉的，如果没有获取到锁，就不用去释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>这是另外一个重载的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Acquires the lock if it is free within the given waiting time and the current thread has not been interrupted.</span><br><span class="line">If the lock is available this method returns immediately with the value true. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</span><br></pre></td></tr></table></figure>

<p>在给定的等待时间之内，如果线程没有被中断并且锁是可以获取的，那么就获取到锁。如果锁拿到了，就会立刻返回true，如果没有获取到，那么线程就无法再进行调度，进入睡眠状态，直到如下三种情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The lock is acquired by the current thread; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of lock acquisition is supported; or</span><br><span class="line">The specified waiting time elapses</span><br></pre></td></tr></table></figure>

<ul>
<li>当前线程获取到了锁</li>
<li>其他线程中断了当前的线程，并且在锁获取的过程中，中断是被支持的</li>
<li>指定的时间到了</li>
</ul>
<p>如果获取到了锁则立刻返回true，如果当前线程被中断了，并且这种中断是被允许的，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">then InterruptedException is thrown and the current thread&#x27;s interrupted status is cleared.</span><br><span class="line">If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.</span><br></pre></td></tr></table></figure>

<p>当前线程就会抛出InterruptedException，并且当前线程的状态也会被清理掉。如果过了指定的时间，那么就会返回false，如果指定时间小于或者等于0，那么这个方法就会做任何的等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Lock implementation will usually impose restrictions on which thread can release a lock (typically only the holder of the lock can release it) and may throw an (unchecked) exception if the restriction is violated. Any restrictions and the exception type must be documented by that Lock implementation.</span><br></pre></td></tr></table></figure>

<p>该方法用来释放掉锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a new Condition instance that is bound to this Lock instance.</span><br><span class="line">Before waiting on the condition the lock must be held by the current thread. A call to Condition.await() will atomically release the lock before waiting and re-acquire the lock before the wait returns.</span><br></pre></td></tr></table></figure>

<p>它会返回一个新的绑定到当前Lock上的Condition实例，在等待condition之前，当前线程必须持有锁，调用Condition.await()会自动地释放掉锁。</p>
<p>接下来我们看一个有关于锁的使用的实际案例。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;myMethod1 invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果注释掉这行代码，程序仍然可以访问到此线程的锁，即上一行的输出会打印，但myMethod2因为获取不到锁，因此不会执行。</span></span><br><span class="line">            <span class="comment">// lock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;myMethod2 invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest1 myTest1 = <span class="keyword">new</span> MyTest1();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                myTest1.myMethod1();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                myTest1.myMethod2();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对myMethod2进行一定的改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.tryLock(<span class="number">800</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序就可以正常的往下执行，可以看出Lock为我们提供了一种更为优雅的方式来获取锁，本小节的最后，我们对于Lock和synchronized关键字的区别进行归纳总结。</p>
<ol>
<li>锁的获取方式：Lock是通过程序代码的方式由开发者手工获取，而synchronized是通过JVM来获取的（无需开发者干预）。</li>
<li>具体的实现方式：Lock是通过Java代码的方式来实现，synchronized是通过JVM底层来实现（无需开发者关注）。</li>
<li>锁的释放方式：Lock务必通过unlock()方法在finally块中手工释放，synchronized是通过JVM来释放（无需开发者关注）。</li>
<li>锁的具体类型：Lock提供了多种，如公平锁、非公平锁，synchronized与Lock都提供了可重入锁。</li>
</ol>
<h3 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h3><p>在Lock接口中，有一个方法的返回值是Condition，在之前的例子中，我们可以通过sychronized+wait+notify/notifyAll来实现多个线程之间的协调与通信，整个过程都是由JVM来帮助我们实现的，开发者无需（也无法）了解底层的实现细节，从JDK5开始，并发包提供了Lock，Condition(await与signal/signalAll)来实现多个线程之间的协调与通信，整个过程都是由开发者来控制的，相比于传统的方式，更加的灵活，功能也更加强大。接下来我们就来了解一下这个接口的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to </span><br><span class="line">give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary </span><br><span class="line">Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition</span><br><span class="line">replaces the use of the Object monitor methods.</span><br></pre></td></tr></table></figure>

<p>Condition本质上类似于Object对象的监控器的方法（wait,notify和notifyAll），可以让各种不同的对象拥有多个等待集合，是通过使用任意的一个Lock的实现将他们组合起来，我们会使用Lock来替代synchronized方法和代码块的使用，Condition来替换Object对象中的监控器方法的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Conditions (also known as condition queues or condition variables) provide a means for one thread to </span><br><span class="line">suspend execution (to &quot;wait&quot;) until notified by another thread that some state condition may now be </span><br><span class="line">true. Because access to this shared state information occurs in different threads, it must be protected,</span><br><span class="line">so a lock of some form is associated with the condition. The key property that waiting for a condition</span><br><span class="line">provides is that it atomically releases the associated lock and suspends the current thread, just like </span><br><span class="line">Object.wait.</span><br></pre></td></tr></table></figure>

<p>Conditions(也叫做条件队列或者条件变量)提供了一种让一个线程可以挂起执行（让线程进入等待状态）直到另外一个condition为true的线程通知当前线程的方式，由于对于共享的状态信息的访问是发生在不同的线程当中的，因此它必须受到保护，即Lock就一定要关联到一个某个Condition上面，一个关键的属性是，它会自动的释放掉关联的锁然后挂起当前的线程，就行Object.wait方法一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method.</span><br></pre></td></tr></table></figure>

<p>一个Condition实例会被天然的绑定到一个lock上面，要想获得一个特定的Lock实例对应的Condition实例的话，需要使用newCondition()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As an example, suppose we have a bounded buffer which supports put and take methods. If a take is </span><br><span class="line">attempted on an empty buffer, then the thread will block until an item becomes available; if a put is </span><br><span class="line">attempted on a full buffer, then the thread will block until a space becomes available. We would like to </span><br><span class="line">keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of </span><br><span class="line">only notifying a single thread at a time when items or spaces become available in the buffer. This can </span><br><span class="line">be achieved using two Condition instances.</span><br></pre></td></tr></table></figure>

<p>举个例子，加我们我们有一个有界的缓冲区，支持put和take方法，如果一个take尝试从空的缓冲区获取元素就会被阻塞，直到缓冲区中有新的元素，如果一个put尝试向一个满的缓冲区中添加元素，这个线程也会被阻塞，直到有可用的空闲空间为止，我们将会让等待的put线程和take线程放置在两个等待集合当中，这样我们就可以在条目存在或者空间存在的时候，只通知一个线程，这个是可以通过使用两个Condition实例来做到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Condition implementation can provide behavior and semantics that is different from that of the Object </span><br><span class="line">monitor methods, such as guaranteed ordering for notifications, or not requiring a lock to be held when</span><br><span class="line">performing notifications. If an implementation provides such specialized semantics then the </span><br><span class="line">implementation must document those semantics.</span><br></pre></td></tr></table></figure>

<p>Condition实现可以提供与Object的monitor方法是不一样的行为，比如对于通知的确定性的排序，或者在执行通知的时候不要求持有锁，如果某一个实现提供了这样一些专门化的语义，在实现的时候，需要在文档当中记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Note that Condition instances are just normal objects and can themselves be used as the target in a </span><br><span class="line">synchronized statement, and can have their own monitor wait and notification methods invoked. Acquiring</span><br><span class="line">the monitor lock of a Condition instance, or using its monitor methods, has no specified relationship </span><br><span class="line">with acquiring the Lock associated with that Condition or the use of its waiting and signalling methods. </span><br><span class="line">It is recommended that to avoid confusion you never use Condition instances in this way, except perhaps</span><br><span class="line">within their own implementation.</span><br></pre></td></tr></table></figure>

<p>注意Condition实例仅仅就是一个普通的obeject对象，它们自己也可以使用sychronized代码块当中，并且拥有自己的monitor方法，比如wait和notification方法。使用Condition实例获取锁对象，其中的waiting和signalling方法与monitor对象中的方法是没有任何关系的，推荐的做法是避免这种混淆，永远不应该在除了内部实现的地方外使用这种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">When waiting upon a Condition, a &quot;spurious wakeup&quot; is permitted to occur, in general, as a concession to the underlying </span><br><span class="line">platform semantics. This has little practical impact on most application programs as a Condition should always be waited upon </span><br><span class="line">in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of </span><br><span class="line">spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a </span><br><span class="line">loop.</span><br></pre></td></tr></table></figure>

<p>当我们在等待一个Condition为真的时候，一个假的唤醒是允许发生的，通常情况下，作为平台的一种底层的语义，这种对于大多数的程序不会产生什么实际的影响，因为Condition总是在一个while循环当中去等待，去测试这个被唤醒的条件是否被满足了。实现可以自由的移除这种假的唤醒的可能性，但是推荐的做法是开发者确保程序总是能够执行的并且总是放在循环当中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation</span><br><span class="line">on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and </span><br><span class="line">maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread </span><br><span class="line">may not always be feasible to implement on all platforms.</span><br></pre></td></tr></table></figure>

<p>三种Condition等待的方式（可中断的、不可中断的、基于时间的）在不同的平台上的实现和性能是不一样的，特别的，我们很难去提供这些特性，并且维护具体的语义，比如说排序的保证，更进一步，这种中断进程的挂起实际是要想在所有平台都实现是难做到非常灵活的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of </span><br><span class="line">waiting, nor is it required to support interruption of the actual suspension of the thread</span><br></pre></td></tr></table></figure>

<p>因此，一个实现针对于这几种方式的等待并不要求精确的定义相同的语义或者相同的保证，同样的，也不要求线程实际的挂起的中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface.</span><br></pre></td></tr></table></figure>

<p>实现可以被要求清晰的定义这些语义和保证由每一个等待方法，当一个实现并不支持线程中断的话，必须要遵循定义在这个接口中中断的语义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor </span><br><span class="line">responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after</span><br><span class="line">another action that may have unblocked the thread. An implementation should document this behavior.</span><br></pre></td></tr></table></figure>

<p>由于中断通常暗示着一种取消，因此检查这个中断不是一个频繁的操作，实现可以自由决定，它可以去响应中断，而非正常的这种方法返回，即便是中断是发生在另一个动作之后，实现需要把这个行为记录下来。</p>
<p>以上就是Condition类的所有的说明，接下来我们来阅读一下Condition接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted.</span><br></pre></td></tr></table></figure>

<p>这个方法会使得当前线程进入等待状态，直到signal方法被调用或者被中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling </span><br><span class="line">purposes and lies dormant until one of four things happens:</span><br></pre></td></tr></table></figure>

<p>调用了await方法之后，与Condition所关联的lock会被自动的释放，当前的线程将无法进行线程调度，并且进入休眠状态，直到下面的四种情况之一发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be </span><br><span class="line">awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>

<ul>
<li>另外一个线程调用了当前线程的signal方法，并且当前的线程恰好是被选中的线程；</li>
<li>另外一个线程调用了signalAll方法；</li>
<li>另外一个线程中断了当前的线程，并且线程是可以中断的；</li>
<li>虚假唤醒出现了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When </span><br><span class="line">the thread returns it is guaranteed to hold this lock.</span><br></pre></td></tr></table></figure>

<p>在以上的四种情况中，在调用了await方法能够返回之前，当前的线程必须要重新获取到与这个condition对应的lock。当线程返回的时候，我们可以保证获取到了lock。</p>
<p>如果当前的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">has its interrupted status set on entry to this method; or</span><br><span class="line">is interrupted while waiting and interruption of thread suspension is supported,</span><br></pre></td></tr></table></figure>

<ul>
<li>当前的线程在进入到这个方法的时候，已经设置了中断的状态；</li>
<li>等待的时候被中断了，并且线程的中断是支持的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">then InterruptedException is thrown and the current thread&#x27;s interrupted status is cleared. It is not specified, in the first</span><br><span class="line">case, whether or not the test for interruption occurs before the lock is released.</span><br></pre></td></tr></table></figure>

<p>就会抛出InterruptedException异常，当前线程的状态也会被清理掉，在一种情况下，在释放锁之前，无论是否测试了中断，都是如此。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the </span><br><span class="line">implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as </span><br><span class="line">IllegalMonitorStateException) and the implementation must document that fact.</span><br></pre></td></tr></table></figure>

<p>当前线程在调用await方法的时候，被假定要持有与Condition相关联的锁，这个取决于具体的实现是否要满足这种条件，如果不满足，应该如何应对，典型的，可以抛出异常（IllegalMonitorStateException），实现必须要将这个情况记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the </span><br><span class="line">implementation must ensure that the signal is redirected to another waiting thread, if there is one</span><br></pre></td></tr></table></figure>

<p>实现也可以选择去响应一个中断而不是通常的方法的返回，在这种情况下，如果有的另外一个线程，实现也必须signal会重定向到另外一个线程。</p>
<p>接下来是awaitUninterruptibly方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>awaitUninterruptibly方法会使得线程进入等待状态，直到下面三种情况之一发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>

<p>与await方法唯一不同的是，这个方法并不回应中断。</p>
<p>接下来是awaitNanos方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses.</span><br></pre></td></tr></table></figure>

<p>调用awaitNanos，会导致当前的线程进入等待状态直到被signal或者被中断或者指定的时间已经过去了，直到下面五种情况有一个发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</span><br><span class="line">Some other thread invokes the signalAll method for this Condition; or</span><br><span class="line">Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</span><br><span class="line">The specified waiting time elapses; or</span><br><span class="line">A &quot;spurious wakeup&quot; occurs.</span><br></pre></td></tr></table></figure>

<p>可以看到与await方法不同的地方在于，指定的等待时间已经过去了，就会返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The method returns an estimate of the number of nanoseconds remaining to wait given the supplied nanosTimeout value upon</span><br><span class="line">return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-</span><br><span class="line">wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the </span><br><span class="line">following form:</span><br></pre></td></tr></table></figure>

<p>这个方法会返回一个近似的纳秒的时间，这个时间是给定时间的剩余的时间，还有可能返回的是一个小于或者等于零的值，这意味着超时了。这个值可以用来是否以及多长时间重新的等待，典型的使用场景是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aMethod</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionBeingWaitedFor()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      nanos = theCondition.awaitNanos(nanos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss </span><br><span class="line">would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when </span><br><span class="line">re-waits occur.</span><br></pre></td></tr></table></figure>

<p>这个方法需要的是一个纳秒的参数来去避免一个截断上的错误再去返回剩余时间，使用它来确保整体的等待时间，这种精度的损失可能对于程序员而言是非常困难的。</p>
<p>接下来是另外一个await方法的重载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. This method is behaviorally equivalent to:</span><br><span class="line">  awaitNanos(unit.toNanos(time)) &gt; 0</span><br></pre></td></tr></table></figure>

<p>这个方法实际上是awaitNanos方法的一个变形，实际上的实现等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">awaitNanos(unit.toNanos(time)) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>接下来是awaitUntil方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>一种典型的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">aMethod</span><span class="params">(Date deadline)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> stillWaiting = <span class="keyword">true</span>;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!conditionBeingWaitedFor()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!stillWaiting)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      stillWaiting = theCondition.awaitUntil(deadline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上都是针对于await方法的一些变形和衍生，本质上并没有什么差别。</p>
<p>接下来是signal方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wakes up one waiting thread.</span><br><span class="line">If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock </span><br><span class="line">before returning from await.</span><br></pre></td></tr></table></figure>

<p>该方法用于唤醒一个等待的线程，如果有多个线程在condition上等待，那么就会选择其中的一个进行唤醒，在返回await方法之前，被唤醒的线程必须获取到lock，而具体唤醒哪一个线程取决于具体的实现。</p>
<p>最后是signalAll方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wakes up all waiting threads.</span><br><span class="line">If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from await.</span><br></pre></td></tr></table></figure>

<p>该方法会唤醒所有处于等待状态的线程，如果有多个线程在condition上等待，那么它们都会被唤醒。每个线程都要获取到lcok才能从awit方法返回。</p>
<h3 id="Condition实践"><a href="#Condition实践" class="headerlink" title="Condition实践"></a>Condition实践</h3><p>Thread.sleep与await（或是Object的wait方法）的本质区别：sleep方法本质上不会释放锁，而await会释放锁，并且在signal后，还需要重新获取到锁才能继续执行（该行为与Object的wait方法完全一致）。</p>
<p>接下来我们通过一个具体的例子来了解Condition的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] elements = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notEmptyCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition notFullCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组中已有元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放置元素索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取元素索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放置元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 需要放置的目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String element)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.elementCount == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                notFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            elements[putIndex] = element;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++putIndex == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                putIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++elementCount;</span><br><span class="line">            System.out.println(<span class="string">&quot;put method: &quot;</span> + Arrays.toString(elements));</span><br><span class="line">            notEmptyCondition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取元素的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmptyCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            String element = elements[takeIndex];</span><br><span class="line">            elements[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++takeIndex == <span class="keyword">this</span>.elements.length) &#123;</span><br><span class="line">                takeIndex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --elementCount;</span><br><span class="line">            System.out.println(<span class="string">&quot;take method: &quot;</span> + Arrays.asList(elements));</span><br><span class="line">            notFullCondition.signal();</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写入口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BoundedContainer boundedContainer = <span class="keyword">new</span> BoundedContainer();</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                boundedContainer.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start());</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                boundedContainer.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put method: [hello, null, null, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, null, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, null, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, null, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, null, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, null, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, null, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, null, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, hello, null]</span><br><span class="line">put method: [hello, hello, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, hello, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, hello, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, hello, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, hello, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, hello, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, hello, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, hello, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, hello, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, null, hello]</span><br><span class="line">take method: [null, null, null, null, null, null, null, null, null, null]</span><br></pre></td></tr></table></figure>

<h3 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h3><p>volatile本身的含义的是不稳定的意思，总体而言，volitle关键字主要有三方面的作用：</p>
<ol>
<li>实现long/double类型变量的原子操作</li>
<li>防止指令重排序</li>
<li>实现变量的可变性</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2020/07/13/Functionalprogramming/</url>
    <content><![CDATA[<p>==函数式编程==</p>
<span id="more"></span>

<h2 id="函数式编程初识"><a href="#函数式编程初识" class="headerlink" title="函数式编程初识"></a>函数式编程初识</h2><p>JDK8或者说Java8是目前企业开发中最常用的JDK版本，Java8可谓Java语言历史上变化最大的一个版本，其承诺要调整Java编程向着函数式风格迈进，这有助于编写出更为简洁、表达力更强，并且在很多情况下能够利用并行运行的代码。</p>
<p>但是很多人在使用Java8的时候，还是使用传统的面向对象的编程方式，这样在使用Java8的好处也仅仅停留在JVM带来的性能上的提升，而事实上Java8的新特性可以极大提升我们的开发效率，面向函数式编程也是将来编程语言的重要趋势，可以说，学习函数式编程风格，刻不容缓。</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>在以往的使用传统面向对象的编程中，我们不得不这样编写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">anonymousTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        JFrame jFrame = <span class="keyword">new</span> JFrame(<span class="string">&quot;My JFrame&quot;</span>);</span><br><span class="line">        JButton jButton = <span class="keyword">new</span> JButton(<span class="string">&quot;My Button&quot;</span>);</span><br><span class="line">        jButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Button Pressed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        jFrame.add(jButton);</span><br><span class="line">        jFrame.pack();</span><br><span class="line">        jFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码我们实际上需要的其实只有System.out.println(“Button Pressed”)这一行，但却不得不编写很多没有实际意义的代码，如果改用函数式风格编程，我们的代码就变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">anonymousTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        JFrame jFrame = <span class="keyword">new</span> JFrame(<span class="string">&quot;My JFrame&quot;</span>);</span><br><span class="line">        JButton jButton = <span class="keyword">new</span> JButton(<span class="string">&quot;My Button&quot;</span>);</span><br><span class="line">        jButton.addActionListener(e -&gt; System.out.println(<span class="string">&quot;Button Pressed&quot;</span>));</span><br><span class="line"></span><br><span class="line">        jFrame.add(jButton);</span><br><span class="line">        jFrame.pack();</span><br><span class="line">        jFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，瞬间代码的易读性提高了很多。</p>
<p>再比如我们经常会用到的创建线程的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czxy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by $&#123;sunxin&#125; on 2019/3/7</span></span><br><span class="line"><span class="comment"> * Lambda可以简循环遍历的写法，不是一般的简化，少些很多代码，简化创建线程的代码，简化以后的代码很少，不易懂，像前端javaScrpit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     Lambda 在创建线程方面可以简化写法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//原来的写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取执行前的毫秒值</span></span><br><span class="line">            <span class="keyword">long</span> old = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//执行一百千次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">100000</span>; a++) &#123;</span><br><span class="line">                <span class="comment">//原来的方式创建线程 实现Runnable接口 重写run方法</span></span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取执行后的毫秒值</span></span><br><span class="line">            <span class="keyword">long</span> newTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//获得消耗的时间</span></span><br><span class="line">            <span class="keyword">long</span> i = newTime - old;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建100000个花费的总毫秒值&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用Lambda表达式的新写法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//获取执行前的毫秒值</span></span><br><span class="line">        <span class="keyword">long</span> old1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a =<span class="number">0</span>;a&lt;<span class="number">100000</span>;a++)&#123;</span><br><span class="line">            Thread threadLambda = <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;使用Lambda创建了线程了&quot;</span>));</span><br><span class="line">            threadLambda.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取执行后的毫秒值</span></span><br><span class="line">        <span class="keyword">long</span> newTime1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//获得消耗的时间</span></span><br><span class="line">        <span class="keyword">long</span> i1 = newTime1 - old1;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda创建100000个花费的总毫秒值&quot;</span>+i1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，Lambda表达式在简化代码上，是非常有效的，Lambda表达式看起来特别像是原来Java中匿名内部类的一种特殊写法，对于初学者而言，暂时不妨可以认为Lambda表达式就是匿名内部类的一种新的写法，或者说是一种语法糖，但其实两者有着本质的区别，Lambda表达式就是一种全新的语法。</p>
<p>这里通过一个例子来说明Lambda表达式和匿名内部类的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    Runnable r1 = () -&gt; System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LambdaTest lambdaTest = <span class="keyword">new</span> LambdaTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(lambdaTest.r1);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(lambdaTest.r2);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream2.LambdaTest@362872a1</span><br><span class="line">Stream2.LambdaTest$1@60c8c409</span><br></pre></td></tr></table></figure>

<p>首先来看第二行，它表示当前对象指的是LambdaTest$1，在Java中表示匿名内部类会使用类名称+”$”+顺序的方式来表示，”@”后面的表示类的哈希值，而第一个Lamda表达式所打印的就是当前类LambdaTest的地址，这说明使用Lambda表达式的这种方式与它所在的类是同一个作用域。通过这个例子说明了Lambda表达式与匿名内部类有着本质的区别，两者是完全不同的，并不是匿名内部类的语法糖或者另一种表达形式，只不过在某些场景下，可以使用Lambda表达式来替代匿名内部类完成相同的功能。</p>
<p>而使用Lambda表达式所带来的好处其实远不止简化代码，它还可以为我们带来代码执行效率上的提升，所以，无论是处于开发效率，还是代码的执行速度上来看，都应该使用Lambda表达式，在后面的文章中，我们首先认识一下函数式编程中两个核心的概念Lambda表达式和Stream。</p>
<h3 id="Lambda表达式和Stream"><a href="#Lambda表达式和Stream" class="headerlink" title="Lambda表达式和Stream"></a>Lambda表达式和Stream</h3><p>Lambda表达式与Stream是java8中新增加的重要新特性，Lambda表达式与Stream相互配合，可以非常高效的处理一些集合的运算。</p>
<p>我们首先从遍历打印集合中元素这样非常常见的例子开始，以往遍历集合通常的做法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>或者使用传统的for循环来遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Lambda表达式我们可以将上述代码优雅的表示为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);\</span><br><span class="line">        </span><br><span class="line">        list.forEach((String x) -&gt; System.out.println(x));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，对于变量前面的类型，也是可以省略的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(x-&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译器可以自动推断出当前遍历集合当前元素的类型，但并不是在所有的场景下，编译器都可以自动推断类型，在后续的文章中，我们就会遇到编译器无法自动推断，需要我们手动声明变量类型的情况。</p>
<p>这里我们先不去考虑Lambda表达式具体的语法，先从直观的角度来感受函数式编程带来的好处，原本三行的代码现在仅仅需要一行就能实现，如果使用方法引用甚至能够让代码变的更加简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::</span><br></pre></td></tr></table></figure>

<p>也是java8中新增的一个语法糖。后续的文章我们有专门的篇幅来介绍方法引用，使用方法引用可以写出更加简洁优雅的代码。</p>
<p>看了这么几个例子，你可能很疑惑，到底什么是Lambda表达式呢？<br>在回答这个问题之前，我们首先需要了解我们为什么需要需要Lambda表达式。</p>
<p>在以往的Java中，方法可以参数的传递总共有两种，一种是传递值，另有一种是传递引用，或者说对象的地址，但是我们无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法，而在其他语言中，比如面向函数式编程语言JavaScript中，函数的参数是一个函数，返回值是另一个函数的情况是非常常见的（回调函数）<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">images_upload_handler: <span class="function"><span class="keyword">function</span>(<span class="params">blobInfo, success, failure</span>) </span>&#123;</span><br><span class="line">       success(...)</span><br><span class="line">       failure(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数总共接收三个参数，第一个参数就是一个普通的变量，success就是这个函数执行成功的回调函数，failure就是这个函数执行失败的回调函数。</p>
<p>可以说，JavaScript是一门非常典型的函数式语言。而使用Lambda表达式就可以实现传递行为这种高阶函数（参数可以接收行为的方法们就称这个方法为高阶函数）的使用。</p>
<p>当然Lambda表达式肯定不止只是能用来遍历集合这个简单，实际上，更多的情况下，我们都是需要配合Stream（流）来实现各种各样的操作。对于前面使用Lambda表达式来实现集合遍历的例子还可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">        </span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来只是增加了一步，将list这个集合转化为了Stream，但是两者的实现有着本质的区别。我们可以简单的了解一下他们之前的区别。<br>对于第一种，</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b964aac39b7b7?w=973&h=519&f=png&s=54757"><br>可以看到list.forEach实际上是调用Iterable这个类中jdk1.8新增的forEach方法，我们都知道List本身继承了Collection集合接口，而Collection接口又继承了Iterable这个类，所以可以完成调用，方法实现本身并没有特别复杂的地方，其实本质上看起来和我们传统的使用迭代器的方式并没有区别，接下来，我们查看一下第二种方式：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b969f366bdfc9?w=1049&h=416&f=png&s=60500"><br>首先同样的是在Collection接口中新增加了一个default method（我们称之为默认方法），在jdk1.8中接口是又具体的方法实现，实际上对于java这一门非常庞大臃肿的语言，为了向函数式编程迈进，jdk的设计者匠心独具，设计非常巧妙。这个方法将返回了一个新的对象Stream，并且调用了StreamSupport这个类中的stream（）方法：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/8/170b970249e81bcc?w=983&h=207&f=png&s=28200"><br>追踪下去，我们也可以看到，同样的也是一个名叫forEach的方法，但其实这里的forEach()方法与之前的forEach（）方法存在本质的差别，这里的forEach实际上表示一种终止操作，而jdk会在集合进行流操作的时候，调用终止操作。</p>
<p>在这两个方法中都接受一个Consumer&lt;? super T&gt; action 这样的一个参数，实际上，对于java而言，为了实现函数式编程，java引入了一个全新的概念：函数式接口，它是java实现整个函数式编程的手段，也是函数式编程中一个及其重要的概念，这个概念会贯穿整个函数式编程的全过程，理解了函数式接口，才能Lambda表达式真正的含义，接下来的时间，我们非常有必要首来认识一下，什么是函数式接口。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是函数式编程中最重要的概念，函数式编程与传统的编码方式相比最明显的区别就是，它允许把函数（或者说表达式）当成参数传递给另一个函数，在其他编程语言中，Lambda表达式的类型是函数，但在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象–函数式接口（functional interface）。</p>
<h3 id="函数式接口定义"><a href="#函数式接口定义" class="headerlink" title="函数式接口定义"></a>函数式接口定义</h3><p>在之前的这个例子中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击箭头就会进入到一个接口当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个接口上有一个@FunctionInterface的注解，点击这个注解进入，就可以看到这样一段JavaDoc:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An informative annotation type used to indicate that an interface</span></span><br><span class="line"><span class="comment"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class="line"><span class="comment"> * defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class="line"><span class="comment"> * an interface declares an abstract method overriding one of the</span></span><br><span class="line"><span class="comment"> * public methods of &#123;<span class="doctag">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count</span></span><br><span class="line"><span class="comment"> * since any implementation of the interface will have an</span></span><br><span class="line"><span class="comment"> * implementation from &#123;<span class="doctag">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class="line"><span class="comment"> * required to generate an error message unless:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class="line"><span class="comment"> * definition of a functional interface as a functional interface</span></span><br><span class="line"><span class="comment"> * regardless of whether or not a &#123;<span class="doctag">@code</span> FunctionalInterface&#125;</span></span><br><span class="line"><span class="comment"> * annotation is present on the interface declaration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.3.2. The Class Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.8 Functional Interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们一行一行来仔细阅读一下这段文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An informative annotation type used to indicate that an interface</span><br><span class="line">type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span><br><span class="line">defined by the Java Language Specification.</span><br></pre></td></tr></table></figure>

<p>这里说，@FunctionInterface这个注解，它使用Java语言规范定义，使用通知性的annotation,来声明函数式接口，换言之，如果一个接口上使用了@FunctionInterface这个注解，那么这个接口就是函数式接口。</p>
<p>那么到底什么是函数式接口呢？继续往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Conceptually, a functional interface has exactly one abstract</span><br><span class="line">method.  Since &#123;@linkplain java.lang.reflect.Method#isDefault()</span><br><span class="line">default methods&#125; have an implementation, they are not abstract.  If</span><br><span class="line">an interface declares an abstract method overriding one of the</span><br><span class="line">public methods of &#123;@code java.lang.Object&#125;, that also does &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count since any implementation of the interface will have an implementation from &#123;@code java.lang.Object&#125; or elsewhere.</span><br></pre></td></tr></table></figure>

<p>一个函数式接口，它只有一个精确的抽象方法，也就是说，有且仅有一个抽象方法，那么这个接口就被称为函数式接口（在jdk8中，除了抽象方法外还可以定义default method和static method，不一定都是抽象方法），并且如果这个抽象方法是Object类中的方法，不会计入这个接口的抽象方法数量。需要注意的是，可以通过Lambda表达式来创建，方法引用来创建，或者构造方法的引用来创建函数式接口的实例。</p>
<p>关于Lambda表达式的创建会在后续的文章中详细讲解，这里只需要大概了解函数式接口实例创建的方式有这么三种。我们继续往下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Note that instances of functional interfaces can be created with</span><br><span class="line">lambda expressions, method references, or constructor references.</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;If a type is annotated with this annotation type, compilers are</span><br><span class="line">required to generate an error message unless:</span><br><span class="line"> </span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span><br><span class="line">&lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;p&gt;However, the compiler will treat any interface meeting the</span><br><span class="line">definition of a functional interface as a functional interface</span><br><span class="line">regardless of whether or not a &#123;@code FunctionalInterface&#125;</span><br><span class="line">annotation is present on the interface declaration.</span><br></pre></td></tr></table></figure>

<p>如果一个接口上有@FunctionInterface这个注解，如果不满足以下情况编译器会报错：</p>
<ul>
<li>被注解的是一个接口类型，而不是一个注解类型，而是枚举或者类；</li>
<li>被注解的类型满足函数式接口的定义；</li>
</ul>
<p>例如，创建线程时需要用到的Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个接口从JDK8开始就加上了@FunctionalInterface这个注解，换句话说，Runnable接口现在变成了函数式接口，我们可以通过Lambda表达式来创建Runnable接口的实例。</p>
<p>在上面的文档中，还有最后一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;However, the compiler will treat any interface meeting the</span><br><span class="line">definition of a functional interface as a functional interface</span><br><span class="line">regardless of whether or not a &#123;@code FunctionalInterface&#125;</span><br><span class="line">annotation is present on the interface declaration</span><br></pre></td></tr></table></figure>

<p>然而，编译器其实会自动为满足函数式接口定义的接口添加@FunctionalInterface注解，也就是说，如果一个接口满足了函数式接口的定义，即便我们没有给他加上@FunctionalInterface这个注解，编译器会自动将它看成是函数式接口。</p>
<p>总的来说，关于函数式接口的定义如下：</p>
<p>1.如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口<br>2.如果我们在某个接口上声明了FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口<br>3.如果某个接口只有一个抽象方法，但我们并没有对该接口声明FunctionalInterface注解，编译器依旧会将该接口看作是函数式接口。</p>
<p>再以这个接口为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个接口中，除了一个抽象方法accept()方法外，还有一个default默认方法andThen()，但是总的来说还是只有一个抽象方法，所以满足函数式接口的定义。</p>
<p>再比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，这个接口中只有一个抽象方法test()，除此之外，有3个default默认方法，有一个static方法，因此同样满足函数式接口的定义。</p>
<p>再比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口中看起来有两个抽象方法，但toString()方法是基类Object中的方法，因此在检查函数式接口的定义的时候，它并不算数，因为Object类是所有类的父类，所有的类默认已经有了这个方法，如果算的话，其实是没有意义的，所以在定义函数式接口的时候，Object类中方法并不会对函数式接口的方法的数量变化。</p>
<p>在JDK8中的提供了大量的现成的函数式接口供我们使用，以之前我们使用forEach()为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实forEach()方法接收的函数式接口就是我们上面举得第一个例子Consumer，然后调用Consumer接口中的accept方法，诸多的函数式接口，为我们方便的传递各种不同需求的行为提供了可能。</p>
<h3 id="为什么是函数式接口？"><a href="#为什么是函数式接口？" class="headerlink" title="为什么是函数式接口？"></a>为什么是函数式接口？</h3><p>在前面我们了解了函数式接口的概念之后，我们来具体看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个接口，MyInterface，这个接口中有两个抽象方法，但由于toString()是继承自Obeject类中的方法，所以并不会对这个接口的抽象方法的总数有影响，还是只有一个抽象方法，那么显然，它满足函数式接口的定义。</p>
<p>首先我们使用传统的匿名内部类的方式来实现MyInterface中的test()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        myInterface.test();</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionalInterfaceTest functionalInterfaceTest = <span class="keyword">new</span> FunctionalInterfaceTest();</span><br><span class="line">        functionalInterfaceTest.MyTest(<span class="keyword">new</span> MyInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;myTest&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyInterface既然满足函数式接口的定义，那么就意味着我们可以使用Lambda表达式的方式来创建MyInterface的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        myInterface.test();</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionalInterfaceTest functionalInterfaceTest = <span class="keyword">new</span> FunctionalInterfaceTest();</span><br><span class="line">        functionalInterfaceTest.MyTest(() -&gt; System.out.println(<span class="string">&quot;myTest&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种写法的运行结果完全是等价的，编译器会自动根据上下文，来推测出 functionalInterfaceTest.MyTest()中需要接收的参数的类型，也就是说，() -&gt; System.out.println(“myTest”)就是MyInterface 的一个实例，由于函数式接口中只会有一个抽象方法，那么对于这个Lambda表达式而言，箭头左边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的参数，右边的部分，一定就是MyInterface 这个接口中唯一的抽象方法test()的实现，由于test()方法的参数是空值，所以左边的括号是空值。</p>
<p>这样看起来，其实MyInterface 这个接口中的抽象方法，具体叫什么名字，反而没有那么重要了，当然虽然这个函数的名字我们并不会直接去调用，但在起名字的时候，最好还是要有意义。</p>
<p>可能初学者并不能直观的认识到() -&gt; System.out.println(“myTest”)表达的具体含义，我们可以换一种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        myInterface.test();</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionalInterfaceTest functionalInterfaceTest = <span class="keyword">new</span> FunctionalInterfaceTest();</span><br><span class="line">        MyInterface myInterface = () -&gt; System.out.println(<span class="string">&quot;myTest&quot;</span>)</span><br><span class="line">        functionalInterfaceTest.MyTest(myInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的效果是完全等价的，使用这种写法，我们就更能直观的体会到，() -&gt; System.out.println(“myTest”)其实就是MyInterface的一个具体实现。</p>
<p>前面我们提到过，在Java中，Lambda表达式需要依赖于函数式接口这样一种特殊的形式，所以为什么是函数式接口呢？或者说为什么需要函数式接口呢？简而言之，Java是纯面向对象的语言，方法无法脱离类或者接口单独存在，因此在Java中，函数式编程必须依附这样一类特殊的对象：函数式接口。</p>
<p>实际上，对于一个特定的Lambda表达式是什么类型的，是需要上下文才能解读的，来看这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Essence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InterfaceTestA interfaceTestA = () -&gt; &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        InterfaceTestB interfaceTestB = () -&gt; &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceTestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceTestB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于这两个不同的函数式接口的实现都是() -&gt; {}这同一种实现，对于这个特定的Lambda表达式，必须要联系他的上下文才能知道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InterfaceTestA interfaceTestA</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InterfaceTestB interfaceTestB</span><br></pre></td></tr></table></figure>

<p>就是这两个Lambda表达式的上下文。</p>
<p>我们再回到遍历List集合的例子中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击forEach方法，就会自动跳转到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs the given action for each element of the &#123;<span class="doctag">@code</span> Iterable&#125;</span></span><br><span class="line"><span class="comment"> * until all elements have been processed or the action throws an</span></span><br><span class="line"><span class="comment"> * exception.  Unless otherwise specified by the implementing class,</span></span><br><span class="line"><span class="comment"> * actions are performed in the order of iteration (if an iteration order</span></span><br><span class="line"><span class="comment"> * is specified).  Exceptions thrown by the action are relayed to the</span></span><br><span class="line"><span class="comment"> * caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation behaves as if:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     for (T t : this)</span></span><br><span class="line"><span class="comment"> *         action.accept(t);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action The action to be performed for each element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified action is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先它是一个默认方法，接收的参数类型是Consumer，遍历这个集合，对集合中的每个元素执行Consumer中的accept()方法。</p>
<p>不妨来读一下这段文档：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs the given action for each element of the &#123;@code Iterable&#125;</span><br><span class="line">until all elements have been processed or the action throws an</span><br><span class="line">exception.  Unless otherwise specified by the implementing class,</span><br><span class="line">actions are performed in the order of iteration (if an iteration order</span><br><span class="line">is specified).  Exceptions thrown by the action are relayed to the</span><br><span class="line">caller</span><br></pre></td></tr></table></figure>

<p>针对于Iterable每一个元素去执行给定的动作，换句话说，这里并不是将值作为参数，而是将行为作为参数进行传递，执行到集合中所有的元素执行完或者抛出异常为止，如果没有被实现类所指定的话，那么动作就会按照迭代的顺序去执行，是不是抛出异常取决于调用者。</p>
<p>其实这里最关键的就是Consumer这个参数，接下来我们重点分析Consumer这个函数式接口。</p>
<h3 id="Consumer函数式接口"><a href="#Consumer函数式接口" class="headerlink" title="Consumer函数式接口"></a>Consumer函数式接口</h3><p>首先我们观察Consumer这个接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment"> * result. Unlike most other functional interfaces, &#123;<span class="doctag">@code</span> Consumer&#125; is expected</span></span><br><span class="line"><span class="comment"> * to operate via side-effects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #accept(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the operation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@since 1.8</span><br></pre></td></tr></table></figure>
<p>这个接口是从JDK1.8才开始有的，consumer这个单词本身的意思是消费者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents an operation that accepts a single input argument and returns no</span><br><span class="line">result. Unlike most other functional interfaces, &#123;@code Consumer&#125; is expected</span><br><span class="line">to operate via side-effects.</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>Consumer代表了一种接收单个输入并且不返回结果的操作，与大多数其他的函数式接口不同的是，它可能会有副作用，这里的副作用指的是可能会修改传入参数的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line">whose functional method is &#123;@link #accept(Object)&#125;.</span><br></pre></td></tr></table></figure>
<p>这是一个函数式接口，接口中的抽象方法是accept()。<br>对于前面List集合遍历的例子，  我们可以通过匿名内部类的方式来操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于所有的匿名内部类又可以使用Lambda表达式来进行替换，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;hello world&quot;);</span><br><span class="line">        list.forEach(item-&gt; System.out.println(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信看到这里，对于函数式接口，大家已经有了一定的理解。这里因为类型推断的原因，编译器会自动推断Item的数据类型，所以无需说明item的类型。</p>
<h3 id="Function函数式接口"><a href="#Function函数式接口" class="headerlink" title="Function函数式接口"></a>Function函数式接口</h3><p>java8为我们了提供了很多的函数式接口，Function就是其中一个，首先我们来读一下它的javaDoc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function and then applies this function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，与之前介绍的Consumer函数一样，都是一个函数式接口，都是从JDK8开始提供的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents a function that accepts one argument and produces a result.</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line">whose functional method is &#123;@link #apply(Object)&#125;.</span><br><span class="line"> </span><br><span class="line">@param &lt;T&gt; the type of the input to the function</span><br><span class="line">@param &lt;R&gt; the type of the result of the function</span><br></pre></td></tr></table></figure>
<p>Function提供了一个接收一个参数并且返回一个结果的函数，它的抽象方法是apply()，&lt;T,R&gt;分别表示输入参数的类型和返回结果的类型。</p>
<p>我们来看一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, value -&gt; <span class="number">2</span> * value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = function.apply(a);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中最关键的地方在于，compute的function参数传递的是一种行为，而不再是传统的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, value -&gt; <span class="number">2</span> * value));</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">2</span>, value -&gt; value * value));</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">3</span>, value -&gt; <span class="number">3</span> + value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = function.apply(a);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们其实只定义了一个函数，每次只需要将我们的所定义好的行为，传入即可，这是与非函数式编程最大的区别。</p>
<p>来看一个输入参数与返回结果参数类型不一致的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FunctionTest &#123;</span><br><span class="line"></span><br><span class="line">    public int method1(int a) &#123;</span><br><span class="line">        return 2 * a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int method2(int a) &#123;</span><br><span class="line">        return a * a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int method3(int a) &#123;</span><br><span class="line">        return 3 + a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当有一种新的操作，我们就不得不定义一个新的函数，因为行为总是被预先定义好的，定义好行为之后我们再去调用。但是使用Lambda表达式，行为是调用的时候才动态的调用执行，这与之前的面向对象的编程方式是完全不同的。</p>
<p>这里还需要简单提及一下高阶函数，如果一个函数接收一个函数作为参数，或者返回一个函数作为返回值，那么该函数就叫做高阶函数。</p>
<p>比如我们上面给出的例子中的compute()方法，convert()方法就是高阶函数。</p>
<p>在Function接口中，还有两个默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment"> * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment"> * function and then applies this function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compose()这个函数返回的是一个复合函数，这个复合函数首先应用before这个Function，然后再去对这个结果应用当前的Function，如果当中任何一个Function抛出了异常，它取决于调用这个怎么去处理这个异常。 </p>
<p>参数before指的是在应用这个函数之前所要应用的当前的函数的函数，首先会应用before这个Function，然后再应用当前的Function。</p>
<p>cmpose()这个方法其实是将两个Function进行了组合，首先调用传入的Function的apply()方法，然后再调用当前的Function的apply()方法。这么做实现了两个函数式接口的串联，实际上也可以n个的串联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment"> * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment"> * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>andThen()这个方法刚好是反过来的，首先会应用当前的Function，然后再去对应用当前的这个对象的Function。</p>
<p>最后这个方法就比较简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>它总是返回输入的变量。identity本身的意思也就是同一性，下面我们通过具体的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">        System.out.println(functionTest.compute2(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Function接口中的apply()方法而言，它只接受一个参数，并返回一个结果，如果想输入两个参数并返回结果，显然它是做不到的，再JDK中有这样一个函数式接口BiFunction：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bi实际上是Bidirectional的缩写，这个单词本身的含义是双向的意思。BiFunction这个函数式接口的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Represents a function that accepts two arguments and produces a result.</span><br><span class="line"> * This is the two-arity specialization of &#123;@link Function&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line"> * whose functional method is &#123;@link #apply(Object, Object)&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; the type of the first argument to the function</span><br><span class="line"> * @param &lt;U&gt; the type of the second argument to the function</span><br><span class="line"> * @param &lt;R&gt; the type of the result of the function</span><br><span class="line"> *</span><br><span class="line"> * @see Function</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>接收两个参数并且返回一个结果，它是Function接口的一种特殊形式，有三个泛型，T，U分别是两个接收的参数的类型，R是返回的结果的类型。</p>
<p>如果我们想定义四则运算的话，使用传统的方式，我们可能会写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察不难发现，四则运算正好就是输入两个参数，返回一个结果，正好满足BiFunction的定义，现在我们使用BiFunction来实现同样的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BiFunctionTest biFunctionTest = <span class="keyword">new</span> BiFunctionTest();</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 + value2));</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 - value2));</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 * value2));</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 / value2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，在Bifunction中只有一个默认方法andThen()，而没有compose()方法:<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment"> * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment"> * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原因是显而易见的，如果有的话，只能返回一个结果，而Bifunction要求接收两个参数，返回一个结果，这显然是不行的，但是对于andThen()方法，after这个Function类型的参数，正好可以接收BiFunction这个接口的返回的结果作为参数。</p>
<p>同样的我们可以举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BiFunctionTest biFunctionTest = <span class="keyword">new</span> BiFunctionTest();</span><br><span class="line">        System.out.println(biFunctionTest.compute(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 + value2, value -&gt; value * value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.andThen(function).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        Person person3 = <span class="keyword">new</span> Person(<span class="string">&quot;wangwu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; persons = Arrays.asList(person1, person2, person3);</span><br><span class="line">        PersonTest personTest = <span class="keyword">new</span> PersonTest();</span><br><span class="line">        List&lt;Person&gt; persons2 = personTest.getPersonByAge(<span class="number">25</span>, persons);</span><br><span class="line">        persons2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonByUsername</span><span class="params">(String username, List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> persons.stream().filter(person -&gt; person.getUsername().equals(username)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonByAge</span><span class="params">(<span class="keyword">int</span> age, List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; biFunction = (ageOfPerson, personList) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> personList.stream().filter(person -&gt; person.getAge() &gt; age).collect(Collectors.toList());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(age, persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Predicate函数式接口"><a href="#Predicate函数式接口" class="headerlink" title="Predicate函数式接口"></a>Predicate函数式接口</h3><p>同样的方式，我们首先类阅读一下Predicate的JavaDoc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #test(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the predicate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of arguments to the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetRef the object reference with which to compare for equality,</span></span><br><span class="line"><span class="comment">     *               which may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Predicate也是一个重要的函数式接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Represents a predicate (boolean-valued function) of one argument.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line"> * whose functional method is &#123;@link #test(Object)&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; the type of the input to the predicate</span><br><span class="line"> *</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>predicate这个单词本身是谓词， 阐明， 断言的意思，这里说，Predicate代表了一个接收一个参数，返回一个boolean值类型的函数式接口，其中方法名叫test()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Evaluates this predicate on the given argument.</span><br><span class="line">   *</span><br><span class="line">   * @param t the input argument</span><br><span class="line">   * @return &#123;@code true&#125; if the input argument matches the predicate,</span><br><span class="line">   * otherwise &#123;@code false&#125;</span><br><span class="line">   */</span><br></pre></td></tr></table></figure>
<p>针对于给定的T类型的参数t来计算，如果与predicate相匹配，则返回一个true,否则返回false。</p>
<p>针对于Predicate可以定义，我们可以给出例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = p -&gt; p.length() &gt; <span class="number">5</span>;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Predicate在集合与stream中有大量的应用，再来看一些具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        PredicateTest2 predicateTest2 = <span class="keyword">new</span> PredicateTest2();</span><br><span class="line">        <span class="comment">// 找到集合中所有的偶数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有的奇数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &gt; <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有小于3的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &lt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以想象的到，如果要使用传统的方式实现这些需求，我们就需要编写很多个具体的方法，但是如果使用Lambda表达式，我们就可以定义一个通用的函数，具体的行为再在调用的时候传入。</p>
<p>Predicate中除了抽象方法test()，还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a composed predicate that represents a short-circuiting logical</span><br><span class="line"> * AND of this predicate and another.  When evaluating the composed</span><br><span class="line"> * predicate, if this predicate is &#123;@code false&#125;, then the &#123;@code other&#125;</span><br><span class="line"> * predicate is not evaluated.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span><br><span class="line"> * to the caller; if evaluation of this predicate throws an exception, the</span><br><span class="line"> * &#123;@code other&#125; predicate will not be evaluated.</span><br><span class="line"> *</span><br><span class="line"> * @param other a predicate that will be logically-ANDed with this</span><br><span class="line"> *              predicate</span><br><span class="line"> * @return a composed predicate that represents the short-circuiting logical</span><br><span class="line"> * AND of this predicate and the &#123;@code other&#125; predicate</span><br><span class="line"> * @throws NullPointerException if other is null</span><br><span class="line"> */</span><br><span class="line">default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    return (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数表示当前的Predicate与另一个Predicate的短路与，当计算这个复合函数的时候，如果前面的Predicate的值为false,那么后面的将不再会被计算，如果在计算过程中，任何一个Predicate会抛出异常的话，怎么做取决于调用者，如果当前的Predicate抛出了异常，那么后者也不会被计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Returns a predicate that represents the logical negation of this</span><br><span class="line">  * predicate.</span><br><span class="line">  *</span><br><span class="line">  * @return a predicate that represents the logical negation of this</span><br><span class="line">  * predicate</span><br><span class="line">  */</span><br><span class="line"> default Predicate&lt;T&gt; negate() &#123;</span><br><span class="line">     return (t) -&gt; !test(t);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>negate本身是否定的意思，表示返回当前Predicate的逻辑非。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns a composed predicate that represents a short-circuiting logical</span><br><span class="line"> * OR of this predicate and another.  When evaluating the composed</span><br><span class="line"> * predicate, if this predicate is &#123;@code true&#125;, then the &#123;@code other&#125;</span><br><span class="line"> * predicate is not evaluated.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span><br><span class="line"> * to the caller; if evaluation of this predicate throws an exception, the</span><br><span class="line"> * &#123;@code other&#125; predicate will not be evaluated.</span><br><span class="line"> *</span><br><span class="line"> * @param other a predicate that will be logically-ORed with this</span><br><span class="line"> *              predicate</span><br><span class="line"> * @return a composed predicate that represents the short-circuiting logical</span><br><span class="line"> * OR of this predicate and the &#123;@code other&#125; predicate</span><br><span class="line"> * @throws NullPointerException if other is null</span><br><span class="line"> */</span><br><span class="line">default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    return (t) -&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，这个方法是计算逻辑或的操作，如果当前的Predicate是true的话，后面的将不会再被计算，关于Predicate的三个默认方法，我们来看具体例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">        PredicateTest2 predicateTest2 = <span class="keyword">new</span> PredicateTest2();</span><br><span class="line">        <span class="comment">// 找到集合中所有的偶数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有的奇数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &gt; <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有小于3的数</span></span><br><span class="line">        predicateTest2.conditionFilter(list, item -&gt; item &lt; <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5并且是偶数的数</span></span><br><span class="line">        predicateTest2.conditionFilter2(list, item -&gt; item &gt; <span class="number">5</span>, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 找到集合中所有大于5或者是偶数的数</span></span><br><span class="line">        predicateTest2.conditionFilter3(list, item -&gt; item &gt; <span class="number">5</span>, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        predicateTest2.conditionFilter4(list, item -&gt; item &gt; <span class="number">5</span>, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter2</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.and(predicate2).test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter3</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.or(predicate2).test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter4</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.or(predicate2).negate().test(integer)) &#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们来看一下它唯一的static方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of arguments to the predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetRef the object reference with which to compare for equality,</span></span><br><span class="line"><span class="comment"> *               which may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">            ? Objects::isNull</span><br><span class="line">            : object -&gt; targetRef.equals(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来根据Objects类中的equals()方法判断两个参数是不是相等，注意，这里并不是Object类，而是Objects，这是从JDK1.7之后新增加的类。<br>Objects::isNull是一个静态方法的方法引用，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PredicateTest3 predicateTest3 = <span class="keyword">new</span> PredicateTest3();</span><br><span class="line">        System.out.println(predicateTest3.isEqual(<span class="string">&quot;test&quot;</span>).test(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Predicate&lt;Date&gt; <span class="title">isEqual</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Predicate.isEqual(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上这个其实”test”.equals(new Date())，那么显然结果是false。</p>
<h3 id="Supplier函数式接口"><a href="#Supplier函数式接口" class="headerlink" title="Supplier函数式接口"></a>Supplier函数式接口</h3><p>同样的，我们来看一下Supplier函数式接口的文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a supplier of results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a new or distinct result be returned each</span></span><br><span class="line"><span class="comment"> * time the supplier is invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #get()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of results supplied by this supplier</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先来看类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents a supplier of results.</span><br><span class="line">There is no requirement that a new or distinct result be returned each time the supplier is invoked.</span><br></pre></td></tr></table></figure>

<p>Supplier表示提供结果的供应者，它每次被调用的时候无需保证返回不同的结果，换言之，每次被调用的结果可能是相同的。</p>
<p>Supplier不接受参数，并返回一个结果。</p>
<p>我们来新建一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierJyc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;String&gt; supplierJyc = () -&gt; <span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">        System.out.println(supplierJyc.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，控制台会打印出以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :SupplierJyc.main()</span><br><span class="line">hello word</span><br></pre></td></tr></table></figure>

<p>实际上，Supplier更多的适用于工厂创建对象，下面我们用具体的例子来说明，首先创建一个Student类，并生成无参构造方法和setter及getter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们使用Supplier来创建一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier = () -&gt; <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(supplier.get().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正式由于Supplier这个函数式接口不接收参数，并且返回一个泛型T类型的对象，所以() -&gt; new Student()就是Supplier函数式接口的一个实例。除了通过这种方式创建实例外，我们还可以使用一种特殊的方式来创建Supplier的实例，即对象引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier = () -&gt; <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(supplier.get().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;Student&gt; supplier2 = Student::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(supplier2.get().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这会与上面的代码得到相同的结果，如果点击Student::new中的new的话，会自动跳转到Student的无参构造的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>说明这个新的语法就是在调用Student的无参构造来创建对象，而这个无参构造刚好满足不接受参数，只返回对象的Supplier函数式接口的要求，所以创建了Student的实例。</p>
<p>当我们修改这个类的默认构造方法，去掉没有参数的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器就会提示我们不能解析构造方法：</p>
<p><img src="D:\笔记\jiyongchao-qf.github.io\docs\views\images\Functionalprogramming.md" alt="1597851410941"></p>
<p>这也验证了我们之前的说法。</p>
<p>以上就是几个最基础也是最重要的几个函数式接口，在此基础上，JDK还为我们提供了一些其他的函数式接口，例如BinaryOperator，他们可以看成是前面几个函数式接口的扩展。</p>
<h3 id="函数式接口扩展"><a href="#函数式接口扩展" class="headerlink" title="函数式接口扩展"></a>函数式接口扩展</h3><p>相同的方式，我们首先来阅读一下BinaryOperator这个函数式接口的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Represents an operation upon two operands of the same type, producing a result</span><br><span class="line"> * of the same type as the operands.  This is a specialization of</span><br><span class="line"> * &#123;@link BiFunction&#125; for the case where the operands and the result are all of</span><br><span class="line"> * the same type.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line"> * whose functional method is &#123;@link #apply(Object, Object)&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; the type of the operands and result of the operator</span><br><span class="line"> *</span><br><span class="line"> * @see BiFunction</span><br><span class="line"> * @see UnaryOperator</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns a &#123;@link BinaryOperator&#125; which returns the lesser of two elements</span><br><span class="line">     * according to the specified &#123;@code Comparator&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt; the type of the input arguments of the comparator</span><br><span class="line">     * @param comparator a &#123;@code Comparator&#125; for comparing the two values</span><br><span class="line">     * @return a &#123;@code BinaryOperator&#125; which returns the lesser of its operands,</span><br><span class="line">     *         according to the supplied &#123;@code Comparator&#125;</span><br><span class="line">     * @throws NullPointerException if the argument is null</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) &#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        return (a, b) -&gt; comparator.compare(a, b) &lt;= 0 ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a &#123;@link BinaryOperator&#125; which returns the greater of two elements</span><br><span class="line">     * according to the specified &#123;@code Comparator&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt; the type of the input arguments of the comparator</span><br><span class="line">     * @param comparator a &#123;@code Comparator&#125; for comparing the two values</span><br><span class="line">     * @return a &#123;@code BinaryOperator&#125; which returns the greater of its operands,</span><br><span class="line">     *         according to the supplied &#123;@code Comparator&#125;</span><br><span class="line">     * @throws NullPointerException if the argument is null</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) &#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        return (a, b) -&gt; comparator.compare(a, b) &gt;= 0 ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type.</span><br><span class="line">This is a functional interface whose functional method is apply(Object, Object).</span><br></pre></td></tr></table></figure>

<p>BinaryOperator表示针对于两个相同运算对象的操作，并且生成与运算对象相同类型的结果类型，这是当使用BiFunction运算对象与结果类型相同时候的一个特例，我们知道，在BiFunction中，类型可以是不相同的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;T, U, R&gt;</span><br></pre></td></tr></table></figure>

<p>同时其中的抽象方法apply()，也接收了两个不同类型的参数，并且返回了不同类型的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当类型相同的时候，就变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt;</span><br></pre></td></tr></table></figure>

<p>apply()方法也就变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">apply</span><span class="params">(T t, T u)</span></span>;</span><br></pre></td></tr></table></figure>

<p>BinaryOperator中还有两个静态方法，首先来看minBy()的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a BinaryOperator which returns the lesser of two elements according to the specified Comparator.</span><br></pre></td></tr></table></figure>

<p>minBy()方法会根据比较器Comparator返回两个元素中比较小的那一个，来看一个具体的例子，我们给定两个字符串，来返回比较小的那一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryOperatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryOperatorTest binaryOperatorTest = <span class="keyword">new</span> BinaryOperatorTest();</span><br><span class="line">        System.out.println(binaryOperatorTest.getShort(<span class="string">&quot;hellohello&quot;</span>, <span class="string">&quot;hello&quot;</span>, (a, b) -&gt; a.length() - b.length()));</span><br><span class="line">        System.out.println(binaryOperatorTest.getShort(<span class="string">&quot;hellohello&quot;</span>, <span class="string">&quot;hello&quot;</span>, (a, b) -&gt; a.charAt(<span class="number">0</span>) - b.charAt(<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShort</span><span class="params">(String a, String b, Comparator&lt;String&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BinaryOperator.minBy(comparator).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然使用maxBy()方法会获得相反的结果。</p>
<p>其实在java.util.function这个包下面，还有很多的其他的函数式接口，比如BiConsumer，BiFunction，LongPredicate，IntSupplier等等，这些都是对于这几个基础的函数式接口的有力的补充，也是这几个基础的函数式接口的特例。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中的::就是JDK8中新增的语法，叫做方法引用，它可以看成是Lambda表达式的一种语法糖，如果所使用的Lambda表达式恰好被实现过的话，就可以使用方法引用来写出更加简洁的代码，我们可以将方法引用看作是一个【函数指针（function pointer）】。</p>
<p>方法引用共分为4类：静态方法引用、构造方法引用、类的任意对象的实例方法引用、特定对象的实例方法引用，对于其中的每一种，我们都会给出Lambda表达式的方式和方法引用的方式实现相同的功能，以此来对照学习。</p>
<h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>首先定义一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByScore</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.score - student2.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByName</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们使用List集合中新增加的sort方法进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        students.sort((studentParam1, studentParam2) -&gt; Student.compareStudentByScore(studentParam1, studentParam2));</span><br><span class="line"></span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们排序的时候直接调用的是List集合中的默认方法sort（），这也是在JDK8中新增加的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">      Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">      Arrays.sort(a, (Comparator) c);</span><br><span class="line">      ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">      <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">          i.next();</span><br><span class="line">          i.set((E) e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到其接收Comparator作为参数，我们再来看一下Comparator的类定义情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这是一个函数式接口，并且接收两个相同类型的参数，并且返回一个Int值，它会根据定义好的排序规则，如果第一个参数大于第二个参数，那么会返回正数，相等会返回0，小于会返回负数，针对于以上的例子，Student类中的静态方法compareStudentByScore恰好是接收两个参数，并且返回一个结果，所以可以作为Comparator这个Lambda表达式的方法体，其实我们还可以使用方法引用的方式，来完成相同的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        <span class="comment">// students.sort((studentParam1, studentParam2) -&gt; Student.compareStudentByScore(studentParam1, studentParam2));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// students.forEach(student -&gt; System.out.println(student.getScore()));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">        students.sort(Student::compareStudentByScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式的效果完全等价，换言之，在这个场景下，方法引用与Lambda表达式完全等价，方法引用是Lambda表达式的一种语法糖，只有当某一个已经存在的方法，恰好满足了Lambda表达式的要求，才可以使用方法引用，Lambda表达式其实是一种更为通用的形式，而方法引用则需要满足一些条件才能使用。</p>
<h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><p>我们依然使用排序这个例子，这次我们使用另一种写法来完成这个功能，首先定义一个这样的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentByScore</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getScore() - student2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentByName</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后来实现对于Student的排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line">        </span><br><span class="line">        StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</span><br><span class="line">        students.sort((studentParam1, studentParam2) -&gt; studentComparator.</span><br><span class="line">                compareStudentByScore(studentParam1, studentParam2));</span><br><span class="line">        </span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们直接使用StudentComparator实例中的compareStudentByScore来进行排序，事实上，这种场景下，也可以使用方法引用来替代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</span><br><span class="line">        students.sort(studentComparator::compareStudentByScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">        students.sort(studentComparator::compareStudentByName);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与静态方法引用的不同的是，这里我们调用的是类实例的方法。</p>
<h3 id="实例方法名引用"><a href="#实例方法名引用" class="headerlink" title="实例方法名引用"></a>实例方法名引用</h3><p>首先，在Student类中，我们增加一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2 * <span class="doctag">@Author</span>: jiyongchao</span></span><br><span class="line"><span class="comment"> * 3 * <span class="doctag">@Date</span>: 2020/8/20 23:56</span></span><br><span class="line"><span class="comment"> * 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByScore</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.score - student2.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareStudentByName</span><span class="params">(Student student1, Student student2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByScore</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getScore() - student.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByName</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().compareToIgnoreCase(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的例子中，compareStudentByScore与compareStudentByName方法实际上是我们有意为之的，实际上这两个静态方法放在任何一个类中，都是可以调用的，通常我们比较两个对象时，更多的情况是，传入一个对象，并与当前对象进行比较，这也是新增加的compareByScore和compareByName的作用，在这种情况下，排序规则又可以做出如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        students.sort(Student::compareByName);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再举一个例子，来加深对于实例方法名引用的理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; cities = Arrays.asList(<span class="string">&quot;qingdao&quot;</span>, <span class="string">&quot;chongqing&quot;</span>, <span class="string">&quot;tianjin&quot;</span>, <span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">        Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2));</span><br><span class="line">        cities.forEach(city -&gt; System.out.println(city));</span><br><span class="line">        Collections.sort(cities, String::compareToIgnoreCase);</span><br><span class="line">       	cities.forEach(city -&gt; System.out.println(city));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，再回到集合遍历的例子当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out::println()</span><br></pre></td></tr></table></figure>

<p>实际上，查看System源码可以发现out实际上是PrintStream的一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>而println()方法就是PrintStream中的一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          print(x);</span><br><span class="line">          newLine();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h3><p>前面我们介绍过的Supplier函数式接口其中一个很重要的应用就是构造方法引用，因为其不接收参数，返回值的特性正好与构造方法的作用不谋而合，所以，我们可以很轻松的写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get() + <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodReferenceDemo methodReferenceDemo = <span class="keyword">new</span> MethodReferenceDemo();</span><br><span class="line">        System.out.println(methodReferenceDemo.getString(String::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了无参构造，还可以调用有参数的构造方法，这个时候就变成了接收一个参数，返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString2</span><span class="params">(String str, Function&lt;String, String&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodReferenceDemo methodReferenceDemo = <span class="keyword">new</span> MethodReferenceDemo();</span><br><span class="line">        System.out.println(methodReferenceDemo.getString2(<span class="string">&quot;hello&quot;</span>, String::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>在方法引用的最后，我们补充一些关于JDK8中默认方法的相关介绍，首先定义这样两个接口，接口中有同名的默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，假设有一个类，要实现这两个接口，但是由于这两个接口中有同名的默认方法，所以，编译器无法自动推断出要继承哪一个接口中的默认方法，一般这个时候，处理方式有两种，一种是在实现类中重写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface1</span>, <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的弊端在于，我们需要将某一个子类中的默认方法实现重写一遍，如果代码很多，既费时，可维护性也比较差，好在JDK为我们提供了另一种方式来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface1</span>, <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       MyInterface1.<span class="keyword">super</span>.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上例子我们再做一个小的扩展，增加一个MyInterface1的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterface1Impl</span> <span class="keyword">implements</span> <span class="title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface1Impl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候，我们再定义一个类，这个类继承MyInterface1Impl，并且实现MyInterface2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyInterface1Impl</span> <span class="keyword">implements</span> <span class="title">MyInterface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass2 myClass2 = <span class="keyword">new</span> MyClass2();</span><br><span class="line">        myClass2.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候调用当前类的myMethod()方法并不会报错，也就是说，编译器自动推断出了我们要想调用MyInterface1Impl中的myMethod()方法，还是MyInterface2中的默认方法myMethod()，这实际上是JDK中的一个约定，编译器会认为继承的优先级大于实现，类中的方法才表示具体的行为，而接口更多的时候还是表示一种模板或者契约。</p>
<p>增加默认方法的特性是Java对于支持函数式编程一个非常重要的改变，在上面排序的例子中可以看到，List这样一个顶层的集合增加了排序的方法，试想，如果没有默认方法，那对于想从JDK7升级到JDK8的人无疑是一场灾难，如果一旦在自己的代码实现过List，那意味你需要重写所有的子类，而JDK在很多的接口中都增加了默认方法，为了升级JDK还需要入侵式的修改客户端的代码，这显然是不合适的，那为什么还会增加默认方法的机制呢？其目的，就是为了更为方便的编写函数式的代码，同时也是为了向后兼容的一种妥协，从这一个层面来说，Java的函数式编程并不是完美无暇的，更像是一个裹足前行的人，这也是面向对象带来限制，但我们还是非常振奋，JDK8使我们看到了Java这门古老的语言的全新面貌。</p>
<p>增加默认方法也可以看到，接口和抽象类的区别越来越小了。</p>
<h2 id="Stream实践"><a href="#Stream实践" class="headerlink" title="Stream实践"></a>Stream实践</h2><p>在前面的章节我们花费了不少的章节整理了Lambda表达式的相关特性，也举出了不少的例子来展示了Lambda表达式的应用，但总有种纸上谈兵的感觉，还是无法理解Lambda表达式到底可以帮我们做哪些事情？函数式编程又指的是什么？在接下来的章节中，我们就会围绕这两个问题展开。</p>
<p>实际上，Lambda表达式在大多数的场景下，都是与Stream相伴出现的，两个配合使用，更加高效、简洁、优雅的处理集合相关的问题。 </p>
<p>首先我们需要了解一些Stream的基本概念，学会新的API使用，在不断的实践中，最后探究Stream的实现原理。一般而言Stream由3个部分组成：</p>
<ol>
<li>源</li>
<li>零个或多个中间操作</li>
<li>终止操作</li>
</ol>
<p>流操作的分类又有两种：</p>
<ol>
<li>惰性求值</li>
<li>及早求值</li>
</ol>
<p>Stream也可以分为并行流和串行流，可以通过非常简单的方式，就是使用并发来加快运行的效率。</p>
<p>我们首先使用不同的方式来创建一个Stream对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream stream1 = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么可以这样创建呢？不妨查看一下Stream这个类中的of()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这是一个静态方法，本身接受的是可变参数，并且会调用Arrays中的stream方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stream(array, <span class="number">0</span>, array.length);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中的”hello”, “world”, “hello world”就称之为源，源的意思就是要操作的数据对象，使用相似的方式，我们还可以这样创建Stream：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream stream1 = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        String[] myArray = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line">        Stream stream2 = Stream.of(myArray);</span><br><span class="line">        Stream stream3 = Arrays.stream(myArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上而言，这几种创建Stream的方式并没有什么区别，其实最常见的，是采用下面的方式来创建流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(myArray);</span><br><span class="line">        Stream stream = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是关于如何创建流的对象的例子，接下来我们看看引入Stream会为我们的编码带来什么样的改变，首先我们创建一个Stream，并且调用它的forEach（）方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们首先创建了一个元素为5，6，7的Stream对象，并且调用forEach()方法，对流中的每一个元素执行打印的操作。</p>
<p>Stream本身其实也提供了针对与特定数据类型的具化的Stream对象，用来避免自动拆箱装箱带来的性能的损耗，所以这段代码也可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>,&#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就在控制台打印了3到7，我们可以来了解一下这个range()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt;= endExclusive) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endExclusive, <span class="keyword">false</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个方法返回的是包含最小值，不包含最大值的IntStream对象，那如果要包含最大值改怎么做呢？一种方式当然可以调整范围，比如，可以设置范围是（3，9）就可以打印3到8的内容，也可以调用另一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>我们不妨来看一下这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">rangeClosed</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt; endInclusive) &#123;</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endInclusive, <span class="keyword">true</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就顺利的同时包含了较小的值和较大的值。</p>
<p>上面的例子看起来还是相对而言比较简陋的，接下来我们给出一个稍微复杂一点的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(list.stream().map(i -&gt; <span class="number">2</span> * i).reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们对于集合中的元素先乘以2，然后求和，这里的map描述的是一种映射，而reduce描述的一种聚合，只有当表达式中具有reduce这样的终止操作的方法的时候，流才会被真正的执行，这就是所谓的终止操作，而map就称之为中间操作。不难看出，与传统的方式，使用函数式的方式，代码变的异常简洁和优雅。</p>
<h3 id="Stream类源码解析"><a href="#Stream类源码解析" class="headerlink" title="Stream类源码解析"></a>Stream类源码解析</h3><p>在初步了解了Sream给我们来了些什么之后，我们来了解一些关于流的特性：</p>
<ul>
<li>Collection提供了新的Stream()方法</li>
<li>流不存储值，通过管道的方式获取值</li>
<li>本质是函数式的，对流的操作会生成一个结果，不过并不会修改底层的数据源，集合可以作为流的底层数据源</li>
<li>延迟查找，很多流操作（过滤、映射、排序等）都可以延迟实现</li>
</ul>
<p>接下来再通过一些实际的例子，来加深对于Stream的理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        String[] stringArray = stream.toArray(length -&gt; <span class="keyword">new</span> String[length]);</span><br><span class="line">        String[] strings = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.asList(stringArray).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子创建Stream的，那Stream是如何转变成我们常用的List集合呢？这里就要说明一个及其重要的方法collect()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">         list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>collect()方法是有几个重载的方法，我们来看接收参数最多的这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs a &lt;a href=&quot;package-summary.html#MutableReduction&quot;&gt;mutable</span></span><br><span class="line"><span class="comment"> * reduction&lt;/a&gt; operation on the elements of this stream.  A mutable</span></span><br><span class="line"><span class="comment"> * reduction is one in which the reduced value is a mutable result container,</span></span><br><span class="line"><span class="comment"> * such as an &#123;<span class="doctag">@code</span> ArrayList&#125;, and elements are incorporated by updating</span></span><br><span class="line"><span class="comment"> * the state of the result rather than by replacing the result.  This</span></span><br><span class="line"><span class="comment"> * produces a result equivalent to:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     R result = supplier.get();</span></span><br><span class="line"><span class="comment"> *     for (T element : this stream)</span></span><br><span class="line"><span class="comment"> *         accumulator.accept(result, element);</span></span><br><span class="line"><span class="comment"> *     return result;</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Like &#123;<span class="doctag">@link</span> #reduce(Object, BinaryOperator)&#125;, &#123;<span class="doctag">@code</span> collect&#125; operations</span></span><br><span class="line"><span class="comment"> * can be parallelized without requiring additional synchronization.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html#StreamOps&quot;&gt;terminal</span></span><br><span class="line"><span class="comment"> * operation&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> There are many existing classes in the JDK whose signatures are</span></span><br><span class="line"><span class="comment"> * well-suited for use with method references as arguments to &#123;<span class="doctag">@code</span> collect()&#125;.</span></span><br><span class="line"><span class="comment"> * For example, the following will accumulate strings into an &#123;<span class="doctag">@code</span> ArrayList&#125;:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     List&lt;String&gt; asList = stringStream.collect(ArrayList::new, ArrayList::add,</span></span><br><span class="line"><span class="comment"> *                                                ArrayList::addAll);</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The following will take a stream of strings and concatenates them into a</span></span><br><span class="line"><span class="comment"> * single string:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,</span></span><br><span class="line"><span class="comment"> *                                          StringBuilder::append)</span></span><br><span class="line"><span class="comment"> *                                 .toString();</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; type of the result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function that creates a new result container. For a</span></span><br><span class="line"><span class="comment"> *                 parallel execution, this function may be called</span></span><br><span class="line"><span class="comment"> *                 multiple times and must return a fresh value each time.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accumulator an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *                    function for incorporating an additional element into a result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> combiner an &lt;a href=&quot;package-summary.html#Associativity&quot;&gt;associative&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#NonInterference&quot;&gt;non-interfering&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *                    &lt;a href=&quot;package-summary.html#Statelessness&quot;&gt;stateless&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *                    function for combining two values, which must be</span></span><br><span class="line"><span class="comment"> *                    compatible with the accumulator function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of the reduction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">              BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">              BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>collect方法接收三个参数，其中的BiConsumer是接收两个参数，并且没有返回值的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface BiConsumer&lt;T, U&gt; </span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来阅读一下collect方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to:</span><br></pre></td></tr></table></figure>

<p>对流当中的元素进行可变的汇聚操作，一个可变的汇聚操作指的是将值汇聚到可变的结果容器，比如ArrayList，并且这个容器是通过更新结果的状态来进行合并的，而不是通过替换结果进行合并的，这个结果相当于下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R result = supplier.get();</span><br><span class="line">    <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">        accumulator.accept(result, element);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>首先会通过supplier.get()方法获取到结果集，然后对流中的元素进行遍历，遍历执行累加器accumulator中的accept，最后返回结果，这里总共有三个步骤，对应的就是collect方法的三个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">                 BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">                 BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们来举一个具体的例子来说明，这段文字的含义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.collect(() -&gt; <span class="keyword">new</span> ArrayList&lt;String&gt;(), (theList, item) -&gt; theList.add(item),(theList1, theList2) -&gt; theList1.addAll(theList2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>supplier就是我们要返回的结果，这里我们选择new一个ArrayList作为返回的容器，accumulator是我们要把流中的元素添加到要返回的结果容器当中，所以这里调用List的add()方法，将流中的元素依次添加到我们新new出来的ArrayList当中，每次将流中的元素添加到的ArrayList时都会新newArrayList，combiner是将上一次返回的结果，添加到的最终的结果theList1当中，当然，这个方法我们也可以用方法引用来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure>

<p>理解了三个参数具体的作用我们具体再往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Like reduce(Object, BinaryOperator), collect operations can be parallelized without requiring additional synchronization.This is a terminal operation.</span><br></pre></td></tr></table></figure>

<p>就像reduce一样，collect无需其他操作就可以很好的支持并行流，并且也是一个终止操作，这也是流式编程给我们带来的好处。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are many existing classes in the JDK whose signatures are well-suited for use with method references as arguments to collect(). </span><br></pre></td></tr></table></figure>

<p>在JDK中有很多的方法都可以采用方法引用的方式，作为collect()的参数，这里举了两个例子，一个正是我们前面举出的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; asList = stringStream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add,</span><br><span class="line">                                               ArrayList::addAll);</span><br></pre></td></tr></table></figure>

<p>还有一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String concat = stringStream.collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">                                       StringBuilder::append).toString();</span><br></pre></td></tr></table></figure>

<p>这里使用StringBuilder作为最终返回的结果容器，遍历集合中的单个的字符串，最终将他们拼接起来。</p>
<p>最后我们来看一下对于参数的说明：</p>
<ul>
<li>supplier – a function that creates a new result container. For a parallel execution, this function may be called multiple times and must return a fresh value each time.</li>
<li>accumulator – an associative, non-interfering, stateless function for incorporating an additional element into a result</li>
<li>combiner – an associative, non-interfering, stateless function for combining two values, which must be compatible with the accumulator function</li>
</ul>
<p>supplier会创建一个新的结果容器，在并行流中可能会多次调用，所以它每次返回的一定是一个新的结果容器，accumulator，它是一个相关的，不冲突的，可关联的一个无状态的一个函数，用于将一个额外的元素合并到结果容器当中，combiner用于合并两个值，它必须和accumulator 是兼容的。</p>
<p>最后我们可以看一个JDK实现的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream实例剖析"><a href="#Stream实例剖析" class="headerlink" title="Stream实例剖析"></a>Stream实例剖析</h3><p>首先来看一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用的Collectors类中的toCollection()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                                   (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                                   CH_ID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它接受一个Supplier参数，这里我们使用构方法引用的方式，这实际上是一种比起toList()更为通用的写法，使用toCollection可以很方便的自定义返回结果容器的类型，比如我们要返回一个LinkedList，我们只需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = stream.collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p>除了将流转化为List，我们也可以转化为Set、Map等，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;String&gt; set = stream.collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">        set.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一章节中，JDK中举出的拼接字符串的例子，实际上在Collectors中有一种更为简洁的实现方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        String str = stream.collect(Collectors.joining()).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们举的例子要么是将集合转化为Stream，要么是将Stream转化为集合，实际使用的时候，需要两者配合使用，举一个这样的例子，将集合中的字符串传化为大写并打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;helloworld&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        list.stream().map(String::toUpperCase).collect(Collectors.toList()).</span><br><span class="line">                forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似这样的代码，才是在实际应用中使用的最多的，其中的map()是JDK为我们提供的API，表示一种映射关系，将集合中的元素映射成后面表达式的结果的操作，再比如，要求出集合中每一个元素的平方并打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        list2.stream().map(item -&gt; item * item).collect(Collectors.toList()).</span><br><span class="line">                forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与map比较类似的还有一个flatmap()方法，它表示将流中元素的界限打破，最终返回一个整体，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>), Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        stream.flatMap(theList -&gt; theList.stream().map(item -&gt; item * item)).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们首先对于流中的集合进行了平方的操作，然后将所有的元素作为一个整体进行打印。</p>
<p>再来看一个map和flatMap例子，假设我们要对一个集合中的元素提取出单词并去重：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello welcome&quot;</span>, <span class="string">&quot;world hello&quot;</span>, <span class="string">&quot;hello world hello&quot;</span>, <span class="string">&quot;hello welcome&quot;</span>);</span><br><span class="line">        list.stream().map(item -&gt; item.split(<span class="string">&quot; &quot;</span>)).distinct().collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Ljava.lang.String;@4eec7777</span><br><span class="line">[Ljava.lang.String;@3b07d329</span><br><span class="line">[Ljava.lang.String;@41629346</span><br><span class="line">[Ljava.lang.String;@404b9385</span><br></pre></td></tr></table></figure>

<p>这显然是不对的，原因就在于这里我们使用map返回的类型实际上变成了String[]，自然的，后续的去重操作当然也都失败了，那如果要实现这个需求改怎么做呢？就需要调用flatMap方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello welcome&quot;</span>, <span class="string">&quot;world hello&quot;</span>, <span class="string">&quot;hello world hello&quot;</span>, <span class="string">&quot;hello welcome&quot;</span>);</span><br><span class="line">        list.stream().map(item -&gt; item.split(<span class="string">&quot; &quot;</span>)).flatMap(Arrays::stream).distinct().</span><br><span class="line">                collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再举这样一个例子来加深对于flatMap理解的场景，比如我们要获取两个集合的笛卡尔积，我们就可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;zhaoliu&quot;</span>);</span><br><span class="line">        list1.stream().flatMap(item -&gt; list2.stream().map(item2 -&gt; item + <span class="string">&quot; &quot;</span> + item2)).</span><br><span class="line">                collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来介绍generate和iterate这两个特殊的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.generate(UUID.randomUUID()::toString);</span><br><span class="line">        stream.findFirst().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来介绍iterate方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(f);</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;T&gt; iterator = <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T t = (T) Streams.NONE;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> t = (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span><br><span class="line">                iterator,</span><br><span class="line">                Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它的参数UnaryOperator可以简单的看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryOperator&lt;T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Function这个函数式接口本身接口T类型的参数，返回R类型的结果，这里的UnaryOperator表示接收参数与返回结果类型相同的情况，接下来我们阅读一下iterate的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</span><br><span class="line">The first element (position 0) in the Stream will be the provided seed. For n &gt; 0, the element at position n, will be the result of applying the function f to the element at position n - 1.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法返回无限的、串行的、有序的一个Stream，它是由迭代函数f对于初始值seed的不断迭代，第一个元素作为seed（种子）,而对于n&gt;0，会不断应用n-1次迭代函数f，比如f(seed)、f(f(seed))等等。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里之所以使用limit是因为如果不加限制，程序将一直运行下去，这是因为iterate他是无限的。</p>
<h3 id="Stream陷阱剖析"><a href="#Stream陷阱剖析" class="headerlink" title="Stream陷阱剖析"></a>Stream陷阱剖析</h3><p>首先来看这样一个例子，假设有这样一个流，流中的元素为1，3，5，6，7，11，我们要找出流中大于2的元素，然后将每个元素乘以2，忽略掉流中的前两个元素之后，再取出流中的前两个元素，然后求出流中元素的总和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).sum();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个新的方法，skip()表示跳过，而limit()表示取前几个元素。</p>
<p>如果我们改一下需求，把求出流中元素的总和改为求出流中元素的最小值，我们猜想代码可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).min();</span><br></pre></td></tr></table></figure>

<p>但是运行之后控制台的输出却不是我们想要的结果，而是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OptionalInt[14]</span><br></pre></td></tr></table></figure>

<p>原来min()方法的源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">OptionalInt <span class="title">min</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回的是一个Optional对象，而不是一个普通的Int，类似的max()方法返回的也是Optional对象，原因就在于，求最大值和最小值有可能为空，而求和则不会，如果流中没有元素返回0即可，从本质上来说，是否会直接返回值，还是返回Optional对象，就是取决于是否可能会出现空指针的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">10</span>);</span><br><span class="line">        stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).max().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果既想求出最大值，也想求出最小值，也想求出总和，改怎么办呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntSummaryStatistics intSummaryStatistics = stream.filter(item -&gt; item &gt; <span class="number">2</span>).mapToInt(item -&gt; item * <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">2</span>).summaryStatistics();</span><br><span class="line">        System.out.println(intSummaryStatistics.getMax());</span><br><span class="line">        System.out.println(intSummaryStatistics.getMin());</span><br><span class="line">        System.out.println(intSummaryStatistics.getSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案就是调用summaryStatistics()方法。</p>
<p>Stream实际上和文件系统中的IO流有很多类似的性质，比如，Stream只能使用一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">        System.out.println(stream);</span><br><span class="line">        System.out.println(stream.filter(item -&gt; item &gt; <span class="number">2</span>));</span><br><span class="line">        System.out.println(stream.distinct());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，会得到如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.util.stream.SliceOps$1@816f27d</span><br><span class="line">java.util.stream.ReferencePipeline$2@53d8d10a</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>

<p>可以看到我们在调用filter方法之后，就会抛出Stream已经被使用的异常，即便我们使用的不是终止操作，而只是一个中间操作，或者说，对于Stream的操作我们只能进行一次，其实中间操作都会返回一个新的Stream对象，为了说明这一点，我们来举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, item -&gt; item + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">        System.out.println(stream);</span><br><span class="line">        Stream&lt;Integer&gt; stream2 = stream.filter(item -&gt; item &gt; <span class="number">2</span>);</span><br><span class="line">        System.out.println(stream2);</span><br><span class="line">        Stream&lt;Integer&gt; stream3 = stream2.distinct();</span><br><span class="line">        System.out.println(stream3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们顺利的打印出了Stream对象，但其实每次打印的Stream对象都是不同的，实际使用的时候，我们更多的是使用链式的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.filter(item -&gt; item &gt; <span class="number">2</span>).distinct();</span><br></pre></td></tr></table></figure>

<p>接下来我们再了解流的另一个特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().map((item-&gt;&#123;</span><br><span class="line">            String result = item.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + item.substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会输出什么呢？答案是什么都不会，如果修改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().map(item -&gt; item.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + item.substring(<span class="number">1</span>)).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        list.stream().map((item -&gt; &#123;</span><br><span class="line">            String result = item.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + item.substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;)).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就会顺利的再控制台打印出我们想要的结果了。</p>
<p>这也是流的另一个重要的特性——流是惰性的，流只有在遇到终止操作的时候，才会真正的执行，而map是中间操作，因此流并没有被真正的调用，而forEach是终止操作，所以流会被正常的调用执行。</p>
<p>再来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.iterate(<span class="number">0</span>, i -&gt; (i + <span class="number">1</span>) % <span class="number">2</span>).distinct().limit(<span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>但程序并没有停止，而是在不停的运行，这是为什么呢？这是因为前面在不断的迭代产生0，1，而去重也并没有等待到新的值，所以程序会无限的运行下去，如果我们将刚才的操作反过来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">0</span>, i -&gt; (i + <span class="number">1</span>) % <span class="number">2</span>).limit(<span class="number">6</span>).distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>可以看到，控制台在输出了0，1之后就停止了，这是因为我们限制了只取流中的前六个元素，这提示我们在使用流的使用后一定要注意编写的顺序和流的相关特性。</p>
<h3 id="内部迭代和外部迭代"><a href="#内部迭代和外部迭代" class="headerlink" title="内部迭代和外部迭代"></a>内部迭代和外部迭代</h3><p>Stream和SQL语句其实非常的相似，例如，要完成这样的一个SQL的功能，使用SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name </span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> address <span class="operator">=</span> ‘beijing’ <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>该简单的sql所要表达的意思是：从student这张表中查询出年龄&gt;20并且地址=北京的记录，并且对年龄进行降序排序，排序之后将其名字查找出来。对于sql其实是一个描述性的语言，只描述其行为，而具体如何让db完成这个行为是没有暴露出来的，对于该sql所做的工作如果换成咱们的stream来实现那会是个什么样子呢，伪代码可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().filter(student -&gt; student.getAge() &gt; <span class="number">20</span>).filter(student -&gt; student.getAddress().equals(“beijing”))</span><br><span class="line">        .sorted(…).forEach(student -&gt; System.out.println(student.getName()));</span><br></pre></td></tr></table></figure>

<p>从表现形式上而言，Stream和SQL非常的类似，这是因为Stream也是属于一种描述性的语句， 整个语句并没有告诉底层Stream要如何去做，等于只要发一些指令给底层就可以了，具体底层怎么做完全不用关心。</p>
<p>如果使用原来传统的方式又该怎么做呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; students.size();i++)&#123;</span><br><span class="line">         Student student = students.get(i);</span><br><span class="line">         <span class="keyword">if</span>(student.getAge() &gt; <span class="number">20</span> &amp;&amp; student.getAddress().equals(“beijing”))&#123;</span><br><span class="line">             list.add(student);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     Collections.sort(list. Comparator()…);</span><br><span class="line">     <span class="keyword">for</span>(Student student : list)&#123;</span><br><span class="line">         System.out.println(student.getName());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用传统的方式，代码还相当冗余的，并且从易读性上而言，还是Stream的方式更加简洁明了，那什么是外部迭代，什么是内部迭代呢？实际上在Stream出现之前的都称之为外部迭代，使用Stream的就称之为内部迭代。</p>
<p>针对一个集合：</p>
<p><img src="assets/1600354418799.png" alt="1600354418799"></p>
<p>对于上面的例子而言：</p>
<p><img src="assets/1600354444327.png" alt="1600354444327"></p>
<p>集合与我们编写的处理逻辑之间是有清晰的划分的：</p>
<p><img src="assets/1600354460849.png" alt="1600354460849"></p>
<p><img src="assets/1600354474589.png" alt="1600354474589"></p>
<p>那对于Stream内部迭代的方式呢？</p>
<p><img src="assets/1600354503346.png" alt="1600354503346"></p>
<p>总的来说，集合关注的是数据与数据存储本身；而流关注的则是对数据的计算。流与迭代器类似的一点是：流是无法重复使用或消费的，并且流在调用的时候，并不是对于集合中所有的元素先调用第一个filter方法，再调用第二个filter方法，再调用其他方法，实际上并不是这样的，流会将执行的调用链的时候，会有一个容器将所有的操作保存下来，并且针对具体的操作，会优化调用顺序，这一点，在后面源代码分析的时候，就可以看到。</p>
<p>我们一直再说中间操作和终止操作，那如何判断一个操作是中间操作还是终止操作呢？简单来说，中间操纵都会返回一个Stream对象，而终止操作则不会返回Stream类型，可能不返回值，也可能返回其他类型的单个值。</p>
<h3 id="流的短路与并发流"><a href="#流的短路与并发流" class="headerlink" title="流的短路与并发流"></a>流的短路与并发流</h3><p>单从使用的角度而言，并发流与串行流的区别并不是很大，但在底层实现上是完全不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">50000000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">        list.stream().sorted().count();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        System.out.println(millis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要改用串行流改怎么做呢？仅仅需要将我们调用的方法修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.parallelStream().sorted().count();</span><br></pre></td></tr></table></figure>

<p>这也是使用内部迭代给我们带来的另一个好处，至于底层如何充分利用计算机资源帮助我们快速迭代，实际上在框架的底层就已经帮我们实现了，复杂性永远都是存在的，区别在于框架帮助我们实现了多少。当然，你可能会说，既然调用并行流这么方便，那是不是所有的场景下，都可以使用并行流来代替串行流？答案是否定的，并流行并不一定就比串行流的效率高，这取决于解决的实际问题，需要选择合适的方法，才能效率最高，这一点，在后续分析源码的时候就可以看到。</p>
<p>接下来我们讨论有关流的短路问题，首先来看这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().mapToInt(String::length).filter(length -&gt; length == <span class="number">5</span>).findFirst().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，如果有长度为5的字符串，就会在控制台打印字符5，将这个例子做如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().mapToInt(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> length = item.length();</span><br><span class="line">            System.out.println(item);</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;).filter(length -&gt; length == <span class="number">5</span>).findFirst().ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台会打印什么呢？答案是会在控制台打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>为什么会只打印hello呢？原因就在于虽然我们采用的是链式的调用，但其实在调用这些方法的时候并没有先后的顺序，对于流中元素进行处理的时候，会从流中的第一个元素开始应用所有对于流元素的操作，并且对于流的操作也有短路的特性，我们要找到长度为5的字符串，第一个元素就已经满足了所有的操作，所以后面的就不再执行了。</p>
<h3 id="分区于分组"><a href="#分区于分组" class="headerlink" title="分区于分组"></a>分区于分组</h3><p>我们曾经在内部迭代与外部迭代的章节中提到过，使用Stream的API很像在使用SQL语句，使用SQL语句进行分组的查询是一个很常见的需求，实际上，Stream也对分组提供了强有力的支持。</p>
<p>同样的，我们先创建一个学生类，并生成构造方法、setter、getter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来创建一些对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>, <span class="number">20</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">90</span>, <span class="number">30</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">80</span>, <span class="number">40</span>);</span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们使用传统的编码方式来实现对于名字的分组操作，大概要经历如下的步骤：</p>
<ol>
<li>循环列表</li>
<li>取出学生的名字</li>
<li>检查Map中是否存在该名字，不存在则直接添加到该Map中，存在则将Map中的List对象取出来，然后将该Student对象添加到List中</li>
<li>返回Map对象</li>
</ol>
<p>那如果我们使用函数式的编程方式呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName));</span><br></pre></td></tr></table></figure>

<p>只需要这一行代码就可以完成根据姓名对于学生的分组操作，这里面用到了Collectors这个类提供的静态方法groupingBy()，我们可以简单的看一下这个方法接收的参数以及它要完成的事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法本身是一个Function的函数式接口，Function我们都知道它接收一个参数，并且有返回值，正如它的方法名称那样描述的，我们需要提供分组的依据，这个方法的文档如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector implementing a &quot;group by&quot; operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map.</span><br></pre></td></tr></table></figure>

<p>这个方法对于给定的输入元素进行了排序的操作，并且返回了一个Map集合，看到这里我们就明白了，T实际上表示的就是流中的每个元素的类型，而我们通过方法引用的方式，返回了流中Student的姓名字段，流就会自动的为我们根据姓名来进行分类了,并且姓名这个字段会作为分组的key。</p>
<p>如果要根据年龄来分组呢，显然只要将分组的key换成分数就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getScore));</span><br></pre></td></tr></table></figure>

<p>接下来，我们尝试实现一个稍微复杂的需求，假设我们要实现与这样的SQL语句相同的功能：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<p>这里我们就要调用groupingBy的一个重载的方式来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>我们首先来看一下这里面调用的counting()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt;</span><br><span class="line">counting() &#123;</span><br><span class="line">    <span class="keyword">return</span> reducing(<span class="number">0L</span>, e -&gt; <span class="number">1L</span>, Long::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它的相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector accepting elements of type T that counts the number of input elements. If no elements are present, the result is 0.</span><br></pre></td></tr></table></figure>

<p>这个方法会统计流中元素的个数，如果没有元素，就会返回0。</p>
<p>我们通过这种方式就实现了上述SQL的需求，运行程序就会在控制台打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;lisi=1, zhangsan=2, wangwu=1&#125;</span><br></pre></td></tr></table></figure>

<p>我们再举一个例子，之前我们是对于分组中的元素个数进行统计，那如果我们想分组的时候也统计分数的平均值，这里我们也是需要使用另一个Collectors中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName, Collectors.averagingDouble(Student::getScore)));</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;lisi=90.0, zhangsan=90.0, wangwu=90.0&#125;</span><br></pre></td></tr></table></figure>

<p>与分组相关的实际上还有一个概念叫做分区，分区可以认为是特殊的分组，它只会分成两组，调用的Api分别是：</p>
<ul>
<li>分组：group by</li>
<li>分区：partition by</li>
</ul>
<p>比如，90分以上的分成一组，90分以下的分成一组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt;= <span class="number">90</span>));</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;false=[stream.Student@3d494fbf], true=[stream.Student@1ddc4ec2, stream.Student@133314b, stream.Student@b1bc7ed]&#125;</span><br></pre></td></tr></table></figure>

<p>至此，对于JDK8中的重要的API全部都介绍完成，学会使用是第一步也是非常重要的一步，在长时间的练习和记忆中，我们才能体会到函数式编程带给我们巨大好处，如果只是从使用的角度而言，掌握本章及之前的内容对于一般的开发者，完全是够用的，然而我想这是远远不够的，学习JDK中优秀的源码，反过来加深我们使用的时候的理解，达到相互促进的作用，这才是更重要的，因此，从下一章节开始，我们将系统而全面的分析JDK是如何实现函数式编程，以及我们之前使用的诸多的API在底层到底是如何实现的。</p>
<h2 id="Collector接口"><a href="#Collector接口" class="headerlink" title="Collector接口"></a>Collector接口</h2><p>Stream的源码复杂而多变，要掌握整个的流程，我们就不得不先要理清楚一些及其重要的概念和几个核心类的作用，当然一开始这是不太容易能够理解的，但是，这会为后面我们能完整的看到流的整个调用顺序打下良好的基础。</p>
<p>首先我们为接下来的部分提前定义好一个学生类作为我们分析源码的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Comparator源码分析及实践"><a href="#Comparator源码分析及实践" class="headerlink" title="Comparator源码分析及实践"></a>Comparator源码分析及实践</h3><p>Comparator并不是JDK8新增加的内容，但是JDK8对它做了一定程度的增强，在函数式编程中非常的常见，所以也非常的重要，在正式进入Stream源码分析之前，有必要了解关于Comparator比较器的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以看到这是一个函数式接口，拥有唯一的抽象方法compare，这个方法接口两个参数并且有返回值，并且在这个类中，JDK从1.8开始增加了若干个默认方法。</p>
<p>假如我们要对一个字符串数据按照首字母进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要按照长度来进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, (item1, item2) -&gt; item1.length() - item2.length());</span><br></pre></td></tr></table></figure>

<p>也可以使用方法引用的方式来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length));</span><br></pre></td></tr></table></figure>

<p>如果是降序则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, (item1, item2) -&gt; item2.length() - item1.length());</span><br></pre></td></tr></table></figure>

<p>同样的，也可以使用方法引用的方式来实现，只是这里我们调用新的方法reversed：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length).reversed());</span><br></pre></td></tr></table></figure>

<p>但是如果你这么写的话，就会发现有问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(item -&gt; item.length()).reversed());</span><br></pre></td></tr></table></figure>

<p>看起来与上面的写法是完全等价的，但IDE却会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cannot resolve method &#x27;length()&#x27;</span><br></pre></td></tr></table></figure>

<p>原因就在于，编译器会认为此时的item是一个Object类型的对象，如果要正常编译运行，就需要显示的声明类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt((String item) -&gt; item.length()).reversed());</span><br></pre></td></tr></table></figure>

<p>在我们之前的所有的例子当中，编译器都可以自动的推断出元素的类型，在这个例子当中，接收的参数ToIntFunction&lt;? super T&gt;由于没有明确的上下文（可能是T类型，也有可能是T类型以上的类型），并且由于调用了reversed获取了新的比较器，所以编译器没有办法准确的推断出类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparingInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(keyExtractor);</span><br><span class="line">      <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">          (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里为什么会是T类型以及T类型以上的类型呢？简而言之，就是可以传入自己本身以及父类的比较器，而如果传入的是父类型的比较器，比较完成之后还是会强转会原来的类型。</p>
<p>其实我们也可以直接调用list的sort方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(Comparator.comparingInt(String::length).reversed());</span><br></pre></td></tr></table></figure>

<p>上面的方法都是一次排序，接下来我们看多次排序的方法，比如现根据名称排序，排好序之后对于名称相同的再根据分数进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length).thenComparing((item1, item2) -&gt; item1.compareToIgnoreCase(item2)));</span><br></pre></td></tr></table></figure>

<p>其实我们也可以这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>

<p>这里我们使用的静态的常量是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">                                     = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br></pre></td></tr></table></figure>

<p>这个类本身就定义在String类当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8575799808933029326L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(n1, n2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                c1 = Character.toUpperCase(c1);</span><br><span class="line">                c2 = Character.toUpperCase(c2);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    c1 = Character.toLowerCase(c1);</span><br><span class="line">                    c2 = Character.toLowerCase(c2);</span><br><span class="line">                    <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                        <span class="comment">// No overflow because of numeric promotion</span></span><br><span class="line">                        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而对于thenComparing方法而言：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order.</span><br></pre></td></tr></table></figure>

<p> 与另一个比较器相比，它返回一个字典顺序的比较器，如果它的前一个比较器返回是元素的相等的情况，即compare(a, b) == 0的情况下，当前传入的比较器就会发挥作用，进行二次排序，这意味着，如果前面的比较器返回的结果不是0，那么后面的比较器就不会再调用，这一点在源代码中也有体现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> res = compare(c1, c2);</span><br><span class="line">        <span class="comment">// 当比较的结果不为0的时候直接返回，相等再执行传入的比较器。</span></span><br><span class="line">        <span class="keyword">return</span> (res != <span class="number">0</span>) ? res : other.compare(c1, c2);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你还可以这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list,Comparator.comparingInt(String::length).thenComparing(Comparator.comparing(String::toLowerCase)));</span><br></pre></td></tr></table></figure>

<p>类似的，比较器也可以进行复合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, Comparator.comparingInt(String::length).thenComparing(String::toLowerCase, Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure>

<p>比这个例子稍微复杂一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list,Comparator.comparingInt(String::length).reversed().thenComparing(String::toLowerCase, Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure>

<h3 id="Collector源码分析"><a href="#Collector源码分析" class="headerlink" title="Collector源码分析"></a>Collector源码分析</h3><p>Collector无疑是整个Stream源码中及其重要的一个类，了解它对于我们认识Stream类有着及其关键的作用，首先回到我们之前的例子当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">        List&lt;Student&gt; studentList = students.stream().collect(Collectors.toList());</span><br><span class="line">        studentList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毫无疑问，到目前这个阶段，这样的代码我们应该已经掌握的非常的熟练了，现在假设说要求使用流的方式求出列表的长度改怎么做呢？你可以使用Collectors中的静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;count: &quot;</span> + students.stream().collect(Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>可以看到，实际使用的时候，使用collect（收集器）的频率非常的高，collect本身的定义是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它本身接收一个参数叫做collector，是Collector类型的，接下来的章节重点分析这个类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel.</span><br><span class="line">Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing &quot;pivot table&quot; summaries such as &quot;maximum valued transaction by seller&quot;, etc. The class Collectors provides implementations of many common mutable reductions.</span><br></pre></td></tr></table></figure>

<p>它是一个可变的汇聚操作，作用是将输入元素累积到一个可变的结果容器当中。它可以在所有的元素都处理完毕后，将累积的结果转换为一个最终的表示（这是一个可选的操作），它支持串行与并行两种方式执行。什么是可变的汇聚操作呢？比如将集合中的元素添加到Collection当中，再比如使用StringBuilder将字符串拼接起来，计算关于元素的求和、最小值、最大值、平均值，这也是一种可变操作，计算“数据透视图”的时候一些汇总信息，比如计算卖方交易数量的最大值，Collectors提供了很多对于常见的可变的汇聚操作的实现（Collectors是Collector的实现类，而Collectors本身实际上是一个工厂）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are:</span><br></pre></td></tr></table></figure>

<p>Collector是由以下四个方法构成，用来完成向一个可变结果容器当中添加元素的，并且对于结果进行最终的转换：</p>
<ul>
<li>creation of a new result container (supplier())</li>
<li>incorporating a new data element into a result container (accumulator())</li>
<li>combining two result containers into one (combiner())</li>
<li>performing an optional final transform on the container (finisher())</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A function that creates and returns a new mutable result container.</span><br></pre></td></tr></table></figure>

<p>supplier()是用来创建新的可变的结果容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A function that folds a value into a mutable result container.</span><br></pre></td></tr></table></figure>

<p>accumulator()是用来将一个新的数据元素添加到结果容器当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container.</span><br></pre></td></tr></table></figure>

<p>combiner函数接收两个部分的结果并且合并它们，combiner函数可以将状态从一个折叠成为另一个，并且返回它们，也可能返回一个新的结果容器，实际上这个是在并行中使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Perform the final transformation from the intermediate accumulation type A to the final result type R.</span><br><span class="line">If the characteristic IDENTITY_TRANSFORM is set, this function may be presumed to be an identity transform with an unchecked cast from A to R.</span><br></pre></td></tr></table></figure>

<p>是将中间的累积类型转换称为最终的结果类型，如果设置了IDENTITY_TRANSFORM这个特性，那么这个函数就会直接将A转型为R。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collectors also have a set of characteristics, such as Collector.Characteristics.CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance.</span><br></pre></td></tr></table></figure>

<p>Collectors还有一个描述特征的的集合，比如Collector.Characteristics.CONCURRENT，它可以通过不同的枚举值来提高并发流的执行效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Characteristics</span> </span>&#123;</span><br><span class="line">    CONCURRENT，</span><br><span class="line">    UNORDERED,</span><br><span class="line">    IDENTITY_FINISH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个枚举是定义在Collector这个接口当中的，首先来看一下类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Characteristics indicating properties of a Collector, which can be used to optimize reduction implementations.</span><br></pre></td></tr></table></figure>

<p>Characteristics是Collector的一个属性，能够优化汇聚操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element. A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result.</span><br></pre></td></tr></table></figure>

<p>对于流的串行实现会创建一个单个的结果容器，并且每个元素会调用accumulator方法一次，而对于并行实现将会对输入进行分区，对于每一个分区都会创建一个结果容器，然后使用combiner方法将每个分区的结果容器当中的内容进行合并。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints.</span><br></pre></td></tr></table></figure>

<p>为了确保串行与并行生成等价的结果，collector必须满足两个条件，即identity（同一性）和associativity（结合性）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()).</span><br></pre></td></tr></table></figure>

<p>同一性指的是，部分累积的结果与一个空的结果容器运算之后还是它本身，这也就是说，对于一个部分累积的结果a而言，它要满足combiner.apply(a, supplier.get())等于a。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent:</span><br></pre></td></tr></table></figure>

<p>结合性指的是分割计算也会得到一个等价的结果，也就是说对于任意的输入t1和t2，和产生的结果r1和r2，下面的计算是等价的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 串行操作</span></span><br><span class="line">A a1 = supplier.get();</span><br><span class="line">   accumulator.accept(a1, t1);</span><br><span class="line">   accumulator.accept(a1, t2);</span><br><span class="line">   R r1 = finisher.apply(a1);</span><br><span class="line"><span class="comment">// 并行操作</span></span><br><span class="line">   A a2 = supplier.get();</span><br><span class="line">   accumulator.accept(a2, t1);</span><br><span class="line">   A a3 = supplier.get();</span><br><span class="line">   accumulator.accept(a3, t2);</span><br><span class="line">   R r2 = finisher.apply(combiner.apply(a2, a3)); </span><br></pre></td></tr></table></figure>

<p>也就是说无论对于串行操作还是并行操作，最终生成的结果必须是等价的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)). For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.)</span><br></pre></td></tr></table></figure>

<p>对于没有UNORDERED特性的collectors来说，如果finisher.apply(a1).equals(finisher.apply(a2))，这两种累加的结果是等价的，对于无序的要求就被放松了，它会考虑到顺序上的区别带来的不相等性，比如无序的collector它累积元素到一个List当中，就会两个List是相同的，他们包含了相同的元素，忽略了顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints:</span><br></pre></td></tr></table></figure>

<p>基于Collector实现汇聚操作的库，比如Stream.collect(Collector)，必须要遵守下面的约定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.</span><br></pre></td></tr></table></figure>

<p>传递给accumulator方法的第一个参数，以及传递给combiner方法的两个参数，以及传递给finisher的参数，它们必须都是result supplier, accumulator, combiner上一次调用的结果。</p>
<p>看到这里还是比较难以理解的，我们首先需要理解Collector泛型的含义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; – the type of input elements to the reduction operation</span><br><span class="line">&lt;A&gt; – the mutable accumulation type of the reduction operation (often hidden as an implementation detail)</span><br><span class="line">&lt;R&gt; – the result type of the reduction operation</span><br></pre></td></tr></table></figure>

<p>T类型表示进行汇聚操作的输入元素的类型，即流中的每一个元素的类型，A类型表示汇聚操作的可变的累积类型，可以认为是每次中间结果容器的类型，R类型表示汇聚操作的结果类型，这个时候我们再来分析一个这四个方法对应的泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>BinaryOperator是因为合并的是两个部分的结果容器的类型，那最终的结果一定也是A类型，从泛型的角度就可以清楚的认识到，对于每一次的调用，supplier提供的结果容器就会传递给accumulator，而accumulator将流中待处理的元素添加到结果容器之后，又将这个部分结果传递给combiner，依次类推。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.</span><br></pre></td></tr></table></figure>

<p>对于具体的实现不应该对生成的supplier、accumulator、combiner做任何的事情，除了将他们再一次传递给accumulator、combiner或者finisher方法，否则将他们返回给汇聚操作的调用者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</span><br></pre></td></tr></table></figure>

<p>如果一个结果被传递给combiner或者finisher函数了，并没有返回相同的类型的对象，那么它就再也不会被使用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.</span><br></pre></td></tr></table></figure>

<p>一旦一个结果被传递给了combiner或者finisher方法，它就不会再被accumulator方法使用了（这是因为调用顺序的原因）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined. This enables collection to occur in parallel without the Collector needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.</span><br></pre></td></tr></table></figure>

<p>对于非并发的collectors，从supplier, accumulator, 或者 combiner中返回的结果都一定是线程封闭的，不会被其他线程使用，这样在并发的情况下，就不用再做其他的操作来保证线程安全，每一个部分的操作都是独立的，并且只有当部分完成之后猜会进行合并的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the Collector.Characteristics.UNORDERED characteristics or if the originating data is unordered.</span><br></pre></td></tr></table></figure>

<p>对于并发的collectors，实现是可以自由的实现，一个多线程的汇聚操作指的是accumulator同时被多个线程调用，他们可以使用相同的可以并发修改的结果容器，而不是保持独立，一个并发的结果容器在什么情况下使用呢？只有当特性值设置为UNORDERED的时候，或者数据源本身不要求有序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In addition to the predefined implementations in Collectors, the static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics...) can be used to construct collectors. For example, you could create a collector that accumulates widgets into a TreeSet with:</span><br></pre></td></tr></table></figure>

<p>除了在Collectors预先定义好的静态工厂方法可以创建一个收集器之外，还可以使用Collector中的of方法，比如你可以使用下面的方式将widget累积到TreeSet当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =</span><br><span class="line">         Collector.of(TreeSet::<span class="keyword">new</span>, TreeSet::add,</span><br><span class="line">                      (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;);</span><br></pre></td></tr></table></figure>

<p>实际上就是除了预先定义好的收集器，我们可以通过Collector中的of方法实现自定的收集器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performing a reduction operation with a Collector should produce a result equivalent to:</span><br></pre></td></tr></table></figure>

<p>使用一个Collector执行汇聚操作会生成的结果应该和下面的结果等价:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R container = collector.supplier().get();</span><br><span class="line">     <span class="keyword">for</span> (T t : data)</span><br><span class="line">         collector.accumulator().accept(container, t);</span><br><span class="line">     <span class="keyword">return</span> collector.finisher().apply(container);</span><br></pre></td></tr></table></figure>

<p>这其实就是汇聚操作的整个过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction. (Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.)</span><br></pre></td></tr></table></figure>

<p>然而，库可以自由的对输入元素分组与分区，在每一个分区上执行这种汇聚操作，然后使用combiner方法合并部分的结果执行一个并行的汇聚操作（取决于具体的并行操作的类型，这可能效率高，也可能效率会变低，这取决于accumulator和combiner消耗的成本和代价）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collectors are designed to be composed; many of the methods in Collectors are functions that take a collector and produce a new collector. For example, given the following collector that computes the sum of the salaries of a stream of employees:</span><br></pre></td></tr></table></figure>

<p>收集器是被设计成可以组合的，这意味着，Collectors很多方法可以接收collector作为参数返回一个新的collector，例如一个员工构成的流的工资的总数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Employee, ?, Integer&gt; summingSalaries</span><br><span class="line">        = Collectors.summingInt(Employee::getSalary))</span><br></pre></td></tr></table></figure>

<p>如果我们想实现收集器的复合改怎么做呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the &quot;sum of salaries&quot; logic using Collectors.groupingBy(Function, Collector):</span><br></pre></td></tr></table></figure>

<p>如果以向创建一个根据部门对于工资的总和表格化，我们就可以重用“工资总和”逻辑，然后使用分组方法Collectors.groupingBy(Function, Collector):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept</span><br><span class="line">        = Collectors.groupingBy(Employee::getDepartment, summingSalaries);</span><br></pre></td></tr></table></figure>

<p>这里的第二个参数就是我们上面定义过的收集器，这就实现了收集器的复合。</p>
<h3 id="Collector实践"><a href="#Collector实践" class="headerlink" title="Collector实践"></a>Collector实践</h3><p>Collector接口有且仅有唯一的实现类CollectorImpl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectorImpl</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;A&gt; supplier;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiConsumer&lt;A, T&gt; accumulator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BinaryOperator&lt;A&gt; combiner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, R&gt; finisher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Characteristics&gt; characteristics;</span><br><span class="line"></span><br><span class="line">    CollectorImpl(Supplier&lt;A&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;A, T&gt; accumulator,</span><br><span class="line">                  BinaryOperator&lt;A&gt; combiner,</span><br><span class="line">                  Function&lt;A,R&gt; finisher,</span><br><span class="line">                  Set&lt;Characteristics&gt; characteristics) &#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">        <span class="keyword">this</span>.accumulator = accumulator;</span><br><span class="line">        <span class="keyword">this</span>.combiner = combiner;</span><br><span class="line">        <span class="keyword">this</span>.finisher = finisher;</span><br><span class="line">        <span class="keyword">this</span>.characteristics = characteristics;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CollectorImpl(Supplier&lt;A&gt; supplier,</span><br><span class="line">                  BiConsumer&lt;A, T&gt; accumulator,</span><br><span class="line">                  BinaryOperator&lt;A&gt; combiner,</span><br><span class="line">                  Set&lt;Characteristics&gt; characteristics) &#123;</span><br><span class="line">        <span class="keyword">this</span>(supplier, accumulator, combiner, castingIdentity(), characteristics);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> combiner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> finisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> characteristics;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这个类没有定义在一个单独的文件当中，而是定义在Collectors当中，这个类本身并没有做任何事情，只是根据Collector接口的要求，将需要的属性和方法定义好。这么做的理由是什么呢？实际上是一种设计上的考量，Collectors类被用来生产一些常见的方法，它绝大部分的方法都是静态方法，可以直接调用，而作为Collector的工厂，所有的方法一定会返回CollectorImpl类型，而在别的地方，又不会用到CollectorImpl，所以设计者直接将这个类作为一个静态的内部类。</p>
<p>接下来我们就围绕Collectors为我们提供的诸多的静态方法展开，了解这些方法的使用以及实现细节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</span><br></pre></td></tr></table></figure>

<p>Collectors实现了Collector接口并提供了很多很有用的汇聚操作，比如将元素累积到一个集合当中，比如摘要（最大值、最小值、平均值等等）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following are examples of using the predefined collectors to perform common mutable reduction tasks:</span><br></pre></td></tr></table></figure>

<p>下面的例子就是使用JDK预先定义好的方法来执行可变的汇聚任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accumulate names into a List</span></span><br><span class="line">List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accumulate names into a TreeSet</span></span><br><span class="line">Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert elements to strings and concatenate them, separated by commas</span></span><br><span class="line">String joined = things.stream()</span><br><span class="line">                      .map(Object::toString)</span><br><span class="line">                      .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute sum of salaries of employee</span></span><br><span class="line"><span class="keyword">int</span> total = employees.stream()</span><br><span class="line">                     .collect(Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group employees by department</span></span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept</span><br><span class="line">    = employees.stream()</span><br><span class="line">               .collect(Collectors.groupingBy(Employee::getDepartment));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute sum of salaries by department</span></span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept</span><br><span class="line">    = employees.stream()</span><br><span class="line">               .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                              Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partition students into passing and failing</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing =</span><br><span class="line">    students.stream()</span><br><span class="line">            .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>

<p>在完整的理解了收集器相关的概念之后，我们可以看一些具体的例子，针对于之前的学生的集合，如果我们想求出学生分数的最小值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.minBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<p>如果是最大值呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.maxBy(Comparator.comparingInt(Student::getScore))).ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<p>如果是平均值呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println( students.stream().collect(Collectors.averagingInt(Student::getScore)));</span><br></pre></td></tr></table></figure>

<p>如果是求出分数的总和呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().collect(Collectors.summingInt(Student::getScore)));</span><br></pre></td></tr></table></figure>

<p>当然也可以调用统计的方法一次将这些特征值都求出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().collect(Collectors.summarizingInt(Student::getScore)));</span><br></pre></td></tr></table></figure>

<p>如果想将学生的名字使用字符串拼接呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining()));</span><br></pre></td></tr></table></figure>

<p>还可以使用逗号分隔：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>还可以拼接前缀和后缀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&lt;begin&gt;&quot;</span>,<span class="string">&quot;&lt;end&gt;&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>除了这些常规的操作，其实对于分组的操作还可以进行二级分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getScore,Collectors.groupingBy(Student::getName)));</span><br></pre></td></tr></table></figure>

<p>类似的对于分区的操作也可以进行二级分区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt; <span class="number">90</span>, Collectors.        partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>)));</span><br></pre></td></tr></table></figure>

<p>分组和分区还可以互相嵌套：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>, Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>下面我们来看一个稍微复杂一点的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getName,Collectors.collectingAndThen(Collectors.minBy(Comparator.comparingInt(Student::getScore)), Optional::get)));</span><br></pre></td></tr></table></figure>

<h3 id="自定义Collector"><a href="#自定义Collector" class="headerlink" title="自定义Collector"></a>自定义Collector</h3><p>在进行Collector源码分析的时候，我们提到过Characteristics这个内部枚举类，接下来我们首先分析每一个枚举项代表的含义：</p>
<p>1、CONCURRENT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that this collector is concurrent, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads.</span><br><span class="line">If a CONCURRENT collector is not also UNORDERED, then it should only be evaluated concurrently if applied to an unordered data source.</span><br></pre></td></tr></table></figure>

<p>CONCURRENT表示当前的收集器是并发的，这意味着中间结果容器支持使用多线程进行并发访问，CONCURRENT并不是UNORDERED，只有无序的数据源才可以使用这个属性。</p>
<p>2、UNORDERED</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that the collection operation does not commit to preserving the encounter order of input elements. (This might be true if the result container has no intrinsic order, such as a Set.)</span><br></pre></td></tr></table></figure>

<p>UNORDERED意味着收集的操作并不确保保留输入元素的顺序（可以用在结果容器不要求有序的场景下，比如Set）</p>
<p>3、IDENTITY_FINISH</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that the finisher function is the identity function and can be elided. If set, it must be the case that an unchecked cast from A to R will succeed.</span><br></pre></td></tr></table></figure>

<p>IDENTITY_FINISH表示finisher方法就是identity方法，可以被省略掉，如果设置了这个属性，那么就要确保从A类型到R类型的强制转换是可以成功的。</p>
<p>接下来我们实现一个自定义的收集器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplier invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里不能调用HashSet::add，因为无法保证与supplier()方法返回的中间结果容器类型相同</span></span><br><span class="line">        <span class="keyword">return</span> Set::add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;combiner invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finisher invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;characteristics invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; set = list.stream().collect(<span class="keyword">new</span> MySetCollector&lt;&gt;());</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">[world, hello, welcome]</span><br></pre></td></tr></table></figure>

<p>可以看到supplier、accumulator、combiner分别执行了一次，而characteristics执行了两次，只有finisher没有被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> P_OUT, A, R&gt; collector)</span> </span>&#123;</span><br><span class="line">    A container;</span><br><span class="line">    <span class="comment">// 如果是并行流</span></span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// characteristics()在这里被第二次调用，用于判断中间结果容器与最终返回的类型是否相同,如果包含了IDENTITY_FINISH这个特性，直接进行强制类型转换，会将中间结果容器强制转换为最终的结果类型。</span></span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们显然是串行流，所以直接进入到第二种情况，首先我们来看一下ReduceOps的makeRef方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, I&gt; <span class="function">TerminalOp&lt;T, I&gt;</span></span><br><span class="line"><span class="function">   <span class="title">makeRef</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, I, ?&gt; collector)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 我们的方法就是在这里被调用了，返回了supplier、accumulator、combiner三个对象。</span></span><br><span class="line">       Supplier&lt;I&gt; supplier = Objects.requireNonNull(collector).supplier();</span><br><span class="line">       BiConsumer&lt;I, ? <span class="keyword">super</span> T&gt; accumulator = collector.accumulator();</span><br><span class="line">       BinaryOperator&lt;I&gt; combiner = collector.combiner();</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">ReducingSink</span> <span class="keyword">extends</span> <span class="title">Box</span>&lt;<span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">               <span class="keyword">implements</span> <span class="title">AccumulatingSink</span>&lt;<span class="title">T</span>, <span class="title">I</span>, <span class="title">ReducingSink</span>&gt; </span>&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">               state = supplier.get();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">               accumulator.accept(state, t);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(ReducingSink other)</span> </span>&#123;</span><br><span class="line">               state = combiner.apply(state, other.state);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ReduceOp&lt;T, I, ReducingSink&gt;(StreamShape.REFERENCE) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ReducingSink <span class="title">makeSink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> ReducingSink();</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">// Characteristics()在这里被第一次调用，用于判断是否有序</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.UNORDERED)</span><br><span class="line">                      ? StreamOpFlag.NOT_ORDERED</span><br><span class="line">                      : <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>为了验证关于Characteristics方法的调用逻辑，我们去掉characteristics方法中的枚举项IDENTITY_FINISH：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;characteristics invoked!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of( Characteristics.UNORDERED));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>观察结果，finsher就得到了调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">[world, hello, welcome]</span><br></pre></td></tr></table></figure>

<p>接下来我们定义一个中间结果容器需要进行类型转换的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Map</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;supplier invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set, item) -&gt; set.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;combiner invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finisher invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> set -&gt; &#123;</span><br><span class="line">            Map&lt;T, T&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">            set.forEach(item -&gt; map.put(item, item));</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;characteristics invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;welcome&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.addAll(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;set: &quot;</span> + set);</span><br><span class="line">        Map&lt;String, String&gt; map = set.stream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>

<p>如果将这个枚举值修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED,Characteristics.IDENTITY_FINISH));</span><br></pre></td></tr></table></figure>

<p>就会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.util.HashSet cannot be cast to java.util.Map</span><br></pre></td></tr></table></figure>

<p>这就是因为我们的中间结果类型是Set类型，而最终的结果类型是Map类型，同时也说明了characteristics就定义了中间结果容器和最终结果的结果容器类型的关系，在运行期间，JDK会根据这个枚举项类判断他们之间的关系，如果编写错误了，就可能会出现错误。</p>
<p>另外如果中间结果容器和最终结果的结果容器类型相同，但是需要对于中间结果容器做一些处理才返回结果，这个时候也要去掉IDENTITY_FINISH这个枚举值，因为在执行过程中，会直接转换类型，而不会操作里面的值。</p>
<p>如果我们在accumulator中打印当前线程的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (set, item) -&gt; &#123;</span><br><span class="line">        set.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台就会打印十次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: main</span><br></pre></td></tr></table></figure>

<p>去掉集合中重复的元素”hello”,正好是十个元素，执行了十次累积的操作，并且都是主线程的，如果我们使用并行流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.parallelStream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>运行的结果就变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">accmulator: main</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-5</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-4</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-5</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便观察并行流和串行流的区别，我们打印一下，进行累积操作的集合中的元素，再次运行，就会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">accmulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">[hello]</span><br><span class="line">[b]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">accmulator: main</span><br><span class="line">[f]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[d]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[d, e]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-4</span><br><span class="line">[f, g]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[b, world]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[b, world, c]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[a]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-5</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>

<p>这里就会开启多个线程，这个时候如果再设置CONCURRENT特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT));</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">====================================</span><br><span class="line">accmulator invoked!</span><br><span class="line">[hello]</span><br><span class="line">accmulator: main</span><br><span class="line">[hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[f, hello, welcome]</span><br><span class="line">[b, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[a, b, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-4</span><br><span class="line">[a, b, world, d, f, g, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-3</span><br><span class="line">[a, b, world, d, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">[a, b, d, f, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-1</span><br><span class="line">[a, b, world, c, d, f, g, hello, welcome]</span><br><span class="line">accmulator: ForkJoinPool.commonPool-worker-2</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, world=world, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome&#125;</span><br></pre></td></tr></table></figure>

<p>如果执行的次数过多，还有可能会出现如下报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException: java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<p>这是因为设置了CONCURRENT特性，多个线程就会操作同一个中间结果容器，而在我们的程序中，除了往集合中不断累加元素之外，还在打印集合中的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;accmulator invoked!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (set, item) -&gt; &#123;</span><br><span class="line">        set.add(item);</span><br><span class="line">        System.out.println(<span class="string">&quot;accmulator: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将导致，偶发的情况下就会出现并发修改的异常，这就要求在在定义Collector的是偶，如果设置了CONCURRENT特性，accumulator方法只能进行累积的操作，而尽量不要进行其他的操作。</p>
<p>总结一下，在使用并行流的时候，如果设置了CONCURRENT特性，那么多个线程就会操作操作同一个中间结果容器，而这个唯一的结果容器就是最终的结果容器，如果没有设置这个特性，那么就会操作不同的中间结果容器，换言之，如果设置了CONCURRENT特性，那么combiner就不会被调用，因为无需进行最后的合并操作，而如果没有设置，那么combiner就会得到调用。</p>
<p>总而言之combiner被调用有两个条件，一个是并行流，一个是没有设置CONCURRENT特性，中间结果容器的个数也是类似的，只有当开启并行流，并且没有设置过CONCURRENT特性的时候才会创建和流中元素个数相同的中间结果容器。</p>
<p>开启并行流的方式除了之前我们使用过的parallelStream，其实还可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().parallel().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>如果要使用串行流，你也可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().sequential().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>甚至可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().sequential().parallel().sequential().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，这里程序并不会依次的调用，而是会调用最后指定的方式，也就是说，上面的代码其实等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = set.stream().sequential().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>这两种写法完全是等价的，这是因为，选择并行流还是串行流，仅仅是由一个布尔值来控制的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * True if pipeline is parallel, otherwise the pipeline is sequential; only</span></span><br><span class="line"><span class="comment">  * valid for the source stage.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> parallel;</span><br></pre></td></tr></table></figure>

<h3 id="Collectors源码分析"><a href="#Collectors源码分析" class="headerlink" title="Collectors源码分析"></a>Collectors源码分析</h3><p>自定义Collector的过程帮助我们很好的理解了关于Collector的基本概念，我们也尝试着自己实现了两个相对比较简单的例子，Collectors作为生产Collector的静态工厂类，里面有大量的关于Collector的实现，本节我们就分析JDK已经帮我们实现的Collector的例子，学习这些例子，有助于我们强化对于Collector的理解。</p>
<p>对于Collectors静态工厂来说，实现Collector，总的来说分为两种情况：</p>
<ol>
<li>通过CollectorImpl来实现</li>
<li>通过reducing方法来实现，而reducing方法本身又是通过CollectorImpl来实现的。</li>
</ol>
<p>首先我们来分析一下我们使用过的最多的toList方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                CH_ID);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的(Supplier&lt;List<T>&gt;) ArrayList::new也可以写成<code>ArrayList&lt;T&gt;::new</code>，这里的第四个参数是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Collector.Characteristics&gt; CH_ID</span><br><span class="line">        = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));</span><br></pre></td></tr></table></figure>

<p>这里的属性值是IDENTITY_FINISH，意味着中间结果容器的类型和最终返回的结果类型相同，所以无需定义finisher。对于toList还有一个接受的更宽广的toCollection：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line"> Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                                (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                                CH_ID);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里只是提供了创建结果容器的入口，例如，要使用LinkedList，你只需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p>对于toSet方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"> Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::<span class="keyword">new</span>, Set::add,</span><br><span class="line">                                (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                                CH_UNORDERED_ID);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由于Set集合本身是无序的，并且最终返回的结果也是Set类型，所以它的特性值是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Collector.Characteristics&gt; CH_UNORDERED_ID</span><br><span class="line">        = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.UNORDERED,</span><br><span class="line">                                                 Collector.Characteristics.IDENTITY_FINISH));</span><br></pre></td></tr></table></figure>

<p>对于joining方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>joining方法与之前的方法不同的是，它还调用了finisher方法，这是因为需要将StringBuilder转为String类型。这里的第四个参数指的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Collector.Characteristics&gt; CH_NOID = Collections.emptySet();</span><br></pre></td></tr></table></figure>

<p>返回的是一个空的集合，说明三个特性都不具备。</p>
<p>joining还有一个重载的方法，可以增加前缀和后缀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                         CharSequence prefix,</span><br><span class="line">                                                         CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> StringJoiner(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringJoiner是JDK1.8提供的一个新的类，用于完成字符串的拼接操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt;</span><br><span class="line">Collector&lt;T, ?, R&gt; mapping(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                           Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream) &#123;</span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> U&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">                               (r, t) -&gt; downstreamAccumulator.accept(r, mapper.apply(t)),</span><br><span class="line">                               downstream.combiner(), downstream.finisher(),</span><br><span class="line">                               downstream.characteristics());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个相对比较复杂的例子，我们先来读一下方法说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation.</span><br></pre></td></tr></table></figure>

<p>mapping方法被用来在累积操作之前对每个输入元素都应用mapping方法，将接收的U类型映射为T类型，从而实现收集器的映射。</p>
<p>方法本身接收两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapper – a function to be applied to the input elements</span><br><span class="line">downstream – a collector which will accept mapped values</span><br></pre></td></tr></table></figure>

<p>这里的下游指的是，将要被映射的值，给出了一个具体的案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity</span><br><span class="line">        = people.stream().collect(groupingBy(Person::getCity,</span><br><span class="line">                                             mapping(Person::getLastName, toSet())));</span><br></pre></td></tr></table></figure>

<p>比这个例子稍微复杂一点的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="title">collectingAndThen</span><span class="params">(Collector&lt;T,A,R&gt; downstream,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                            Function&lt;R,RR&gt; finisher)</span> </span>&#123;</span><br><span class="line">    Set&lt;Collector.Characteristics&gt; characteristics = downstream.characteristics();</span><br><span class="line">    <span class="keyword">if</span> (characteristics.contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (characteristics.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 如果只有IDENTITY_FINISH特性，就将特性值设置为空</span></span><br><span class="line">            characteristics = Collectors.CH_NOID;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将IDENTITY_FINISH去掉</span></span><br><span class="line">            characteristics = EnumSet.copyOf(characteristics);</span><br><span class="line">            characteristics.remove(Collector.Characteristics.IDENTITY_FINISH);</span><br><span class="line">            characteristics = Collections.unmodifiableSet(characteristics);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">                               downstream.accumulator(),</span><br><span class="line">                               downstream.combiner(),</span><br><span class="line">                               downstream.finisher().andThen(finisher),</span><br><span class="line">                               characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先来读一下方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adapts a Collector to perform an additional finishing transformation. For example, one could adapt the toList() collector to always produce an immutable list with:</span><br></pre></td></tr></table></figure>

<p>适配一个Collector来执行finisher方法的转换，例如，我们可以使用这个方法将使用toList收集的方法来转换为一个不可变的集合，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; people</span><br><span class="line">       = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));</span><br></pre></td></tr></table></figure>

<p>toList本身方法返回的是一个ArrayList对象，本身是可变的，通过这种方式就可以得到一个不可变的集合列表，方法实现中将原来流中的IDENTITY_FINISH特性去掉的原因在于，如果设置了这个特性值，finisher方法就不会得到执行，而collectingAndThen方法的目的就在于转换最终的结果类型，关键就在于需要执行的finisher方法。</p>
<p>接下来我们看一个之前使用的方法，summingInt的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt;</span><br><span class="line">summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>],</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] += mapper.applyAsInt(t); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] += b[<span class="number">0</span>]; <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>summingInt方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector that produces the sum of a integer-valued function applied to the input elements. If no elements are present, the result is 0.</span><br></pre></td></tr></table></figure>

<p> 返回的Collector是对流中的每一个元素执行传入的整型值函数，如果流中没有元素，就返回0。</p>
<p>需要说明的是，这里为什么不直接使用数字，而是new了一个int类型的数组，原因在于数字是值类型的，而数组是引用类型的，值类型的参数无法进行传递，数组本身也符合容器的定义，只不过这里每次只是取出来数组中唯一的元素，对数组中唯一的元素进行累加的操作。</p>
<p>以上都是通过CollectorImpl来实现的Collector，接下来我们看一下通过reducing来实现的例子，首先来查看reducing方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reducing方法也是借助CollectorImpl来实现的Collector的，我们来阅读一下reducing方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector which performs a reduction of its input elements under a specified mapping function and BinaryOperator. This is a generalization of reducing(Object, BinaryOperator) which allows a transformation of the elements before reduction.</span><br></pre></td></tr></table></figure>

<p>groupingBy和partitioningBy是整个Collectors类中比较难以理解的两部分，关键的部分在于，理解每个泛型代表的含义以及每个参数的作用，在有了前面的基础之后，我们有必要了解一下有关分区和分组的实现。首先来看一下groupingBy方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T类型表示流中元素的类型，？表示的是中间结果容器的类型，Map是最终的结果类型，K表示分类的时候的key的类型，<code>List&lt;T&gt;</code>就表示根据分类依据K分类之后的列表集合，方法本身的参数并没有直接使用T和K，而是使用T类型以及T以上的类型，K类型以及K类型以下的类型，并且只接受一个参数，调用了另一个重载的groupingBy方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                      Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的第一个参数是一个Function类型，第二个参数是Collector类型的，同样的，我们需要搞清楚这里每一个泛型的含义，T表示流中元素的类型，K表示分类器返回的结果的类型，或者说是返回的Map的key的类型，D表示Map返回的值的类型，方法要完成的事情实际上就是要将downstream在收集的时候，应用分类器classifier。它本身又调用一个重载的方法，在查看之前首先需要了解一个JDK中新增加的方法，在最终构造返回的accumulator的时候，我们要用到Map接口中所新增加的默认方法computeIfAbsent：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="params"><span class="function">            Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(mappingFunction);</span><br><span class="line">    	<span class="comment">// 	V表示当前map的值的类型</span></span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> ((v = get(key)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V newValue;</span><br><span class="line">            <span class="keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                put(key, newValue);</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null.</span><br></pre></td></tr></table></figure>

<p>如果给定一个key与值没有关联起来（或者键映射为空），直接返回结果，如果它不为空的话，将尝试着计算他们的值使用给定的映射方法，就将他放入到map里面。总而言之，如果key不存在，则返回，如果存在，就执行mappingFunction，然后将映射之后的值放入到map当中。</p>
<p>下面的方式是groupingBy真正执行的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</span><br><span class="line">    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                  Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                                  Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    	<span class="comment">// A表示下游收集器的中间结果容器类型</span></span><br><span class="line">        Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();</span><br><span class="line">    	<span class="comment">// T表示流中元素的类型</span></span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    	<span class="comment">// 构造最终所返回的累加器对象</span></span><br><span class="line">        BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</span><br><span class="line">            K key = Objects.requireNonNull(classifier.apply(t), <span class="string">&quot;element cannot be mapped to a null key&quot;</span>);</span><br><span class="line">            A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</span><br><span class="line">            downstreamAccumulator.accept(container, t);</span><br><span class="line">        &#125;;</span><br><span class="line">    	<span class="comment">// 完成两个Map的合并操作</span></span><br><span class="line">        BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());</span><br><span class="line">    	<span class="comment">// 将M类型强转为&lt;K,A&gt;类型，M本身是&lt;K,D&gt;类型，由于中间结果类型一定是&lt;K,A&gt;类型，所以可以强转成功。</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下游收集器本身返回的是&lt;A,D&gt;类型的，这里也是由于一定是&lt;A,A&gt;类型的，所以可以强转成功。</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</span><br><span class="line">            <span class="comment">// 将Map中的键值对替换 </span></span><br><span class="line">            Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</span><br><span class="line">                intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                M castResult = (M) intermediate;</span><br><span class="line">                <span class="keyword">return</span> castResult;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数是一个分类器，输入类型是T，返回的是K类型，第二个参数是accumulator累加器的类型，对应上面例子中的HashMap::new，第三个参数是下游收集器，其中的A表示的是中间结果的容器类型，在整个方法的返回类型中，泛型M的定义是M extends Map&lt;K, D&gt;。首先我们来阅读以下这个方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a Collector implementing a cascaded &quot;group by&quot; operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The Map produced by the Collector is created with the supplied factory function.</span><br></pre></td></tr></table></figure>

<p>groupingBy方法返回了完成对于给定T类型的层叠的分组操作的Collector，它是根据提供的分类器来对元素进行分组的，然后会对于给定的key所关联的值（即Map）使用给定的下游收集器执行汇聚操作，Collector所使用的Map是由supplied工厂函数提供的。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map&lt;K, D&gt;.</span><br></pre></td></tr></table></figure>

<p>分类器方法会将元素映射成某个k类型，然后下游收集器会对流中T类型的元素生成一个D类型的结果，所生成的collector类型是Map&lt;K,D&gt;。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For example, to compute the set of last names of people in each city, where the city names are sorted:</span><br></pre></td></tr></table></figure>

<p>比如要根据城市的名字对城市中每个人的姓进行分组，并且返回的结果要求带有排序的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;City, Set&lt;String&gt;&gt; namesByCity</span><br><span class="line">       = people.stream().collect(groupingBy(Person::getCity, TreeMap::<span class="keyword">new</span>,</span><br><span class="line">                                            mapping(Person::getLastName, toSet())));</span><br></pre></td></tr></table></figure>

<p>关于分组的方法还有另外的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The returned Collector is not concurrent. For parallel stream pipelines, the combiner function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using groupingByConcurrent(Function, Supplier, Collector) may offer better parallel performance.</span><br></pre></td></tr></table></figure>

<p>groupingBy方法返回的Collector不是并发的，对于并行流管道，combiner方法会将一个map的key合并到另一个当中，这可能是一个昂贵的操作，如果对于下游收集器而言，元素的顺序不是很重要的话，建议使用groupingByConcurrent，它可以提供更好的并发的性能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, ConcurrentMap&lt;K, D&gt;&gt; groupingByConcurrent(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                                          Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingByConcurrent(classifier, ConcurrentHashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因就在于groupingByConcurrent使用的是ConcurrentHashMap。</p>
<p>与groupingBy相关联的另一个方法就是分区partitioningBy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate) &#123;</span><br><span class="line">    <span class="keyword">return</span> partitioningBy(predicate, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它也有两个重载的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt;</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate,</span><br><span class="line">                                                Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    BiConsumer&lt;Partition&lt;A&gt;, T&gt; accumulator = (result, t) -&gt;</span><br><span class="line">            downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t);</span><br><span class="line">    BinaryOperator&lt;A&gt; op = downstream.combiner();</span><br><span class="line">    BinaryOperator&lt;Partition&lt;A&gt;&gt; merger = (left, right) -&gt;</span><br><span class="line">            <span class="keyword">new</span> Partition&lt;&gt;(op.apply(left.forTrue, right.forTrue),</span><br><span class="line">                            op.apply(left.forFalse, right.forFalse));</span><br><span class="line">    Supplier&lt;Partition&lt;A&gt;&gt; supplier = () -&gt;</span><br><span class="line">            <span class="keyword">new</span> Partition&lt;&gt;(downstream.supplier().get(),</span><br><span class="line">                            downstream.supplier().get());</span><br><span class="line">    <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(supplier, accumulator, merger, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Function&lt;Partition&lt;A&gt;, Map&lt;Boolean, D&gt;&gt; finisher = par -&gt;</span><br><span class="line">                <span class="keyword">new</span> Partition&lt;&gt;(downstream.finisher().apply(par.forTrue),</span><br><span class="line">                                downstream.finisher().apply(par.forFalse));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(supplier, accumulator, merger, finisher, CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Partition是用来定义分组结果的一个静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Partition</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">Boolean</span>, <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">         <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> T forTrue;</span><br><span class="line">     <span class="keyword">final</span> T forFalse;</span><br><span class="line"></span><br><span class="line">     Partition(T forTrue, T forFalse) &#123;</span><br><span class="line">         <span class="keyword">this</span>.forTrue = forTrue;</span><br><span class="line">         <span class="keyword">this</span>.forFalse = forFalse;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Set&lt;Map.Entry&lt;Boolean, T&gt;&gt; entrySet() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> AbstractSet&lt;Map.Entry&lt;Boolean, T&gt;&gt;() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;Boolean, T&gt;&gt; iterator() &#123;</span><br><span class="line">                 Map.Entry&lt;Boolean, T&gt; falseEntry = <span class="keyword">new</span> SimpleImmutableEntry&lt;&gt;(<span class="keyword">false</span>, forFalse);</span><br><span class="line">                 Map.Entry&lt;Boolean, T&gt; trueEntry = <span class="keyword">new</span> SimpleImmutableEntry&lt;&gt;(<span class="keyword">true</span>, forTrue);</span><br><span class="line">                 <span class="keyword">return</span> Arrays.asList(falseEntry, trueEntry).iterator();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>之所以这么做的原因是，分区一定是固定的两组结果，如果再使用Map类描述的话并不是特别清晰。</p>
<h2 id="Stream原理"><a href="#Stream原理" class="headerlink" title="Stream原理"></a>Stream原理</h2><p>收集器是我们认识整个Stream的第一步，在了解了有关收集器的内容之后，可以为我们了解Stream打下良好的基础，这一部分是整个函数式编程最核心的部分，我们将会看到JDK在底层到底是如何巧妙的实现函数式编程。</p>
<h3 id="Stream源码分析"><a href="#Stream源码分析" class="headerlink" title="Stream源码分析"></a>Stream源码分析</h3><p>在正式开始介绍之前，需要有一些预备的知识，从JDK1.7开始增加了这样一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An object that may hold resources (such as file or socket handles) until it is closed. The close() method of an AutoCloseable object is called automatically when exiting a try-with-resources block for which the object has been declared in the resource specification header. This construction ensures prompt release, avoiding resource exhaustion exceptions and errors that may otherwise occur.</span><br></pre></td></tr></table></figure>

<p>这是一个关闭之前可能持有一些资源（比如文件、socket句柄）的对象，它的close方法会在退出 try-with-resources代码块的时候自动得到调用，这种调用的机制被声明在资源的规范的头里面，这种设置确保了可以适当的释放一些资源，避免了资源被消耗尽造异常外和错误。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCloseableTest</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;close invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (AutoCloseableTest autoCloseableTest = <span class="keyword">new</span> AutoCloseableTest()) &#123;</span><br><span class="line">            autoCloseableTest.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方式可以替换原来的需要人为的显示关闭各种流的操作，close方法会自动的得到调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doSomething invoked!</span><br><span class="line">close invoked!</span><br></pre></td></tr></table></figure>

<p>接下来我们就完整的梳理一下关于Sream类本身的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using Stream and IntStream:</span><br></pre></td></tr></table></figure>

<p>首先Stream是一个支持并行与串行聚合操作的元素的序列，下面的示例演示了如何让使用Stream和IntStream进行聚合操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">                      .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">                      .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">                      .sum();</span><br></pre></td></tr></table></figure>

<p>对于这个例子的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this example, widgets is a Collection&lt;Widget&gt;. We create a stream of Widget objects via Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget. Then this stream is summed to produce a total weight.</span><br></pre></td></tr></table></figure>

<p>在这个例子当中，widgets是Widget类型的集合，我们通过使用Collection的stream方法创建了一个Widget对象的流，生成了一个新的只包含红色的Widget的流，然后将它转换成int值的Stream对象，代表了每个红色Widget的重量，最后流被汇总起来生成一个总的重量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as &quot;streams&quot; and conform to the characteristics and restrictions described here.</span><br></pre></td></tr></table></figure>

<p>Stream本身是一个对象引用流，除了他还有一些原生的、特化的版本。比如IntStream、LongStream、DoubleStream，他们都被称之为Stream，满足Stream的特性，遵循Stream的相关约束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.</span><br></pre></td></tr></table></figure>

<p>为了进行计算，Stream会被组合成一个Stream pipeline（流管道）当中，一个流管道包含了一个元（可以是一个数组，一个集合，一个生成器法，一个I/O通道等等），包含0个或多个中间操作（会将一个Stream转换为另一个Stream，比如filter(Predicate)），包含一个终止操作（将会产生一个结果或者是有副作用的，比如count() 或者forEach(Consumer)），流是延迟的，只有当终止操作开始的时候，才会对元数据的计算才会真正的进行执行，元的数据只有在需要的时候才会被消费。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal.</span><br></pre></td></tr></table></figure>

<p>集合与流，他们有一些相似性，但是有不同的目标，集合主要考虑的是高效的访问和管理他们的元素，与之相反，流并不会直接提供直接的去操作元素的方式，而是通过声明式的方式来描述他们元以及操作，这些操作会被聚合起来应用到他们的元上面，流关注的是元的计算。然而，如果提供的流操作并没有所需要的功能，那么iterator()和spliterator() 就可以执行控制性的遍历（即采用传统的方式来进行一些流的操作）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A stream pipeline, like the &quot;widgets&quot; example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.</span><br></pre></td></tr></table></figure>

<p>一个流管道，比如刚才的widgets，它可以被看成是一种对于流元的查询，除非这个流被显示的设计成可以并发修改的（比如ConcurrentHashMap），否则一些错误的型为就可能会产生并发修改的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -&gt; w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters:</span><br></pre></td></tr></table></figure>

<p>大多数的流都会接收用户指定的一种行为，比如Lambda表达式 w -&gt; w.getWeight()，为了保证最终结果的正确性，这些行为参数都要满足下面的这些条件特性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">must be non-interfering (they do not modify the stream source); and</span><br><span class="line">in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).</span><br></pre></td></tr></table></figure>

<ul>
<li>他们必须是冲突非干扰的，</li>
<li>在大多数情况下都是一种无状态的操作（结果不应该依赖于在流管道执行过程当中可能会修改的任意状态）,即执行的结果与执行的顺序是无关的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null.</span><br></pre></td></tr></table></figure>

<p>这些参数总是一个函数式接口的实例。比如说Lamda表达式，除特殊情况外，参数都是非空的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, &quot;forked&quot; streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.</span><br></pre></td></tr></table></figure>

<p>一个流调用中间操作或者终止操作只能被操作一次，这并不是绝对的，比如”派生“的流，相同的元会提供两个或多个流管道，或者对相同的元执行多次的遍历，如果检测到流被重用了，就会抛出IllegalStateException，然而有些流操作可能会返回他们的接收者而并不是一个新的Stream对象，这种情况下是无法检测到被重用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Streams have a close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.)</span><br></pre></td></tr></table></figure>

<p>流都实现了AutoCloseable接口，因此都会自动的调用close方法，但是几乎所有的流实例在使用完成之后都不需要关闭，只有当流的元是一个IO通道的时候（比如从Files.lines返回对象）需要被关闭，大多数流的元都是集合、数组、或者生成器函数，他们并不需要特殊的资源管理（如果一个流确实需要关闭，它会使用try-with-resources声明成一个资源）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method.</span><br></pre></td></tr></table></figure>

<p>流管道可以通过并行或者是串行的方式来去执行，这种执行方式只是流里面的一个属性而已，流初始被创建的时候就会选择串行还是并行的（比如Collection.stream() 创建的就是串行流，Collection.parallelStream()创建的就是并行流），这种执行模式的选择，还可以通过sequential()或者parallel() 方法进行修改，并且还可以通过isParallel() 方法来查询流的类型。</p>
<p>以上就是关于Stream这个类的内容，Stream本身又继承了BaseStream类，BaseStream定义了所有流、流的操作、流管道以及并行流的行为和种类，我们首先来看一下BaseStream类的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回针对于流中元素的迭代器</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 这是流的终止操作，返回流中元素的分割迭代器</span></span><br><span class="line">    <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 判断流是否是并行流，只能在流的终止操作之前进行调用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isParallel</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回一个等价的串行流，有可能会返回流本身，也有可能会将底层的流修改为串行流，这是一个中间操作</span></span><br><span class="line">    <span class="function">S <span class="title">sequential</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回一个等价的并行流，有可能返回流本身，也有可能将底层的流修改为并行流，这是一个中间操作</span></span><br><span class="line">    <span class="function">S <span class="title">parallel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回一个无序的流，有可能返回流本身，原因是流本身就是无序的，这是一个中间操作</span></span><br><span class="line">    <span class="function">S <span class="title">unordered</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回一个额外带有关闭处理器的流，当流的close方法被调用的时候，就会按照被添加进去的顺序得到调用，所有的关闭处理器都会得到调用而无论它之前的关闭处理器是否抛出了异常，如果任意的关闭处理器抛出了异常，那么抛出的第一个异常就会被抛给close方法的调用者，其余的异常就会作为被压制的异常（除非其余的异常是与第一个异常相同的异常，因为一个异常不能压制它本身），同样的，他也有可能返回自己</span></span><br><span class="line">    <span class="function">S <span class="title">onClose</span><span class="params">(Runnable closeHandler)</span></span>;</span><br><span class="line">	<span class="comment">// 关闭这个流，所有的流管道处理器都会得到调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的泛型T代表流中元素的类型，S指的是实现了BaseStream类型的流对象，实际上指的就是中间操作返回的新的流对象，回到Stream类的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stream</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">Stream</span>&lt;<span class="title">T</span>&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p>对照BaseStream的定义不难发现，这里的泛型S指的就是<code>Stream&lt;T&gt;</code>,而<code>Stream&lt;T&gt;</code>又正好继承了BaseStream，所以这个泛型是成立的。</p>
<p>关于关闭处理器可以举一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用这种方式是为了执行Stream的close方法</span></span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; stream = list.stream()) &#123;</span><br><span class="line">            stream.onClose(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            &#125;).onClose(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">            &#125;).forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure>

<p>修改一下程序，观察有异常发生的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = list.stream()) &#123;</span><br><span class="line">         stream.onClose(() -&gt; &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;first exception&quot;</span>);</span><br><span class="line">         &#125;).onClose(() -&gt; &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">         &#125;).forEach(System.out::println);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>就会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">java.lang.NullPointerException: first exception</span><br><span class="line">	at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18)</span><br><span class="line">	at java.util.stream.Streams$1.run(Streams.java:850)</span><br><span class="line">	at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323)</span><br><span class="line">	at Stream2.StreamTest2.main(StreamTest2.java:22)</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br></pre></td></tr></table></figure>

<p>可以看到虽然抛出了异常，但是后面的关闭处理器依然得到了执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">Exception in thread &quot;main&quot; world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">java.lang.NullPointerException: first exception</span><br><span class="line">	at Stream2.StreamTest2.lambda$main$0(StreamTest2.java:18)</span><br><span class="line">	at java.util.stream.Streams$1.run(Streams.java:850)</span><br><span class="line">	at java.util.stream.AbstractPipeline.close(AbstractPipeline.java:323)</span><br><span class="line">	at Stream2.StreamTest2.main(StreamTest2.java:23)</span><br><span class="line">	Suppressed: java.lang.NullPointerException: second exception</span><br><span class="line">		at Stream2.StreamTest2.lambda$main$1(StreamTest2.java:21)</span><br><span class="line">		at java.util.stream.Streams$1.run(Streams.java:854)</span><br><span class="line">		... 2 more</span><br></pre></td></tr></table></figure>

<p>这里的Suppressed就是压制的异常信息，可以看到后续的异常都被压制了,针对于文档中提到相同的异常，就不会被压制，指的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   NullPointerException nullPointerException = <span class="keyword">new</span> NullPointerException(<span class="string">&quot;exception&quot;</span>);    </span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = list.stream()) &#123;</span><br><span class="line">           stream.onClose(() -&gt; &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">               <span class="keyword">throw</span> nullPointerException;</span><br><span class="line">           &#125;).onClose(() -&gt; &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">               <span class="keyword">throw</span> nullPointerException;</span><br><span class="line">           &#125;).forEach(System.out::println);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">Exception in thread &quot;main&quot; world</span><br><span class="line">hello world</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">java.lang.NullPointerException: exception</span><br><span class="line">	at Stream2.StreamTest2.main(StreamTest2.java:15)</span><br><span class="line"></span><br><span class="line">FAILURE: Build failed with an exception.</span><br></pre></td></tr></table></figure>

<h3 id="Spliterator源码分析"><a href="#Spliterator源码分析" class="headerlink" title="Spliterator源码分析"></a>Spliterator源码分析</h3><p>Spliterator被称之为分割迭代器，是整个流实现非常重要的一环，从本节开始，就正式进入的流源码的分析。</p>
<p>首先还是定义一个非常简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用的Collection接口中的stream方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们来阅读一下方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a sequential Stream with this collection as its source.</span><br><span class="line">This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)</span><br></pre></td></tr></table></figure>

<p>stream方法会调用的将集合作为流的元，并且返回一个串行流，当spliterator方法无法返回IMMUTABLE（不可变的）、CONCURRENT（并行的）、late-binding（延迟绑定的）的分割迭代器，那么这个方法应该当被重写。</p>
<p>stream方法的参数也是定义在Collection集合中的默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一下这个方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports Spliterator.SIZED and this collection contains no elements.</span><br><span class="line">The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the stream() and parallelStream()&#125; methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be late-binding. If none of these is practical, the overriding class should describe the spliterator&#x27;s documented policy of binding and structural interference, and should override the stream() and parallelStream() methods to create streams using a Supplier of the spliterator, as in:</span><br></pre></td></tr></table></figure>

<p>创建一个针对于这个集合的元素分割迭代器，实现应该对于spliterator方法所返回的Spliterator特性值进行文档化（记录下来），这些特性值并不要求去报告，如果这个Spliterator报告了Spliterator.SIZED，并且这个集合不包含任何元素，默认的实现应该要被子类所重写，目的是为了返回一个效率更高的分割迭代器，为了保留stream、parallelStream两个方法的延迟特性，spliterators的特性值要么是IMMUTABLE或者CONCURRENT，要么就是late-binding，如果上面这些都无法实现，重写的类需要文档化spliterator的绑定策略，并且使用spliterator的Supplier重写stream和parallelStream方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;E&gt; s = StreamSupport.stream(() -&gt; spliterator(), spliteratorCharacteristics)</span><br></pre></td></tr></table></figure>

<p>应该使用这种方式来定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">These requirements ensure that streams produced by the stream() and parallelStream() methods will reflect the contents of the collection as of initiation of the terminal stream operation.</span><br></pre></td></tr></table></figure>

<p>这些要求确保了由stream和parallelStream方法生成的流从终止流操作开始发起的时候就反应出流的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The default implementation creates a late-binding spliterator from the collections&#x27;s Iterator. The spliterator inherits the fail-fast properties of the collection&#x27;s iterator.</span><br><span class="line">The created Spliterator reports Spliterator.SIZED.</span><br></pre></td></tr></table></figure>

<p>默认的实现会从集合的迭代器创建一个延迟绑定的分割迭代器，创建出来的分割迭代器继承了集合迭代器的快速失败（如果碰到问题，程序不再往下执行，直接抛出异常）的属性，创建出来的分割迭代器具有 Spliterator.SIZED（固定大小）的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The created Spliterator additionally reports Spliterator.SUBSIZED.</span><br></pre></td></tr></table></figure>

<p>所创建出来的Spliterator还有一个额外的特性：Spliterator.SUBSIZED（所分割出来的每个块的大小是固定的）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a spliterator covers no elements then the reporting of additional characteristic values, beyond that of SIZED and SUBSIZED, does not aid clients to control, specialize or simplify computation. However, this does enable shared use of an immutable and empty spliterator instance (see Spliterators.emptySpliterator()) for empty collections, and enables clients to determine if such a spliterator covers no elements.</span><br></pre></td></tr></table></figure>

<p> 如果分割迭代器中没有任何元素，那么除了IZED和SUBSIZED其他的特性值并不会简化客户端的计算，但是可以重用一个空的、不可变的分割迭代器，是不是里面没有元素，并且对于空的集合，可以帮助客户端来判断spliterator里面是不是没有元素。</p>
<p>Spliterator和Spliterators的关系就好像Collector和Collectors的关系一样，Spliterators针对于Spliterator提供了若干的静态方法，接下来就正式开始了解有关Spliterator的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function.</span><br></pre></td></tr></table></figure>

<p>Spliterator是一个对于元中的元素进行遍历和分区的对象，Spliterator 元中的元素可以是数组，可以是集合，可以是IO通道，也可以是一个生成器函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk (forEachRemaining()).</span><br></pre></td></tr></table></figure>

<p>一个Spliterator可以使用tryAdvance单个的遍历元素，也可以使用forEachRemaining成块的遍历元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator may also partition off some of its elements (using trySplit) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation.</span><br></pre></td></tr></table></figure>

<p>一个Spliterator也可以对它的元素使用trySplit进行分区，形成另外的Spliterator，并且可以被并行的使用。如果使用Spliterator不能进行分割，或者分割的不平衡或者效率非常低的方式，那使用并行就并没有带来多少的好处。遍历和分割都会消耗元素，每一个Spliterator仅仅是对一个单块的计算是有用的（每一块元素都有自己的分割迭代器）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator also reports a set of characteristics() of its structure, source, and elements from among ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, and SUBSIZED. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a Collection would report SIZED, a Spliterator for a Set would report DISTINCT, and a Spliterator for a SortedSet would also report SORTED. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if ORDERED, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values.</span><br></pre></td></tr></table></figure>

<p>Spliterator还会报告它的结构、元、元素的特性值ORDERED（有序的）、DISTINCT（不同的）、SORTED（排序的）、SIZED（确定大小的）、NONNULL（不为空的）、IMMUTABLE（不可变的）、CONCURRENT（并放大的）、SUBSIZED（子部分固定大小的），这些可以被Spliterator的客户端使用，使用他们来简化一些计算，比如说，如果元是Collection集合，那么它就会报告SIZED的特性值，如果元是Set集合，那么就会报告DISTINCT，如果元是SortedSet集合，那么就会报告SORTED，Characteristics会作为一个位操作来标识的，有一些特性值会额外限制方法的行为，比如ORDERED，那么遍历的时候就必须遵循遍历时候的顺序，未来可能会定义一些新的characteristics，所以不要使用这些特性值之外的值，可能会引起冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator that does not report IMMUTABLE or CONCURRENT is expected to have a documented policy concerning: when the spliterator binds to the element source; and detection of structural interference of the element source detected after binding. A late-binding Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not late-binding binds to the source of elements at the point of construction or first invocation of any method. Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a Spliterator should, on a best-effort basis, throw ConcurrentModificationException if structural interference is detected. Spliterators that do this are called fail-fast. The bulk traversal method (forEachRemaining()) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately.</span><br></pre></td></tr></table></figure>

<p>当分割迭代器绑定到元上元素的时候，如果Spliterator没有报告IMMUTABLE或者CONCURRENT，期望可以文档化。并且在绑定之后，要对元素的结构上一些修改进行相应检测，延迟绑定的Spliterator会在元素第一次分割、遍历的，或者笫一次查询元素大小的时候绑定。而不是在Spliterator创建的时候绑定的，如果不是延迟绑定的Spliterator，就会在元创建的时候或者说第一次调用方法时候进行绑定。如果在绑定元之前对元进行了修改的话，这种修改就会在分割迭代器遍历的时候反映出来，如果绑定之后对元进行了修改，就会抛出ConcurrentModificationException的异常，按照这种方式我们称之为”快速失败”，块的遍历方法（例如forEachRemaining）会优化遍历并检测结构上的修改，在所有的元素都遍历之后，而不是对每个元素一次检测。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spliterators can provide an estimate of the number of remaining elements via the estimateSize method. Ideally, as reflected in characteristic SIZED, this value corresponds exactly to the number of elements that would be encountered in a successful traversal. However, even when not exactly known, an estimated value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially.</span><br></pre></td></tr></table></figure>

<p>Spliterators通过estimateSize方法来估算剩余元素的个数，理想情况下，通过特性值SIZED获取到的值就是之后遍历元素个数的值，不过，即便不是精确的知道待遍历元素的数量，一个估算的值，对于元的操作也是很有用的，比如可以帮助对元进行进一步的分割或者对于剩余的元素进行串行的遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time. This is generally easy to attain via serial thread-confinement, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition. A thread calling trySplit() may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with tryAdvance(), as certain guarantees (such as the accuracy of estimateSize() for SIZED spliterators) are only valid before traversal has begun.</span><br></pre></td></tr></table></figure>

<p>尽管他们显著的功能在算法当中，分割迭代器并不被要求是线程安全的，相反，使用了spliterators并行算法的实现，应该确保了分割迭代器在某个时候一次只有一个线程使用，这可以使用serial thread-confinement这种模式来实现。这是一个通过递归解耦得到的自然的结果。一个调用了trySplit的一个线程，它可以将返回的Spliterator交由另一个线程接管，另一个线程可能会进一步的分割，分割以及遍历的行为是不确定的，如果两个或者多个线程操作同一个Spliterator，如果原来的线程将Spliterator交由另外一个线程处理的话，那么最好这种传递是发生在任何元素在使用tryAdvance方法消费之前完成，因为某些保证实在执行之前才是有效的（比如统计元素个数的estimateSize方法，SIZED特性值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Primitive subtype specializations of Spliterator are provided for int, long, and double values. The subtype default implementations of tryAdvance(Consumer) and forEachRemaining(Consumer) box primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, Spliterator.OfInt.tryAdvance(IntConsumer) and Spliterator.OfInt.forEachRemaining(IntConsumer) should be used in preference to Spliterator.OfInt.tryAdvance(Consumer) and Spliterator.OfInt.forEachRemaining(Consumer). Traversal of primitive values using boxing-based methods tryAdvance() and forEachRemaining() does not affect the order in which the values, transformed to boxed values, are encountered.</span><br></pre></td></tr></table></figure>

<p>原生的子类型的特化也提供了。比如int、long、double，普通的方法接收的参数tryAdvance(Consumer) and forEachRemaining(Consumer)，这些参数就会使用包装类型，这样就有可能影响了性能上的优势，为了避免装箱拆箱操作带来的性能消耗，就应该使用Spliterator.OfInt.tryAdvance(IntConsumer) 和Spliterator.OfInt.forEachRemaining(IntConsumer) ，如果可以使用特化版本就不要使用通用版本。无论使用哪种方式，元素的顺序与之前的保持一致。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spliterators, like Iterators, are for traversing the elements of a source. The Spliterator API was designed to support efficient parallel traversal in addition to sequential traversal, by supporting decomposition as well as single-element iteration. In addition, the protocol for accessing elements via a Spliterator is designed to impose smaller per-element overhead than Iterator, and to avoid the inherent race involved in having separate methods for hasNext() and next().</span><br></pre></td></tr></table></figure>

<p>Spliterators就像Iterators一样，也是用来遍历元当中的元素的，Spliterator的API设计为串行和高效的并行方式来进行元素的遍历，通过支持解耦、分解、单元素的遍历迭代，此外，相对于Iterator，使用Spliterator来遍历元素的成本是更低的，因为避免了在使用hasNext和next方法的竞争的出现（使用Iterators遍历元素通常需要两者搭配使用，但Spliterator只需要通过一个方法tryAdvance）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For mutable sources, arbitrary and non-deterministic behavior may occur if the source is structurally interfered with (elements added, replaced, or removed) between the time that the Spliterator binds to its data source and the end of traversal. For example, such interference will produce arbitrary, non-deterministic results when using the java.util.stream framework.</span><br></pre></td></tr></table></figure>

<p>对于可变的元来说，如果元在绑定了Spliterator之后，遍历结束之前在结构上被修改了（元素的添加、替换、移除）就可能出现一些不确定的行为，比如说，在使用java.util.stream 框架的这种修改可能出现这些不确定的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Structural interference of a source can be managed in the following ways (in approximate order of decreasing desirability):</span><br></pre></td></tr></table></figure>

<p>一个元在结构上的改变是可以通过如下的几种方式来进行管理的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source cannot be structurally interfered with. For example, an instance of java.util.concurrent.CopyOnWriteArrayList is an immutable source. A Spliterator created from the source reports a characteristic of IMMUTABLE.</span><br></pre></td></tr></table></figure>

<p>1、元的结构是不能被修改的，例如，java.util.concurrent.CopyOnWriteArrayLis就是一个不可变的元，通过这种元创建的Spliterator会返回一个IMMUTABLE的特性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source manages concurrent modifications. For example, a key set of a java.util.concurrent.ConcurrentHashMap is a concurrent source. A Spliterator created from the source reports a characteristic of CONCURRENT.</span><br></pre></td></tr></table></figure>

<p>2、元本身管理并发修改，例如java.util.concurrent.ConcurrentHashMap键的集合就是一个并发的元，通过这种元创建的Spliterator会返回一个CONCURRENT的特性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a late-binding and fail-fast Spliterator. Late binding narrows the window during which interference can affect the calculation; fail-fast detects, on a best-effort basis, that structural interference has occurred after traversal has commenced and throws ConcurrentModificationException. For example, ArrayList, and many other non-concurrent Collection classes in the JDK, provide a late-binding, fail-fast spliterator.</span><br></pre></td></tr></table></figure>

<p>3、可变的元提供了一种延迟绑定和快速失败的Spliterator，延迟绑定会限制修改影响计算的时间间隔，可变的元</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a non-late-binding but fail-fast Spliterator. The source increases the likelihood of throwing ConcurrentModificationException since the window of potential interference is larger.</span><br></pre></td></tr></table></figure>

<p>4、可变的元提供了非延迟绑定但是快速失败的Spliterator，发生ConcurrentModificationException可能性就会增加，因为时间间隔增大了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a late-binding and non-fail-fast Spliterator. The source risks arbitrary, non-deterministic behavior after traversal has commenced since interference is not detected.</span><br></pre></td></tr></table></figure>

<p>5、可变的元提供了延迟绑定但是非快速失败的Spliterator，这个时候元就有一些风险，在遍历已经开始之后就可能发生一些不确定的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mutable source provides a non-late-binding and non-fail-fast Spliterator. The source increases the risk of arbitrary, non-deterministic behavior since non-detected interference may occur after construction.</span><br></pre></td></tr></table></figure>

<p>6、可变的元提供了延迟绑定并且快速失败的Spliterator，也会增加不确定的风险，在构造之后增加不确定的行为的可能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example. Here is a class (not a very useful one, except for illustration) that maintains an array in which the actual data are held in even locations, and unrelated tag data are held in odd locations. Its Spliterator ignores the tags.</span><br></pre></td></tr></table></figure>

<p>这里给出了一个例子（并不具有实用性，只是为了说明问题），数据实际上是存储在数组的偶数位置上，不相关的标签数据是存放在基数的位置上的，它对应的Spliterator会忽略掉标签，即只关心偶书位置上的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 构造之后就是一个不可变的数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object[] elements;</span><br><span class="line">  TaggedArray(T[] data, Object[] tags) &#123;</span><br><span class="line">    <span class="keyword">int</span> size = data.length;</span><br><span class="line">    <span class="comment">// 数据和标签的个数应该相同</span></span><br><span class="line">    <span class="keyword">if</span> (tags.length != size) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[<span class="number">2</span> * size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">      elements[j++] = data[i];</span><br><span class="line">      elements[j++] = tags[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TaggedArraySpliterator&lt;&gt;(elements, <span class="number">0</span>, elements.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaggedArraySpliterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] array;</span><br><span class="line">    <span class="comment">// 当前的索引，在遍历的时候会自增</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> origin;</span><br><span class="line">    <span class="comment">// 超过最大索引值加1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fence;</span><br><span class="line"></span><br><span class="line">    TaggedArraySpliterator(Object[] array, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence) &#123;</span><br><span class="line">      <span class="keyword">this</span>.array = array; <span class="keyword">this</span>.origin = origin; <span class="keyword">this</span>.fence = fence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; origin &lt; fence; origin += <span class="number">2</span>)</span><br><span class="line">        action.accept((T) array[origin]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (origin &lt; fence) &#123;</span><br><span class="line">        action.accept((T) array[origin]);</span><br><span class="line">        <span class="comment">// tag中的数据不需要</span></span><br><span class="line">        origin += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 分开一半的范围</span></span><br><span class="line">      <span class="keyword">int</span> lo = origin;</span><br><span class="line">      <span class="comment">// 取中点</span></span><br><span class="line">      <span class="keyword">int</span> mid = ((lo + fence) &gt;&gt;&gt; <span class="number">1</span>) &amp; ~<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 分割左侧的</span></span><br><span class="line">      <span class="keyword">if</span> (lo &lt; mid) &#123;</span><br><span class="line">        <span class="comment">// 重新设置范围</span></span><br><span class="line">        origin = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TaggedArraySpliterator&lt;&gt;(array, lo, mid);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>  <span class="comment">// 太小了，无法分割</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">long</span>)((fence - origin) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ORDERED | SIZED | IMMUTABLE | SUBSIZED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子是一个串行的例子，接下来还提供了一个并行的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As an example how a parallel computation framework, such as the java.util.stream package, would use Spliterator in a parallel computation, here is one way to implement an associated parallel forEach, that illustrates the primary usage idiom of splitting off subtasks until the estimated amount of work is small enough to perform sequentially. Here we assume that the order of processing across subtasks doesn&#x27;t matter; different (forked) tasks may further split and process elements concurrently in undetermined order. This example uses a java.util.concurrent.CountedCompleter; similar usages apply to other parallel task constructions.</span><br></pre></td></tr></table></figure>

<p>如何使用并行框架来尽心给计算，例如使用java.util.stream package，在并行情况下使用Spliterator，它描述了对于分割子任务的分割方法，如何将子任务进行分割，如果分割的足够小的话，再以串行的方式去执行，下面的例子使用了java.util.concurrent.CountedCompleter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parEach</span><span class="params">(TaggedArray&lt;T&gt; a, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">   Spliterator&lt;T&gt; s = a.spliterator();</span><br><span class="line">   <span class="keyword">long</span> targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * <span class="number">8</span>);</span><br><span class="line">   <span class="keyword">new</span> ParEach(<span class="keyword">null</span>, s, action, targetBatchSize).invoke();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParEach</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">CountedCompleter</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Spliterator&lt;T&gt; spliterator;</span><br><span class="line">   <span class="keyword">final</span> Consumer&lt;T&gt; action;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> targetBatchSize;</span><br><span class="line"></span><br><span class="line">   ParEach(ParEach&lt;T&gt; parent, Spliterator&lt;T&gt; spliterator,</span><br><span class="line">           Consumer&lt;T&gt; action, <span class="keyword">long</span> targetBatchSize) &#123;</span><br><span class="line">     <span class="keyword">super</span>(parent);</span><br><span class="line">     <span class="keyword">this</span>.spliterator = spliterator; <span class="keyword">this</span>.action = action;</span><br><span class="line">     <span class="keyword">this</span>.targetBatchSize = targetBatchSize;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Spliterator&lt;T&gt; sub;</span><br><span class="line">     <span class="keyword">while</span> (spliterator.estimateSize() &gt; targetBatchSize &amp;&amp;</span><br><span class="line">            (sub = spliterator.trySplit()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       addToPendingCount(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">new</span> ParEach&lt;&gt;(<span class="keyword">this</span>, sub, action, targetBatchSize).fork();</span><br><span class="line">     &#125;</span><br><span class="line">     spliterator.forEachRemaining(action);</span><br><span class="line">     propagateCompletion();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the boolean system property org.openjdk.java.util.stream.tripwire is set to true then diagnostic warnings are reported if boxing of primitive values occur when operating on primitive subtype specializations.</span><br></pre></td></tr></table></figure>

<p>如果系统变量org.openjdk.java.util.stream.tripwire被设置成true的话，如果在操作原生子类型特化的时候，对原生的子类型进行装箱操作，系统就会给出警告。</p>
<p>以上是关于Spliterator这个类本身的说明，接下来Spliterator接口本身提供的一些方法进行说明：</p>
<p>首先是tryAdvance方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.</span><br></pre></td></tr></table></figure>

<p>如果元素存在，就会对元素执行给定的action方法，同时true，否则返回false，如果这个Spliterator是ORDERED，就会对的下一个元素去执行action方法，由这个动作执行产生的任何的异常都会传递给调用者。</p>
<p>接下来是forEachRemaining方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (tryAdvance(action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.The default implementation repeatedly invokes tryAdvance until it returns false. It should be overridden whenever possible.</span><br></pre></td></tr></table></figure>

<p>对剩下的元素都执行action方法，在当前的线程是以串行的方式执行，知道所有的元素都已经被处理了，或者动作本身抛出了异常，如果Spliterator是ORDERED，action会以遇到元素的顺序去执行，由这个动作抛出的异常会被传递给调用者。默认的实现是不断的调用tryAdvance方法直到返回false，在合适的时候应该被重写。 </p>
<p>接下来是trySplit方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator.</span><br><span class="line">If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements.</span><br><span class="line">Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return:</span><br></pre></td></tr></table></figure>

<p>如果这个Spliterator是可以被分割的，就会返回一个新的Spliterator对象，新的Spliterator可能可以进一步分割，剩余的元素是由当前的Spliterator继续涵盖的。</p>
<p>如果这个Spliterator是ORDERED，所返回的Spliterator必须也是ORDERED，除了Spliterator涵盖的是一个无限元素的对象的情况，重复调用trySplit最终得到的结果一定是空，当不为空的情况出现的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and</span><br></pre></td></tr></table></figure>

<p>1、在分割之前estimateSize方法所估算的元的大小的值，必须在分割之后，一定要大于或者等于当前的和返回的新的Spliterator的estimateSize方法所返回的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting.</span><br></pre></td></tr></table></figure>

<p>2、如果Spliterator是SUBSIZED，那么在分割之前Spliterator的estimateSize的值必须等于分割之后所剩下的estimateSize以及剩下的Spliteratord的estimateSize加起来必须相等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.</span><br></pre></td></tr></table></figure>

<p>这个方法有可能会返回一个空值，包括原来的就是Spliterator就是空的，在遍历开始之后无法分割，数据结构上的限制，效率上的考量等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n ideal trySplit method efficiently (without traversal) divides its elements exactly in half, allowing balanced parallel computation. Many departures from this ideal remain highly effective; for example, only approximately splitting an approximately balanced tree, or for a tree in which leaf nodes may contain either one or two elements, failing to further split these nodes. However, large deviations in balance and/or overly inefficient trySplit mechanics typically result in poor parallel performance.</span><br></pre></td></tr></table></figure>

<p>一种理想的trySplit方法在没有进行遍历的情况下，它会恰好就元素分成等量的两部分，这样并行计算的时候工作量是比较平均的。但更多的时候无法达到理想状态，比如说，只是分割一个近似平衡的树，或者对一个树，树中的叶子节点包含了一两个元素，没法再对这些节点进行进一步的分割，对于这种极度不平衡的树，没有效率的trySplit会是的并发执行的效率急剧下降。</p>
<p>接下来是estimateSize方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.</span><br></pre></td></tr></table></figure>

<p>返回对于遍历可能会遇到的元中的元素的数量的估算值，如果元的元素是无限的、未知的、或者计算成本非常昂贵的时候，就会返回Long.MAX_VALUE。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.</span><br></pre></td></tr></table></figure>

<p>如果这个Spliterator是SIZED，并且还没有被分割或者迭代，或者Spliterator是SUBSIZED的，但还没有被部分遍历，那么estimate返回的就一定是一个精确的值，就是要被遍历的元素的个数，否则，estimate估算就可能是不精确的，但是必须要随着trySplit方法的调用次数不断减少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Even an inexact estimate is often useful and inexpensive to compute. For example, a sub-spliterator of an approximately balanced binary tree may return a value that estimates the number of elements to be half of that of its parent; if the root Spliterator does not maintain an accurate count, it could estimate size to be the power of two corresponding to its maximum depth.</span><br></pre></td></tr></table></figure>

<p>estimate方法估算的值通常而言也是有用的，并且计算起来成本也不高，对一个近似平衡的二叉树的sub-spliterator，它会估算父亲节点的元素的一般，如果根Spliterator没有保存正确的计算结果，那么他就会根据树的深度返回2的指数次方，以此来估算元中元素的个数。</p>
<p>接下来是getExactSizeIfKnown方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">long</span> <span class="title">getExactSizeIfKnown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (characteristics() &amp; SIZED) == <span class="number">0</span> ? -<span class="number">1L</span> : estimateSize();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Convenience method that returns estimateSize() if this Spliterator is SIZED, else -1.</span><br></pre></td></tr></table></figure>

<p>如果Spliterator是SIZED就会返回estimateSize的值，否则返回-1。</p>
<p>接下来是characteristics方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result.</span><br></pre></td></tr></table></figure>

<p>返回Spliterator和它的元素特性值的集合，这种结果用ORed值来表示的，共有八个，在trySplit调用之前和调用当中重复地调用这个方法，永远都会返回相同的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.</span><br></pre></td></tr></table></figure>

<p>如果返回了不同的特性值的集合（分割之前和分割之后有可能特性值会不同），那么对于Spliterator的任何计算都是不受保障。</p>
<p>接下来是hasCharacteristics方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasCharacteristics</span><span class="params">(<span class="keyword">int</span> characteristics)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (characteristics() &amp; characteristics) == characteristics;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Returns true if this Spliterator&#x27;s characteristics contain all of the given characteristics.</span><br></pre></td></tr></table></figure>

<p>判断当前的Spliterator是否包含传入的characteristics特性值。</p>
<p>接下来是getComparator方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> Comparator&lt;? <span class="keyword">super</span> T&gt; getComparator() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this Spliterator&#x27;s source is SORTED by a Comparator, returns that Comparator. If the source is SORTED in natural order, returns null. Otherwise, if the source is not SORTED, throws IllegalStateException.</span><br></pre></td></tr></table></figure>

<p>如果这个Spliterator的元通过Comparator是SORTED，那么返回用于排序的比较器，如果元在自然序列下是SORTED，返回null，如果元不是有序的，抛出IllegalStateException异常。</p>
<p>接下来是八个特性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORDERED    = <span class="number">0x00000010</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISTINCT   = <span class="number">0x00000001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SORTED     = <span class="number">0x00000004</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZED      = <span class="number">0x00000040</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONNULL    = <span class="number">0x00000100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IMMUTABLE  = <span class="number">0x00000400</span>;</span><br><span class="line"><span class="comment">// 不能同时返回SIZED和CONCURRENT，如果多个线程访问元，就有可能修改元的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONCURRENT = <span class="number">0x00001000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUBSIZED = <span class="number">0x00004000</span>;</span><br></pre></td></tr></table></figure>

<p>除了以上非常核心的方法，Spliterator中还有两个接口OfPrimitive和OfInt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OfPrimitive</span>&lt;<span class="title">T</span>, <span class="title">T_CONS</span>, <span class="title">T_SPLITR</span> <span class="keyword">extends</span> <span class="title">Spliterator</span>.<span class="title">OfPrimitive</span>&lt;<span class="title">T</span>, <span class="title">T_CONS</span>, <span class="title">T_SPLITR</span>&gt;&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">T_SPLITR <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;overloads&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(T_CONS action)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;overloads&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(T_CONS action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (tryAdvance(action));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator specialized for primitive values.</span><br><span class="line">&lt;T&gt; – the type of elements returned by this Spliterator. The type must be a wrapper type for a primitive type, such as Integer for the primitive int type.</span><br><span class="line">&lt;T_CONS&gt; – the type of primitive consumer. The type must be a primitive specialization of Consumer for T, such as IntConsumer for Integer.</span><br><span class="line">&lt;T_SPLITR&gt; – the type of primitive Spliterator. The type must be a primitive specialization of Spliterator for T, such as Spliterator.OfInt for Integer.</span><br></pre></td></tr></table></figure>

<p>这是一个针对原生值设定的Spliterator，T表示由当前的Spliterator所返回的元素的类型，类型必须要是原生类型的包装类型，比如int类型的包装类型Integer。T_CONS是原生的consumer特化的类型，这个类型必须是java.util.function.Consumer原生类型的特化，比如对于Integer的IntConsumer，T_SPLITR是原生的Spliterator分割迭代器的类型，必须是对于T类型的原生类型的特化，比如对于Integer的OfInt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OfInt</span> <span class="keyword">extends</span> <span class="title">OfPrimitive</span>&lt;<span class="title">Integer</span>, <span class="title">IntConsumer</span>, <span class="title">OfInt</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function">OfInt <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 重写的OfPrimitive中的tryAdvance方法</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(IntConsumer action)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(IntConsumer action)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (tryAdvance(action));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重写的Spliterator中的tryAdvance方法</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Integer&gt; action)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (action <span class="keyword">instanceof</span> IntConsumer) &#123;</span><br><span class="line">               <span class="comment">// IntConsumer和Consumer类型并没有直接继承的关系，这可以强转的原因是如果参数是Integer类型的，由于自动拆箱和自动装箱的原因存在，传递的action如果是Lambda表达式就既满足了Consumer的要求，也满足了IntConsumer的要求，另外是由于Lambda表达式中的类型判断是需要结合具体的上下文的。</span></span><br><span class="line">               <span class="keyword">return</span> tryAdvance((IntConsumer) action);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (Tripwire.ENABLED)</span><br><span class="line">                   Tripwire.trip(getClass(),</span><br><span class="line">                                 <span class="string">&quot;&#123;0&#125; calling Spliterator.OfInt.tryAdvance((IntConsumer) action::accept)&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> tryAdvance((IntConsumer) action::accept);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Integer&gt; action)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (action <span class="keyword">instanceof</span> IntConsumer) &#123;</span><br><span class="line">               forEachRemaining((IntConsumer) action);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (Tripwire.ENABLED)</span><br><span class="line">                   Tripwire.trip(getClass(),</span><br><span class="line">                                 <span class="string">&quot;&#123;0&#125; calling Spliterator.OfInt.forEachRemaining((IntConsumer) action::accept)&quot;</span>);</span><br><span class="line">               forEachRemaining((IntConsumer) action::accept);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Spliterator specialized for int values.</span><br></pre></td></tr></table></figure>

<p>针对于int值的分割迭代器。</p>
<p>这其中比较重要的是第二个tryAdvance方法，首先来看方法的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the action is an instance of IntConsumer then it is cast to IntConsumer and passed to tryAdvance(IntConsumer); otherwise the action is adapted to an instance of IntConsumer, by boxing the argument of IntConsumer, and then passed to tryAdvance(IntConsumer).</span><br></pre></td></tr></table></figure>

<p>如果action是IntConsumer的一个实例，那么就会被强转为IntConsumer并传递给tryAdvance(IntConsumer)，否则，action会被适配成IntConsumer实例，方式是通过IntConsumer的参数进行装箱操作，然后再传递给tryAdvance(IntConsumer)。</p>
<p>对于上面注释中提到的为什么可以强转，我们通过一个具体的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Consumer&lt;Integer&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConsumerTest consumerTest = <span class="keyword">new</span> ConsumerTest();</span><br><span class="line">        <span class="comment">// 两个相同的Lambda表达式</span></span><br><span class="line">        Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i);</span><br><span class="line">        IntConsumer intConsumer = i -&gt; System.out.println(i);</span><br><span class="line">        <span class="comment">// 面向对象的方式</span></span><br><span class="line">        consumerTest.test(consumer);</span><br><span class="line">        <span class="comment">// 编译通过但执行报错</span></span><br><span class="line">        consumerTest.test((Consumer&lt;Integer&gt;) intConsumer);</span><br><span class="line">        <span class="comment">// 传递行为，函数式的方式</span></span><br><span class="line">        consumerTest.test(consumer::accept);</span><br><span class="line">        consumerTest.test(intConsumer::accept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了OfInt之外还有其他两种OfLong、OfDouble，原理和功能都是类似的。</p>
<h3 id="Pipeline源码分析"><a href="#Pipeline源码分析" class="headerlink" title="Pipeline源码分析"></a>Pipeline源码分析</h3><p>分割迭代器无疑是函数式编程中一个相当核心的概念，其地位与收集器相同，在了解了分割迭代器的相关内容之后，我们再回到一开始的例子当中，看看JDK是如何使用分割迭代器来构造流源的，还是回到最开始的入口这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的spliterator方法是定义Collection接口当中的一个默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 这里的this表示的是当前集合的引用，当前集合的引用就是在这个时候被传递进去的</span></span><br><span class="line">       <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Spliterators中静态方法spliterator返回了一个Spliterator实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">(Collection&lt;? extends T&gt; c,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">int</span> characteristics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IteratorSpliterator&lt;&gt;(Objects.requireNonNull(c),</span><br><span class="line">                                     characteristics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们实际上使用的分割迭代器是IteratorSpliterator，IteratorSpliterator是实现了Spliterator接口的一个实现类，它本身持有了元数据集合的引用。</p>
<p>创建流元的过程是由StreamSupport这个类来完成的，以下是关于StreamSupport这个类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Low-level utility methods for creating and manipulating streams.</span><br><span class="line">This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various Stream classes.</span><br></pre></td></tr></table></figure>

<p>提供了一些创建和操作流的底层方法。这个类是给类库的编写者提供的，用于呈现流的数据视图，为用户所设计的大多数的静态的流的方法大多都在stream类中提的方法。</p>
<p>StreamSupport中的stream方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creates a new sequential or parallel Stream from a Spliterator.</span><br><span class="line">The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences.</span><br><span class="line">It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, stream(Supplier, int, boolean) should be used to reduce the scope of potential interference with the source. See Non-Interference for more details.</span><br></pre></td></tr></table></figure>

<p>从一个分割迭代器对象创建一个串行或者并行的流，spliterator在流管道开启之后仅仅是完成遍历、分割、查询、大小的等功能，强烈建议spliterator返回IMMUTABLE、CONCURRENT或者late-binding这样一些特性，否则，stream应该用于减少潜在的干扰，查看Non-Interference获取更多信息。</p>
<p>这里引出了另外一个及其重要的类ReferencePipeline，用于描述中间的管道阶段和管道源阶段的的类，它与流的操作息息相关，Head是ReferencePipeline的一个静态内部类，描述的是管道的源阶段，二者在大部分属性的设定上都是类似的，但存在一些属性是不同的，比如说Head是没有previousStage的，而ReferencePipeline则是存在previousStage的，等等。接下来就需要重点了解管道流相关的内容。</p>
<p>首先是定义在ReferencePipeline类当中的内部类Head：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; <span class="keyword">extends</span> <span class="title">ReferencePipeline</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">      Head(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source,</span><br><span class="line">           <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">          <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 这里Spliterator作为流的源</span></span><br><span class="line">      Head(Spliterator&lt;?&gt; source,</span><br><span class="line">           <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">          <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">opIsStateful</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> Sink&lt;E_IN&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">              sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">super</span>.forEach(action);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">              sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">super</span>.forEachOrdered(action);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Head类本身有两个泛型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;E_IN&gt; – type of elements in the upstream source</span><br><span class="line">&lt;E_OUT&gt; – type of elements in produced by this stage</span><br></pre></td></tr></table></figure>

<p>E_IN表示上游流源的元素类型，E_OUT表示这个阶段生成的元素类型。</p>
<p>真正在创建的时候又是调用了ReferencePipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferencePipeline(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source,</span><br><span class="line">                   <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">     <span class="keyword">super</span>(source, sourceFlags, parallel);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>而ReferencePipeline的构造方法又调用了它的父类AbstractPipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractPipeline(Supplier&lt;? extends Spliterator&lt;?&gt;&gt; source,</span><br><span class="line">                  <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">     <span class="keyword">this</span>.previousStage = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">this</span>.sourceSupplier = source;</span><br><span class="line">     <span class="keyword">this</span>.sourceStage = <span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class="line">     <span class="comment">// The following is an optimization of:</span></span><br><span class="line">     <span class="comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span></span><br><span class="line">     <span class="keyword">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class="line">     <span class="keyword">this</span>.depth = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">this</span>.parallel = parallel;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>AbstractPipeline的说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Abstract base class for &quot;pipeline&quot; classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines.</span><br></pre></td></tr></table></figure>

<p>AbstractPipeline是对于管道类抽象出来的一个父类，管道类指的是流接口以及其原生特化的核心的实现，它会管理流管道的构建以及计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An AbstractPipeline represents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation.</span><br></pre></td></tr></table></figure>

<p>AbstractPipeline代表了流管道初始的阶段，它封装了一个流源和0个或者多个中间操作，每一个单个的AbstractPipeline通常称为stages（阶段），这个阶段要么描述的是流的源，要么描述的是中间操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A concrete intermediate stage is generally built from an AbstractPipeline, a shape-specific pipeline class which extends it (e.g., IntPipeline) which is also abstract, and an operation-specific concrete class which extends that. AbstractPipeline contains most of the mechanics of evaluating the pipeline, and implements methods that will be used by the operation; the shape-specific classes add helper methods for dealing with collection of results into the appropriate shape-specific containers.</span><br></pre></td></tr></table></figure>

<p>一个具体的中间阶段通常是通过AbstractPipeline构建出来的，特化的管道类（IntPipeline、LongPipeline）操作都是类似的，AbstractPipeline包含了大多数计算管道的机制，并且实现了操作的时候要使用的方法，与原生特定相关的类增加了用来处理结果集合添加到特定的特化的管道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">After chaining a new intermediate operation, or executing a terminal operation, the stream is considered to be consumed, and no more intermediate or terminal operations are permitted on this stream instance.</span><br></pre></td></tr></table></figure>

<p>当链接一个新的中间操作，或者执行一个终止操作，流就会被认为被消费掉了，不会再有中间操作和终止操作添加到这个流实例上了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For sequential streams, and parallel streams without stateful intermediate operations, parallel streams, pipeline evaluation is done in a single pass that &quot;jams&quot; all the operations together. For parallel streams with stateful operations, execution is divided into segments, where each stateful operations marks the end of a segment, and each segment is evaluated separately and the result used as the input to the next segment. In all cases, the source data is not consumed until a terminal operation begins.</span><br></pre></td></tr></table></figure>

<p>对于串行流和中间操作都是无状态的并行流，管道的计算是在单个的过程中完成的（即不是通过链式调用，而是拿出一个元素执行所有的中间操作），对于有状态的并行流，管道的计算就会分成不同的段来执行，其中每一个有状态的都会标识一个段的结尾，每个段都会被单独的执行，而且每个段的执行结果会作为下一个段的输入（表示是有顺序的），直到一个终止操作开始的时候，源数据才会被消费。</p>
<p> 接下来是AbstractPipeline类中的一些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractPipeline previousStage;</span><br></pre></td></tr></table></figure>

<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The &quot;upstream&quot; pipeline, or null if this is the source stage.</span><br></pre></td></tr></table></figure>

<p>上游的pipline，如果是源阶段的话就是null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractPipeline sourceStage;</span><br></pre></td></tr></table></figure>

<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Backlink to the head of the pipeline chain (self if this is the source stage).</span><br></pre></td></tr></table></figure>

<p>表示管道反向链接的头（如果是源阶段就是它自身）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br></pre></td></tr></table></figure>

<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The number of intermediate operations between this pipeline object and the stream source if sequential, or the previous stateful if parallel. Valid at the point of pipeline preparation for evaluation.</span><br></pre></td></tr></table></figure>

<p>当前的管道对象和流元的管道对象的中间操作的个数，在流准备进行计算的时候是有效的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> parallel;</span><br></pre></td></tr></table></figure>

<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True if pipeline is parallel, otherwise the pipeline is sequential; only valid for the source stage.</span><br></pre></td></tr></table></figure>

<p>如果是true表示并行，如果是false，表示串行，只有在流源这个阶段才有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Spliterator&lt;?&gt; sourceSpliterator;</span><br></pre></td></tr></table></figure>

<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source spliterator. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSupplier must be null. After the pipeline is consumed if non-null then is set to null.</span><br></pre></td></tr></table></figure>

<p>是针对于元的分割迭代器，只会head pipeline起作用，在管道被消费之前，如果sourceSpliterator是非空的话，那么sourceSupplier必须是null，管道被消费之后sourceSpliterator就要设置为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Supplier&lt;? extends Spliterator&lt;?&gt;&gt; sourceSupplier;</span><br></pre></td></tr></table></figure>

<p>属性的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The source supplier. Only valid for the head pipeline. Before the pipeline is consumed if non-null then sourceSpliterator must be null. After the pipeline is consumed if non-null then is set to null.</span><br></pre></td></tr></table></figure>

<p>supplier的元，只会head pipeline起作用，在管道被消费之前，如果sourceSupplier是空的，那么sourceSpliterator必须为空，在管道被消费之后，就要将sourceSupplier置为null。</p>
<p>可以看到这两个成员变量可以认为是互斥的，必须要保证其中一个不为空，在流消费之后都要置为空，表示流已经消费完成，至此为止，流源的对象也已经构造完成。</p>
<h3 id="流调用机制与原理"><a href="#流调用机制与原理" class="headerlink" title="流调用机制与原理"></a>流调用机制与原理</h3><p>回到一开始的例子当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>这里调用的第一个stream方法，使用分割迭代器来构造流源的这一步我们已经完成了，接下来我们来查看一下forEach方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performs an action for each element of this stream.</span><br><span class="line">This is a terminal operation.</span><br></pre></td></tr></table></figure>

<p>它表示要对于流中每个元素都执行action操作，并且这是一个终止操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.</span><br></pre></td></tr></table></figure>

<p>这个操作的行为是不确定的，对于并行流管道来说，这个操作并不会保证它会遵循流当中元素的顺序，因为如果遵循的话，就会牺牲并行的优势，对于任意给定的元素，这个action可能会在任意的时间或者库所选择的任意线程中去执行，如果库访问了共享的状态，那么它就需要提供完整的同步机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.parallelStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>这其实指的就是如果使用并行流，那么就无法再保证执行给定的Lambda表达式的元素的顺序了，这个方法实际上在ReferencePipeline中是有两个实现的，一个是在它的静态内部类Head中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对串行流进行优化</span></span><br><span class="line">    <span class="keyword">if</span> (!isParallel()) &#123;</span><br><span class="line">        sourceStageSpliterator().forEachRemaining(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是并行流，调用ReferencePipeline中的forEach方法</span></span><br><span class="line">        <span class="keyword">super</span>.forEach(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是针对于管道源的有过优化的实现，换句话说，如果被流的源调用的话，就是直接进入这个方法，另一个forEach方法是在ReferencePipeline当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">     evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当有中间操作的时候，都会进入这个方法，之所以会有这个差异，就是为了效率上的考量，如果有中间操作的话，就需要对于中间操作进行一般化的处理，如果没有的话，就可以直接对流源进行操作。</p>
<p>我们不妨来看一下优化的时候调用的sourceStageSpliterator方法，它是定义在AbstractPipeline当中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> Spliterator&lt;E_OUT&gt; <span class="title">sourceStageSpliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != sourceStage)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"><span class="comment">// 被链接或者被消费，为了保证是在源阶段</span></span><br><span class="line">      <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">          <span class="comment">// MSG_STREAM_LINKED = &quot;stream has already been operated upon or closed&quot;;</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">      linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 流源可能通过两种方式来构建，因此有两种情况，并且这两种情况是互斥的</span></span><br><span class="line">      <span class="keyword">if</span> (sourceStage.sourceSpliterator != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          Spliterator&lt;E_OUT&gt; s = sourceStage.sourceSpliterator;</span><br><span class="line">          sourceStage.sourceSpliterator = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sourceStage.sourceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          Spliterator&lt;E_OUT&gt; s = (Spliterator&lt;E_OUT&gt;) sourceStage.sourceSupplier.get();</span><br><span class="line">          sourceStage.sourceSupplier = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// MSG_CONSUMED = &quot;source already consumed or closed&quot;;</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_CONSUMED);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gets the source stage spliterator if this pipeline stage is the source stage. The pipeline is consumed after this method is called and returns successfully.</span><br></pre></td></tr></table></figure>

<p>如果管道的阶段是源阶段的话，就会返回源阶段的分割迭代器，这个管道在被调用之后，就会返回并且销毁。</p>
<p>我们知道一般情况下分割迭代器返回的是IteratorSpliterator实现，我们来看一下IteratorSpliterator中对于forEachRemaining的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Iterator&lt;? extends T&gt; i;</span><br><span class="line">    <span class="comment">// it是Spliterator中定义的迭代器</span></span><br><span class="line">    <span class="keyword">if</span> ((i = it) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前集合的迭代器</span></span><br><span class="line">        i = it = collection.iterator();</span><br><span class="line">        est = (<span class="keyword">long</span>)collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">    i.forEachRemaining(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将集合中的迭代器找出来并且估算元素的大小，然后再调用Iterator中的新增加的forEachRemaining方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">while</span> (hasNext())</span><br><span class="line">        action.accept(next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里我们就明白了，对于简单的遍历，使用传统的Iterator遍历的效率是要比流的方式效率要高的，当然这是因为我们是没有任何的中间操作，如果有了一系列的中间操作，那么使用流的方式效率还是比传统的方式要高的。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().map(item -&gt; item).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>在ReferencePipeline当中，map方法只有唯一的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="comment">// 返回StatelessOp的匿名内部类对象，this表示ReferencePipeline，第二个参数表示流的类型是引用类型的，第三个是流的特性值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="comment">// 真正执行传入Lambda表达式的地方</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的StatelessOp也是定义在ReferencePipeline当中的一个静态内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessOp</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt;</span></span><br><span class="line"><span class="class">           <span class="keyword">extends</span> <span class="title">ReferencePipeline</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">       StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,</span><br><span class="line">                   StreamShape inputShape,</span><br><span class="line">                   <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">           <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">           <span class="keyword">assert</span> upstream.getOutputShape() == inputShape;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">opIsStateful</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>相关说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Construct a new Stream by appending a stateless intermediate operation to an existing stream.</span><br></pre></td></tr></table></figure>

<p>构造一个针对无状态的中间的阶段的流，这里的构造方法又调用了ReferencePipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferencePipeline(AbstractPipeline&lt;?, P_IN, ?&gt; upstream, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor for appending an intermediate operation onto an existing pipeline.</span><br></pre></td></tr></table></figure>

<p>这个构造方法完成的就是对于已经存在的管道追加一个中间操作，upstream表示上游元素的源。</p>
<p>这里又调用了AbstractPipeline的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">        <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">		<span class="comment">// 标识为已经消费</span></span><br><span class="line">        previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">        previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">        <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">        <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">        <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">        <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">            sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">// 深度加1</span></span><br><span class="line">        <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor for appending an intermediate operation stage onto an existing pipeline.</span><br></pre></td></tr></table></figure>

<p>向一个已有的管道用于追加一个中间操作。</p>
<p>这里也可以看到这个构造方法与我们之前见过的有关构造流源的构造方法的作用完全不同，回到刚才的例子当中，除了上面追加中间操作的部分，还涉及到了另外一个及其重要的类Sink，一般翻译为饮水槽，这是我们了解整个流调用机制的最后一个类。</p>
<h3 id="Sink源码分析"><a href="#Sink源码分析" class="headerlink" title="Sink源码分析"></a>Sink源码分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc. Before calling the accept() method on a Sink for the first time, you must first call the begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method. After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink.</span><br></pre></td></tr></table></figure>

<p>Sink是Consumer接口的一个扩展，用于在整个流管道阶段处理值，还提供了一些额外的信息，比如管理大小的信息，控制流程，等等。在首次调用Sink的accept之前必须先调用begin方法来通知数据即将到达，同时你也可以通知Sink需要处理的数据量是多少，在所有的数据发送完成之后，必须调用end方法，在调用完end方法，你就不应该再去调用accept方法，如果还想调用，就需要再调用一次begin方法，Sink本身可以通过cancellationRequested方法来发出不要再接收数据的信号，那么源在发送数据之前就可以根据判断是否要向Sink发送数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A sink may be in one of two states: an initial state and an active state. It starts out in the initial state; the begin() method transitions it to the active state, and the end() method transitions it back into the initial state, where it can be re-used. Data-accepting methods (such as accept() are only valid in the active state.</span><br></pre></td></tr></table></figure>

<p>一个Sink一定是处于两种状态之一的，一种是初始状态，另一种是激活状态，首先它是从初始状态开始的，使用begin方法可以将它从初始状态转换成激活状态，使用end方法可以将它从激活状态转换成初始状态，这样调用完之后就可以重用了，对于Sink来说，只有在激活状态下才可以接收数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A stream pipeline consists of a source, zero or more intermediate stages (such as filtering or mapping), and a terminal stage, such as reduction or for-each. For concreteness, consider the pipeline:</span><br></pre></td></tr></table></figure>

<p>一个流管道包含了0个或多个中间阶段（比如过滤、映射），还有一个终止阶段，比如汇聚等等，具体考虑下面这个pipeline：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> longestStringLengthStartingWithA</span><br><span class="line">         = strings.stream()</span><br><span class="line">                  .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max();</span><br></pre></td></tr></table></figure>

<p>继续往下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Here, we have three stages, filtering, mapping, and reducing. The filtering stage consumes strings and emits a subset of those strings; the mapping stage consumes strings and emits ints; the reduction stage consumes those ints and computes the maximal value.</span><br></pre></td></tr></table></figure>

<p>这里对我们而言有三个阶段，过滤，映射，汇聚，过滤阶段会消耗字符串集合，会输出字符串的子集，映射阶段会消耗字符串集合，映射成整型值，汇聚阶段会消耗这个整型值并求出最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A Sink instance is used to represent each stage of this pipeline, whether the stage accepts objects, ints, longs, or doubles. Sink has entry points for accept(Object), accept(int), etc, so that we do not need a specialized interface for each primitive specialization. (It might be called a &quot;kitchen sink&quot; for this omnivorous tendency.) The entry point to the pipeline is the Sink for the filtering stage, which sends some elements &quot;downstream&quot; -- into the Sink for the mapping stage, which in turn sends integral values downstream into the Sink for the reduction stage. The Sink implementations associated with a given stage is expected to know the data type for the next stage, and call the correct accept method on its downstream Sink. Similarly, each stage must implement the correct accept method corresponding to the data type it accepts.</span><br></pre></td></tr></table></figure>

<p>Sink实例是用来表示管道的每一个阶段，而无论这个阶段接收的类型，比如 ints, longs, or doubles，Sink对于accept有一个入口点，这样我们就不需要针对于原生类型的特化版本，上面的例子当中，就是一个过滤阶段，Sink会将值映射成整型值向下游发送，最后进行汇聚操作。</p>
<p>Sink中的方法说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling end(), you may call this method to reset the sink for another calculation.</span><br></pre></td></tr></table></figure>

<p>会重新设置Sink的状态并且刷新数据集，向Sink发送任何数据之前一定要调用这个方法，调用完end方法之后，可以再次调用这个方法来重置Sink来进行其他的计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedReference</span>&lt;<span class="title">T</span>, <span class="title">E_OUT</span>&gt; <span class="keyword">implements</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     	<span class="comment">// 表示下游的操作</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream;</span><br><span class="line"><span class="comment">// 会保存下游的对象</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">ChainedReference</span><span class="params">(Sink&lt;? <span class="keyword">super</span> E_OUT&gt; downstream)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.downstream = Objects.requireNonNull(downstream);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">          downstream.begin(size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          downstream.end();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancellationRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> downstream.cancellationRequested();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Abstract Sink implementation for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink&lt;T&gt;. The implementation of the accept() method must call the correct accept() method on the downstream Sink.</span><br></pre></td></tr></table></figure>

<p>它是Sink的一个抽象实现，用于创建Sink的一个链，begin, end, 和cancellationRequested方法都会链接起来，这个实现会接收下游的Sink。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Sink&lt;E_IN&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;E_OUT&gt; sink)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accepts a Sink which will receive the results of this operation, and return a Sink which accepts elements of the input type of this operation and which performs the operation, passing the results to the provided Sink.</span><br></pre></td></tr></table></figure>

<p>它会接收一个Sink作为当前操作的结果(E_OUT)，并且返回一个Sink，返回的Sink（E_IN）会接收这个操作的所对应的输入元素的类型并且执行这个操作，然后将结果传递给所提供的Sink。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a sink which accepts elements, perform the operation upon each element, and passes the results (if any) to the provided Sink.</span><br></pre></td></tr></table></figure>

<p>返回的Sink会接收一个元素，并且对每个元素进行操作，最后将执行的结果（如果有的话）传递给提供的Sink。</p>
<p>正是因为将执行的结果传递给了方法参数的Sink，才将一系列的Sink有机的串联了起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The implementation may use the flags parameter to optimize the sink wrapping. For example, if the input is already DISTINCT, the implementation for the Stream#distinct() method could just return the sink it was passed.</span><br></pre></td></tr></table></figure>

<p>可以使用flags来优化sink，例如，如果输入一定是不同，那么实现的时候，stream.distinct()方法就可以不用再去执行。</p>
<p>总的来说在进行中间操作的时候，StatelessOp继承了ReferencePipeline，而ReferencePipeline又实现了Stream接口，通过StatelessOp创建饮水槽，将中间操作串联起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">TerminalOp&lt;T, Void&gt; <span class="title">makeRef</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,                                              <span class="keyword">boolean</span> ordered)</span> </span>&#123;    Objects.requireNonNull(action);    <span class="keyword">return</span> <span class="keyword">new</span> ForEachOp.OfRef&lt;&gt;(action, ordered);&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actory for creating instances of TerminalOp that perform an action for every element of a stream. Supported variants include unordered traversal (elements are provided to the Consumer as soon as they are available), and ordered traversal (elements are provided to the Consumer in encounter order.)</span><br></pre></td></tr></table></figure>

<p>这是一个工厂，用来创建终止操作的实例，终止操作会对流中的每个元素执行action，支持的变化包括无序的遍历（只要还有元素，就将元素提供给Consumer）还有一种有序的遍历（按照元素输入的顺序提供给Consumer）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elements are provided to the Consumer on whatever thread and whatever order they become available. For ordered traversals, it is guaranteed that processing an element happens-before processing subsequent elements in the encounter order.</span><br></pre></td></tr></table></figure>

<p>在可用的任意的顺序，任意线程都会将元素提供给Consumer ，对于有序的遍历而言，会保证处理一个元素一定是happens-before（某一件事情一定是发生在另外一件事情之前）处理后续的元素之前，即先遇到的先遍历。</p>
<p>makeRef方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructs a TerminalOp that perform an action for every element of a stream.</span><br></pre></td></tr></table></figure>

<p>构造了一个终止操作，并且对流中的每个元素都执行给定的动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TerminalOp</span>&lt;<span class="title">E_IN</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认是引用类型</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> StreamShape <span class="title">inputShape</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> StreamShape.REFERENCE; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getOpFlags</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行的方式</span></span><br><span class="line">    <span class="keyword">default</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;E_IN&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Tripwire.ENABLED)</span><br><span class="line">            Tripwire.trip(getClass(), <span class="string">&quot;&#123;0&#125; triggering TerminalOp.evaluateParallel serial default&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> evaluateSequential(helper, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串行的方式</span></span><br><span class="line">    &lt;P_IN&gt; <span class="function">R <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;E_IN&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Spliterator&lt;P_IN&gt; spliterator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An operation in a stream pipeline that takes a stream as input and produces a result or side-effect. A TerminalOp has an input type and stream shape, and a result type. A TerminalOp also has a set of operation flags that describes how the operation processes elements of the stream (such as short-circuiting or respecting encounter order; see StreamOpFlag).</span><br></pre></td></tr></table></figure>

<p>这是流管道中的一个操作，它会接收一个流作为输入，生成一个结果或者拥有副作用（修改传入参数的引用），一个终止操作会拥有一个输入类型和一个流的类型（引用、整型、长整型等）和一个结果类型，一个终止操作描述了描述了流是如何处理流中元素的（比如短路、有序的执行）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A TerminalOp must provide a sequential and parallel implementation of the operation relative to a given stream source and set of intermediate operations.</span><br></pre></td></tr></table></figure>

<p>终止操作对于给定的流源和中间操作一定要提供并行和串行的实现。</p>
<p>实际上，终止操作的数量并不是特别多。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A TerminalOp that evaluates a stream pipeline and sends the output to itself as a TerminalSink. Elements will be sent in whatever thread they become available. If the traversal is unordered, they will be sent independent of the stream&#x27;s encounter order.</span><br></pre></td></tr></table></figure>

<p>这是一个终止操作，它会计算一个流福安到并且将结果发送给自身作为一个TerminalSink，元素如果可用的话会发送给任意一个线程，如果遍历是无序的，那么在遍历的时候就会独立于流中输入的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This terminal operation is stateless. For parallel evaluation, each leaf instance of a ForEachTask will send elements to the same TerminalSink reference that is an instance of this class.</span><br></pre></td></tr></table></figure>

<p>这个终止操作是无状态的，对于并行计算，每一个叶子节点都会发送个这个类的同一个TerminalSink实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Evaluate the pipeline with a terminal operation to produce a result.</span><br></pre></td></tr></table></figure>

<p>执行一个终止的操作，并且返回一个结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">           ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">           : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串行的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> helper.wrapAndCopyInto(<span class="keyword">this</span>, spliterator).get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Helper class for executing stream pipelines, capturing all of the information about a stream pipeline (output shape, intermediate operations, stream flags, parallelism, etc) in one place.</span><br></pre></td></tr></table></figure>

<p>这是一个执行流管道的辅助类，它会在一个地方捕获关于流管道的所有信息（输出种类，中间操作，特性值，并行或者串行）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A PipelineHelper describes the initial segment of a stream pipeline, including its source, intermediate operations, and may additionally incorporate information about the terminal (or stateful) operation which follows the last intermediate operation described by this PipelineHelper. The PipelineHelper is passed to the TerminalOp.</span><br><span class="line">evaluateParallel(PipelineHelper, Spliterator), TerminalOp.evaluateSequential(PipelineHelper, Spliterator), and AbstractPipeline.opEvaluateParallel(PipelineHelper, Spliterator, IntFunction), methods, which can use the PipelineHelper to access information about the pipeline such as head shape, stream flags, and size, and use the helper methods such as wrapAndCopyInto(Sink, Spliterator), copyInto(Sink, Spliterator), and wrapSink(Sink) to execute pipeline operations.</span><br></pre></td></tr></table></figure>

<p>PipelineHelper描述了一个流管道最开始的阶段，包括它的源，中间操作，以及一些附加的信息关于终止的有状态的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPipeline</span>&lt;<span class="title">E_IN</span>, <span class="title">E_OUT</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">E_OUT</span>, <span class="title">S</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">PipelineHelper</span>&lt;<span class="title">E_OUT</span>&gt; <span class="keyword">implements</span> <span class="title">BaseStream</span>&lt;<span class="title">E_OUT</span>, <span class="title">S</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ordered)</span><br><span class="line">              <span class="keyword">new</span> ForEachOrderedTask&lt;&gt;(helper, spliterator, <span class="keyword">this</span>).invoke();</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">new</span> ForEachTask&lt;&gt;(helper, spliterator, helper.wrapSink(<span class="keyword">this</span>)).invoke();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span>&lt;P_IN, S extends Sink&lt;P_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Applies the pipeline stages described by this PipelineHelper to the provided Spliterator and send the results to the provided Sink.</span><br></pre></td></tr></table></figure>

<p>将PipelineHelper所描述的管道阶段应用到所提供的Spliterator同时把结果发送给提供的Sink。</p>
<p>这个方法在AbstractPipeline中有唯一的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的wrapSink方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span>&lt;P_IN&gt; Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;P_OUT&gt; sink)</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Takes a Sink that accepts elements of the output type of the PipelineHelper, and wrap it with a Sink that accepts elements of the input type and implements all the intermediate operations described by this PipelineHelper, delivering the result into the provided Sink.</span><br></pre></td></tr></table></figure>

<p>它会接收PipelineHelper输出类型的元素，使用Sink对于接收到的所有的元素进行包装成由PipelineHelper所描述的中间操作，并且将结果传递给提供的Sink。</p>
<p>这个方法就是对流中的中间操作进行串联的方法，具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(sink);</span><br><span class="line"><span class="comment">// 深度大于0说明有中间操作。</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span> AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">          <span class="comment">// opWrapSink是map等方法中实现的</span></span><br><span class="line">          sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span>&lt;P_IN&gt; <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法的说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pushes elements obtained from the Spliterator into the provided Sink. If the stream pipeline is known to have short-circuiting stages in it (see StreamOpFlag.SHORT_CIRCUIT), the Sink.cancellationRequested() is checked after each element, stopping if cancellation is requested.</span><br></pre></td></tr></table></figure>

<p>将从Spliterator获取到元素推送到Sink当中，如果这个流管道已经知道了拥有短路的阶段，就会进入短路逻辑的判断，方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TerminalSink是Sink最终的形态。</p>
<h3 id="Stream调用流程"><a href="#Stream调用流程" class="headerlink" title="Stream调用流程"></a>Stream调用流程</h3><p>BaseStream-&gt;Stream-&gt;AbstractPipline-&gt;ReferencePipline-&gt;(Head（流源）、StatelessOp（无状态的中间操作）、StatefulOp（有状态的中间操作））</p>
<p>Terminalop-&gt;(FindOp、ForeachOp、MatchOp、ReduceOp)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SpringFramework</title>
    <url>/2020/07/16/SpringFramework/</url>
    <content><![CDATA[<p>==Spring==</p>
<span id="more"></span>
<h1 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h1><h2 id="Spring特性总览"><a href="#Spring特性总览" class="headerlink" title="Spring特性总览"></a>Spring特性总览</h2><h3 id="Spring-中值得学习的地方"><a href="#Spring-中值得学习的地方" class="headerlink" title="Spring 中值得学习的地方"></a>Spring 中值得学习的地方</h3><ol>
<li>Java语言特性，例如反射、动态代理、枚举、泛型、注解、ARM、Lambda语法</li>
<li>设计思想和模式的实现，如OOP，DDD，TDD，GoF23等</li>
<li>Java API的封装与简化，如JDBC，事务，Transaction，Servlet，JPA，JMX ，Bean Validation</li>
<li>JSR规范的适配与实现</li>
<li>第三方框架的整合，如MyBatis整合Hibernetes和Redis</li>
</ol>
<h3 id="Spring核心特性"><a href="#Spring核心特性" class="headerlink" title="Spring核心特性"></a>Spring核心特性</h3><ol>
<li>IOC容器（IOC Container）</li>
<li>Spring事件（Events）</li>
<li>资源管理（Resources）</li>
<li>国际化（i18n）</li>
<li>校验（Validation）</li>
<li>数据绑定（Data Binding）</li>
<li>类型转换（Type Conversion）</li>
<li>Spring表达式（Spring Express Language）</li>
<li>面向切面编程（AOP）</li>
</ol>
<h3 id="Spring数据存储"><a href="#Spring数据存储" class="headerlink" title="Spring数据存储"></a>Spring数据存储</h3><ol>
<li>JDBC</li>
<li>事务抽象（Transactions）</li>
<li>DAO支持（DAO Support）</li>
<li>O/R映射（O/R Mapping）</li>
<li>XML编列（XML Marshalling）</li>
</ol>
<h3 id="Spring-Web技术"><a href="#Spring-Web技术" class="headerlink" title="Spring Web技术"></a>Spring Web技术</h3><ol>
<li>Web Servlet技术栈<ol>
<li>Spring MVC</li>
<li>WebSocket</li>
<li>SockJS</li>
</ol>
</li>
<li>Web Reactive技术栈<ol>
<li>Spring WebFlux</li>
<li>WebClient</li>
<li>WebSocket</li>
</ol>
</li>
</ol>
<h3 id="Spring技术整合"><a href="#Spring技术整合" class="headerlink" title="Spring技术整合"></a>Spring技术整合</h3><ol>
<li>远程调用（Remoting）</li>
<li>Java消息服务（JMS）</li>
<li>Java连接架构（JCA）</li>
<li>Java管理扩展（JMX）</li>
<li>Java邮件客户端（Email）</li>
<li>本地任务（Taks）</li>
<li>本地调度（Scheduling）</li>
<li>缓存抽象（Caching）</li>
</ol>
<h3 id="Spring测试"><a href="#Spring测试" class="headerlink" title="Spring测试"></a>Spring测试</h3><ol>
<li>模拟对象（Mock Objects）</li>
<li>TestContext框架（TestContext Framework）</li>
<li>Spring MVC测试（Spring MVC Test）</li>
<li>Web 测试客户端（Web TestClient）</li>
</ol>
<h2 id="Spring版本特性"><a href="#Spring版本特性" class="headerlink" title="Spring版本特性"></a>Spring版本特性</h2><table>
<thead>
<tr>
<th>Spring Framework版本</th>
<th>Java标准版</th>
<th>Java企业版</th>
</tr>
</thead>
<tbody><tr>
<td>1.x</td>
<td>1.3+</td>
<td>J2EE 1.3+</td>
</tr>
<tr>
<td>2.x</td>
<td>1.4.2+</td>
<td>J2EE 1.3+</td>
</tr>
<tr>
<td>3.x</td>
<td>5+</td>
<td>J2EE1.4和JavaEE5</td>
</tr>
<tr>
<td>4.x</td>
<td>6+</td>
<td>Java EE6和7</td>
</tr>
<tr>
<td>5.x</td>
<td>8+</td>
<td>Java EE7</td>
</tr>
</tbody></table>
<h2 id="Spring模块化设计"><a href="#Spring模块化设计" class="headerlink" title="Spring模块化设计"></a>Spring模块化设计</h2><p><a href="https://github.com/spring-projects/spring-framework">仓库链接</a></p>
<p><img src="./assets/1618239964959.png" alt="1618239964959"></p>
<h2 id="Spring编程模型"><a href="#Spring编程模型" class="headerlink" title="Spring编程模型"></a>Spring编程模型</h2><ol>
<li><p>面向对象编程</p>
<ol>
<li>锲约接口：Aware、BeanPostProcessor…</li>
<li>设计模式：观察者模式、组合模式、模板模式…</li>
<li>对象继承：Abstract类</li>
</ol>
</li>
<li><p>面向切面编程</p>
<ol>
<li>动态代理：JDKDynamicAopProxy</li>
<li>字节码提升：ASM、CGLib、AspectJ</li>
</ol>
</li>
<li><p>面向元编程</p>
<ol>
<li>注解：模式注解（@Component、@Service、@Respository…）</li>
<li>配置：Environment抽象、PropertySources、BeanDefinition…</li>
<li>泛型：Generic TypeResolver、Resolvable Type…</li>
</ol>
</li>
<li><p>函数驱动</p>
<ol>
<li>函数接口：ApplicationEventPublisher</li>
<li>Reactive：Spring WebFlux</li>
</ol>
</li>
<li><p>模块驱动</p>
<ol>
<li>Maven Artifacts</li>
<li>OSGI Bundies</li>
<li>Java 9 Automatic Modules</li>
<li>Spring @Enable*</li>
</ol>
<p> ​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p>
</li>
</ol>
<h2 id="Spring的核心价值"><a href="#Spring的核心价值" class="headerlink" title="Spring的核心价值"></a>Spring的核心价值</h2><ol>
<li>生态系统<ol>
<li>Spring Boot</li>
<li>Spring Cloud</li>
<li>Spring Security</li>
<li>Spring Data</li>
<li>其他</li>
</ol>
</li>
<li>API抽象设计<ol>
<li>AOP抽象</li>
<li>事务抽象</li>
<li>Environment抽象</li>
<li>生命周期</li>
</ol>
</li>
<li>编程模型<ol>
<li>面向对象编程：契约接口</li>
<li>面向切面编程：动态代理、字节码提升</li>
<li>面向元编程：配置元信息、注解、配置</li>
<li>面向模块编程：Maven Artifacts、Java9 Automatic Modules</li>
<li>Spring @Enable*注解</li>
<li>面向函数式编程：Lambda、Reactive</li>
</ol>
</li>
<li>设计思想<ol>
<li>Object-Oriented Programming（OOP）</li>
<li>Ioc/DI</li>
<li>Domain-Driven Development（DDD）</li>
<li>Test-Driven Development（TDD）</li>
<li>Event-Driven Programing（EDP）</li>
<li>Functional Programing（FP）</li>
</ol>
</li>
<li>设计模式<ol>
<li>专属模式<ol>
<li>前缀模式：Enable模式<ol>
<li>Configurable模式</li>
</ol>
</li>
<li>后缀模式<ol>
<li>处理器模式（Process、Resolver、Handler）</li>
<li>意识模式（Aware）</li>
<li>配置器模式（Configuror）</li>
<li>选择器模式（ImportSelector）</li>
</ol>
</li>
</ol>
</li>
<li>传统GoF23</li>
</ol>
</li>
<li>用户基础<ol>
<li>Spring用户 Spring Framework、SpringBoot、Spring Cloud</li>
<li>传统用户 Java SE、Java EE</li>
</ol>
</li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是Spring-Framework？"><a href="#什么是Spring-Framework？" class="headerlink" title="什么是Spring Framework？"></a>什么是Spring Framework？</h3><p> Spring Framework提供一个完整性的编程或配置的一个现代化的基于Java的企业的应用，Spring的核心特点是在应用级别上的基础设施建设。</p>
<p>Spring使得你的应用开发变的更容易，它可以提供任何你想要的东西，并是拥抱企业环境的Java语言，并且支持可以运行在JVM上面的其他语言，比如Groovy或者Kotlin，同时也提供一些弹性，根据软件的需要提供不同的软件架构。</p>
<h3 id="Spring-Framwork有哪些核心模块？"><a href="#Spring-Framwork有哪些核心模块？" class="headerlink" title="Spring Framwork有哪些核心模块？"></a>Spring Framwork有哪些核心模块？</h3><ol>
<li>Spring-core：Spring 基础API模块，如资源管理、泛型处理</li>
<li>Spring-beans：Spring Bean相关，如依赖查找，依赖注入</li>
<li>Spring-aop：Spring AOP处理，如动态代理，AOP字节码提升</li>
<li>Spring-context：事件驱动、注解驱动、模块驱动</li>
<li>Spring-expresson：Spring 表达式语言模块</li>
</ol>
<h3 id="Spring-Framework的优势和不足是什么？"><a href="#Spring-Framework的优势和不足是什么？" class="headerlink" title="Spring Framework的优势和不足是什么？"></a>Spring Framework的优势和不足是什么？</h3><p>待定…</p>
<h1 id="IoC简介"><a href="#IoC简介" class="headerlink" title="IoC简介"></a>IoC简介</h1><h2 id="IoC的发展简介"><a href="#IoC的发展简介" class="headerlink" title="IoC的发展简介"></a>IoC的发展简介</h2><ol>
<li>1983年，好莱坞原则</li>
<li>1988年，控制反转</li>
<li>1996年，Inversion of control -&gt; Hollywood principle</li>
<li>2004年，Martin Fowler提出了自己对IoC以及DI的理解</li>
<li>2005年，Martin Fowler对IoC做出了进一步的说明</li>
</ol>
<h2 id="IoC主要实现策略"><a href="#IoC主要实现策略" class="headerlink" title="IoC主要实现策略"></a>IoC主要实现策略</h2><ol>
<li>使用service locator pattern（服务定位模式）</li>
<li>通过依赖注入：<ol>
<li>构造器注入</li>
<li>参数注入</li>
<li>Setter注入</li>
<li>接口注入</li>
</ol>
</li>
<li>上下文的依赖查询（beancontext）</li>
<li>模板方法设计模式（例如JDBC）</li>
<li>策略模式</li>
</ol>
<p>IoC主要的实现策略：依赖查找、依赖注入。</p>
<h2 id="IoC容器的职责"><a href="#IoC容器的职责" class="headerlink" title="IoC容器的职责"></a>IoC容器的职责</h2><ol>
<li>依赖处理<ol>
<li>依赖查找</li>
<li>依赖注入</li>
</ol>
</li>
<li>生命周期管理<ol>
<li>容器</li>
<li>托管的资源（Java Beans或其他资源）</li>
</ol>
</li>
<li>配置<ol>
<li>容器</li>
<li>外部化配置</li>
<li>托管的资源（Java Beans或其他资源）</li>
</ol>
</li>
</ol>
<h2 id="IoC的实现"><a href="#IoC的实现" class="headerlink" title="IoC的实现"></a>IoC的实现</h2><ol>
<li>Java SE<ul>
<li>Java Beans</li>
<li>Java ServiceLoader SPI</li>
<li>JNDI（Java Naming and Directory Interface）</li>
</ul>
</li>
<li>Java EE<ul>
<li>EJB（Enterprise Java Beans）</li>
<li>Servlet</li>
</ul>
</li>
<li>开源<ul>
<li>Apache Avalon</li>
<li>PicoContainer</li>
<li>Google Guice</li>
<li>Spring Framework</li>
</ul>
</li>
</ol>
<h2 id="传统IoC容器的实现"><a href="#传统IoC容器的实现" class="headerlink" title="传统IoC容器的实现"></a>传统IoC容器的实现</h2><p>Java Beans 作为IoC容器的特性：</p>
<ul>
<li>依赖查找</li>
<li>生命周期管理</li>
<li>配置元信息</li>
<li>事件</li>
<li>自定义</li>
<li>资源管理</li>
<li>持久化</li>
</ul>
<p>什么是Java Beans呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述人的POJO类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以打印这个Bean的元信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInfoDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(Person.class, Object.class);</span><br><span class="line">        Stream.of(beanInfo.getPropertyDescriptors()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.beans.PropertyDescriptor[name=age; propertyType=class java.lang.Integer; readMethod=public java.lang.Integer beans.Person.getAge(); writeMethod=public void beans.Person.setAge(java.lang.Integer)]</span><br><span class="line">java.beans.PropertyDescriptor[name=name; propertyType=class java.lang.String; readMethod=public java.lang.String beans.Person.getName(); writeMethod=public void beans.Person.setName(java.lang.String)]</span><br></pre></td></tr></table></figure>

<h2 id="如何界定IoC容器是轻量级的？"><a href="#如何界定IoC容器是轻量级的？" class="headerlink" title="如何界定IoC容器是轻量级的？"></a>如何界定IoC容器是轻量级的？</h2><p>以下观点出自于《J2EE Development without EJB》</p>
<ol>
<li>管理应用代码</li>
<li>能够快速启动</li>
<li>容器不需要一些特殊的配置来进行操作（主要是针对于EJB）</li>
<li>容器的内存占用小以及最小化API的一个依赖</li>
<li>容器需要一些可以管控的一个渠道，这个渠道能够帮助我们去部署和管理一些细粒度的对象，甚至是一些粗粒度的组件</li>
</ol>
<h2 id="依赖查找和依赖注入"><a href="#依赖查找和依赖注入" class="headerlink" title="依赖查找和依赖注入"></a>依赖查找和依赖注入</h2><table>
<thead>
<tr>
<th>类型</th>
<th>依赖处理</th>
<th>实现便利性</th>
<th>代码入侵性</th>
<th>API依赖性</th>
<th>可读性</th>
</tr>
</thead>
<tbody><tr>
<td>依赖查找</td>
<td>主动获取</td>
<td>相对繁琐</td>
<td>侵入业务逻辑</td>
<td>依赖容器API</td>
<td>良好</td>
</tr>
<tr>
<td>依赖注入</td>
<td>被动提供</td>
<td>相对便利</td>
<td>低入侵性</td>
<td>不主动依赖容器API</td>
<td>一般</td>
</tr>
</tbody></table>
<h2 id="构造器注入和Setter注入"><a href="#构造器注入和Setter注入" class="headerlink" title="构造器注入和Setter注入"></a>构造器注入和Setter注入</h2><p>Spring官方推荐使用构造器注入，这样可以确保在注入时，对象不为空，但是参数过多时会影响代码的整洁性，可能需要考虑重构。</p>
<p>Setter注入应该主要仅用于我们的可选性的注入，因为Setter的字段本身是可以为空的。</p>
<p>而《J2EE Development without EJB》认为应该使用Setter注入，原因在于：</p>
<ol>
<li>JavaBean属性能够获取更好的IDE支持</li>
<li>JavaBean属性通常是一个自文档的说明</li>
<li>在类型转换上有优势</li>
<li>大量的JavaBeans可能不经过任何修改就可以在JavaBean容器当中使用</li>
</ol>
<p>当然，Setter注入也有缺点，就是无法确定属性初始化的顺序。</p>
<h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是IoC？"><a href="#什么是IoC？" class="headerlink" title="什么是IoC？"></a>什么是IoC？</h3><p>简单地说，IoC是反转控制，类似于好莱坞原则，主要有依赖查找和依赖注入两种实现。按照IoC的定义，很多方面其实都是IoC，比如JavaBeans是IoC的一个容器实现，Servlet的容器也是IoC的实现，因为Servlet可以去依赖或者反向地通过JNDI的方式进行得到一些外部的一些资源，包括DataSource或者相关的EJB的组件，于此同时SpringFramework或者Peak Container的依赖注入的框架，也能帮助我们去实现IoC，除此之外，消息也可以看作是IoC的一种实现。</p>
<h3 id="依赖查找和依赖注入的区别？"><a href="#依赖查找和依赖注入的区别？" class="headerlink" title="依赖查找和依赖注入的区别？"></a>依赖查找和依赖注入的区别？</h3><p>依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准API实现。而依赖注入则是手动或自动依赖绑定的方式，无需依赖特定的容器和API。</p>
<h3 id="Spring作为IoC容器有什么优势？"><a href="#Spring作为IoC容器有什么优势？" class="headerlink" title="Spring作为IoC容器有什么优势？"></a>Spring作为IoC容器有什么优势？</h3><p>典型的IoC管理，依赖查找和依赖注入，AOP抽象，事务抽象，事件机制，SPI扩展，强大的第三方整合，易测试性，更好的面向对象。</p>
<h1 id="IoC实践"><a href="#IoC实践" class="headerlink" title="IoC实践"></a>IoC实践</h1><h2 id="Spring-IoC依赖查找"><a href="#Spring-IoC依赖查找" class="headerlink" title="Spring IoC依赖查找"></a>Spring IoC依赖查找</h2><ol>
<li>根据Bean名称查找<ul>
<li>实时查找</li>
<li>延迟查找</li>
</ul>
</li>
<li>根据Bean类型查找<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
</li>
<li>根据Bean名称+类型查找</li>
<li>根据Java注解查找</li>
</ol>
<p>新建一个用户类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个超级用户类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超级用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Super</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperUser</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SuperUser&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;&#125; &quot;</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Super &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>向容器中注入一些Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吉永超&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;SuperUser&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.SuperUser&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;user&quot;</span> <span class="attr">primary</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;深圳&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;objectFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖查找的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyLookupDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置XML文件</span></span><br><span class="line">        <span class="comment">// 启动Spring应用上下文</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 实时查找</span></span><br><span class="line">        lookupInRealTime(beanFactory);</span><br><span class="line">        <span class="comment">// 延迟查找</span></span><br><span class="line">        lookupInLazy(beanFactory);</span><br><span class="line">        <span class="comment">// 按照类型查找</span></span><br><span class="line">        lookupByType(beanFactory);</span><br><span class="line">        <span class="comment">// 按照类型查找集合对象</span></span><br><span class="line">        lookupCollectionType(beanFactory);</span><br><span class="line">        <span class="comment">// 通过注解查找</span></span><br><span class="line">        lookupByAnnotationType(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过注解查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByAnnotationType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = (Map)listableBeanFactory.getBeansWithAnnotation(Super.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有标注@Super的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        User user = beanFactory.getBean(User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照类型查找 &quot;</span> + user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupInLazy</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        ObjectFactory&lt;User&gt; objectFactory = (ObjectFactory&lt;User&gt;) beanFactory.getBean(<span class="string">&quot;objectFactory&quot;</span>);</span><br><span class="line">        User user = objectFactory.getObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;延迟查找 &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实时查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupInRealTime</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        User user = (User) beanFactory.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;实时查找&quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-IoC依赖注入"><a href="#Spring-IoC依赖注入" class="headerlink" title="Spring IoC依赖注入"></a>Spring IoC依赖注入</h2><ol>
<li>根据Bean名称注入</li>
<li>根据Bean类型注入<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
</li>
<li>注入容器内建的Bean对象</li>
<li>注入非Bean对象</li>
<li>注入类型<ul>
<li>实时注入</li>
<li>延迟注入</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息仓库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRespository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; users; <span class="comment">// 自定义Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory; <span class="comment">//内建的非Bean对象（对象）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;ApplicationContext&gt; objectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsers</span><span class="params">(Collection&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.users = users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectFactory&lt;ApplicationContext&gt; <span class="title">getObjectFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectFactory</span><span class="params">(ObjectFactory&lt;ApplicationContext&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类似的资源：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过导入复用   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--   Auto-wiring     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRespository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.repository.UserRespository&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   手动配置     --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;users&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;util:list&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;ref bean=&quot;user&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;ref bean=&quot;SuperUser&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;/util:list&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置XML文件</span></span><br><span class="line">        <span class="comment">// 启动Spring应用上下文</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;META-INF/dependency-injection-context.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserRespository userRespository = beanFactory.getBean(<span class="string">&quot;userRespository&quot;</span>, UserRespository.class);</span><br><span class="line"><span class="comment">//        System.out.println(userRespository.getUsers());</span></span><br><span class="line">        System.out.println(userRespository.getBeanFactory());</span><br><span class="line"><span class="comment">//        System.out.println(userRespository.getBeanFactory() == beanFactory);</span></span><br><span class="line">        ObjectFactory&lt;ApplicationContext&gt; userFactory = userRespository.getObjectFactory();</span><br><span class="line">        System.out.println(userFactory.getObject() == beanFactory);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比结果可以发现依赖查找和依赖注入的来源并不一样。</p>
<h2 id="Spring依赖注入和依赖查找的来源"><a href="#Spring依赖注入和依赖查找的来源" class="headerlink" title="Spring依赖注入和依赖查找的来源"></a>Spring依赖注入和依赖查找的来源</h2><ol>
<li>自定义Bean</li>
<li>容器内建Bean对象</li>
<li>容器内建依赖</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置XML文件</span></span><br><span class="line">        <span class="comment">// 启动Spring应用上下文</span></span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;META-INF/dependency-injection-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 自定义的Bean</span></span><br><span class="line">        UserRespository userRespository = beanFactory.getBean(<span class="string">&quot;userRespository&quot;</span>, UserRespository.class);</span><br><span class="line">        <span class="comment">// 依赖注入（内建依赖）</span></span><br><span class="line">        System.out.println(userRespository.getBeanFactory());</span><br><span class="line">        <span class="comment">// 容器内建Bean对象</span></span><br><span class="line">        Environment environment = beanFactory.getBean(Environment.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取Enviroment类型的Bean&quot;</span> + environment);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-IoC配置元信息"><a href="#Spring-IoC配置元信息" class="headerlink" title="Spring IoC配置元信息"></a>Spring IoC配置元信息</h2><ol>
<li>Bean定义配置<ul>
<li>基于XML文件</li>
<li>基于Properties文件</li>
<li>基于Java注解</li>
<li>基于Java API（专题讨论）</li>
</ul>
</li>
<li>IoC容器配置<ul>
<li>基于XML文件</li>
<li>基于Java注解</li>
<li>基于Java API（专题讨论）</li>
</ul>
</li>
<li>外部化属性配置<ul>
<li>基于Java注解</li>
</ul>
</li>
</ol>
<h2 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h2><p>BeanFactory和ApplicationContext谁才是Spring IoC容器？</p>
<p>BeanFactory是一个具有基本功能的框架，而ApplicationContext添加了更多企业级的特性，总而言之，ApplicationContext是BeanFactory的超集，并且在实现上，ApplicationContext虽然继承了BeanFactory接口，但内部的BeanFactory是采用组合的方式进行的实现，默认的实现类为DefaultListableBeanFactory。</p>
<p>ApplicationContext除了IoC容器角色，还有提供：</p>
<ul>
<li>面向切面（AOP）</li>
<li>配置元信息（Configuration Metadata）</li>
<li>资源管理（Resources）</li>
<li>事件（Events）</li>
<li>国际化（i18n）</li>
<li>注解（Annotations）</li>
<li>Environment抽象（Environment Abstraction）</li>
</ul>
<p>BeanFactory的IoC容器的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanFactory作为IoC容器示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAsIoCContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建BeanFactory容器</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 加载配置</span></span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        <span class="comment">// XML配置文件ClassPath路径</span></span><br><span class="line">        String location = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 加载配置</span></span><br><span class="line">        <span class="keyword">int</span> beanDefinitions = reader.loadBeanDefinitions(location);</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean定义加载的数量: &quot;</span> + beanDefinitions);</span><br><span class="line">        <span class="comment">// 依赖查找集合对象....</span></span><br><span class="line">        lookupCollectionType(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application的IoC容器使用：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ApplicationA作为IoC容器示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationApplicationAsIoCContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建BeanFactory容器</span></span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(AnnotationApplicationAsIoCContainerDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 依赖查找集合对象....</span></span><br><span class="line">        lookupCollectionType(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">            ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">            Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用BeanFactory和ApplicationContext都可以完成依赖查找的功能。</p>
<h2 id="Spring-IoC容器生命周期"><a href="#Spring-IoC容器生命周期" class="headerlink" title="Spring IoC容器生命周期"></a>Spring IoC容器生命周期</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line">			beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">			contextRefresh.end();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是Spring-IoC容器"><a href="#什么是Spring-IoC容器" class="headerlink" title="什么是Spring IoC容器"></a>什么是Spring IoC容器</h3><p>Spring Framework是IoC（控制反转）的一种具体的实现，主要包括了DI（dependency injection），和DL（dependency lookup）。</p>
<h3 id="BeanFactory和FactoryBean"><a href="#BeanFactory和FactoryBean" class="headerlink" title="BeanFactory和FactoryBean"></a>BeanFactory和FactoryBean</h3><p>BeanFactory是IoC底层容器，FactoryBean是创建Bean的一种方式，帮助实现复杂的初始化逻辑。</p>
<h3 id="Spring-IoC容器启动时做了哪些准备？"><a href="#Spring-IoC容器启动时做了哪些准备？" class="headerlink" title="Spring IoC容器启动时做了哪些准备？"></a>Spring IoC容器启动时做了哪些准备？</h3><p>IoC配置元信息读取和解析、IoC容器生命周期、Spring事件发布、国际化等。</p>
<h1 id="Spring-Bean基础"><a href="#Spring-Bean基础" class="headerlink" title="Spring Bean基础"></a>Spring Bean基础</h1><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>BeanDefinition时Spring Framework中定义Bean配置元信息接口，包含：</p>
<ol>
<li>Bean的类名（必须是全限定类名）</li>
<li>Bean行为配置元素，如作用域、自动绑定的模式、生命周期回调等</li>
<li>其他Bean引用，又可称合作者（collaborators）或者依赖（dependencies）</li>
<li>配置设置，比如Bean属性（Properties）</li>
</ol>
<p>BeanDefinition元信息</p>
<table>
<thead>
<tr>
<th>属性（Property）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td>Bean全类名，必须是具体类，不能用抽象类或接口</td>
</tr>
<tr>
<td>Name</td>
<td>Bean的名称或者ID</td>
</tr>
<tr>
<td>Scope</td>
<td>Bean的作用域（如：singleton、prototype等）</td>
</tr>
<tr>
<td>Constructor arguments</td>
<td>Bean构造器参数（用于依赖注入）</td>
</tr>
<tr>
<td>Properties</td>
<td>Bean属性设置（用于依赖注入）</td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>Bean自动绑定模式（如：通过名称byName）</td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td>Bean延迟初始化模式（延迟和非延迟）</td>
</tr>
<tr>
<td>Initialization method</td>
<td>Bean初始化回调方法名称</td>
</tr>
<tr>
<td>Destruction method</td>
<td>Bean销毁回调方法名称</td>
</tr>
</tbody></table>
<p>BeanDefinition的构建方式</p>
<ol>
<li>通过BeanDefinitionBuilder</li>
<li>通过AbstactBeanDefinition以及派生类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanDefinition构建示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionCreationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通过BeanDefinitionBuilder</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);</span><br><span class="line">        <span class="comment">// 通过属性设置</span></span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jyc&quot;</span>);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BeanDefinition实例</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// BeanDefinition并非Bean的终态，可以自定义修改</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过AbstactBeanDefinition以及派生类</span></span><br><span class="line">        GenericBeanDefinition genericBeanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        <span class="comment">// 设置Bean类型</span></span><br><span class="line">        genericBeanDefinition.setBeanClass(User.class);</span><br><span class="line">        <span class="comment">// 通过MutablePropertyValues批量操作属性</span></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">        propertyValues.addPropertyValue(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        propertyValues.addPropertyValue(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jyc&quot;</span>);</span><br><span class="line">        genericBeanDefinition.setPropertyValues(propertyValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Bean命名"><a href="#Spring-Bean命名" class="headerlink" title="Spring Bean命名"></a>Spring Bean命名</h2><p>什么是Bean的名称？</p>
<p>每个Bean拥有一个或多个标识符（identifiers），这些标识符在Bean所在的容器必须是唯一的。通常，一个Bean仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。</p>
<p>在基于XML的配置元信息中，开发人员可用id或者name属性来规定Bean的标识符。通常Bean的标识符由字母组成，允许出现特殊字符，如果要想映入新的Bean的别名的话，可在name属性使用半角逗号（“,”）或分号（“;”）来间隔。</p>
<p>Bean的id或name属性并非必须制定，如果留空的话，容器回味Bean自动生成一个唯一的名称。Bean的名称尽管没有限制，不过官方建议采用驼峰的方式，更符合Java的命名约定。</p>
<p>Bean名称生成器（BeanNameGenerator）主要有两种实现：</p>
<ol>
<li>DefaultBeanNameGenerator（默认通用BeanNameGenerator实现）</li>
<li>AnnotationBeanNameGenerator</li>
</ol>
<p>默认实现的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateBeanName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		BeanDefinition definition, BeanDefinitionRegistry registry, <span class="keyword">boolean</span> isInnerBean)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	String generatedBeanName = definition.getBeanClassName();</span><br><span class="line">	<span class="keyword">if</span> (generatedBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (definition.getParentName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			generatedBeanName = definition.getParentName() + <span class="string">&quot;$child&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (definition.getFactoryBeanName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			generatedBeanName = definition.getFactoryBeanName() + <span class="string">&quot;$created&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(generatedBeanName)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Unnamed bean definition specifies neither &quot;</span> +</span><br><span class="line">				<span class="string">&quot;&#x27;class&#x27; nor &#x27;parent&#x27; nor &#x27;factory-bean&#x27; - can&#x27;t generate bean name&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isInnerBean) &#123;</span><br><span class="line">		<span class="comment">// Inner bean: generate identity hashcode suffix.</span></span><br><span class="line">		<span class="keyword">return</span> generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Top-level bean: use plain class name with unique suffix if necessary.</span></span><br><span class="line">	<span class="keyword">return</span> uniqueBeanName(generatedBeanName, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是简单场景的Bean的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uniqueBeanName</span><span class="params">(String beanName, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	String id = beanName;</span><br><span class="line">	<span class="keyword">int</span> counter = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Increase counter until the id is unique.</span></span><br><span class="line">	String prefix = beanName + GENERATED_BEAN_NAME_SEPARATOR;</span><br><span class="line">	<span class="keyword">while</span> (counter == -<span class="number">1</span> || registry.containsBeanDefinition(id)) &#123;</span><br><span class="line">		counter++;</span><br><span class="line">		id = prefix + counter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解实现的核心源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">			String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">				<span class="comment">// Explicit bean name found.</span></span><br><span class="line">				<span class="keyword">return</span> beanName;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">		<span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果是一个普通的Bean就会调用Java Beans的API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">	String beanClassName = definition.getBeanClassName();</span><br><span class="line">	Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">&quot;No bean class name set&quot;</span>);</span><br><span class="line">	String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">	<span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean别名（Alias）的价值：</p>
<ol>
<li><p>复用现有的BeanDefinition</p>
</li>
<li><p>更具有场景化的命名方法，比如：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemA-datasource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemB-datasource&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="BeanDefinition注册到IoC容器"><a href="#BeanDefinition注册到IoC容器" class="headerlink" title="BeanDefinition注册到IoC容器"></a>BeanDefinition注册到IoC容器</h2><p>BeanDefinition注册的不同方式：</p>
<ol>
<li>XML配置元信息<ul>
<li>&lt;bean name =”…” … /&gt;</li>
</ul>
</li>
<li>Java注解配置元信息<ul>
<li>@Bean</li>
<li>@Component</li>
<li>@import</li>
</ul>
</li>
<li>Java API配置元信息<ul>
<li>命名方式：BeanDefinitionRegistry#registerBeanDefinition（String，BeanDefinition）</li>
<li>非命名方式：BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition，BeanDefinitionRegistry)</li>
<li>配置类方式：AnnotatedBeanDefinitionReader#register（Class）</li>
</ul>
</li>
</ol>
<p>通过Java注解配置元信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解BeanDefinition示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Import(AnnotationBeanDefinitionDemo.Config.class)</span> <span class="comment">// 3.通过@Import方式导入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanDefinitionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册配置类（configuration class）</span></span><br><span class="line">        applicationContext.register(AnnotationBeanDefinitionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        System.out.println(<span class="string">&quot;Config类型的所有的Beans&quot;</span> + applicationContext.getBeansOfType(Config.class));</span><br><span class="line">        System.out.println(<span class="string">&quot;user类型的所有的Beans&quot;</span> + applicationContext.getBeansOfType(User.class));</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过Component方式</span></span><br><span class="line">    <span class="meta">@Component</span> <span class="comment">//定义当前类作为Spring Bean（组件）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通过@Bean方式定义</span></span><br><span class="line">        <span class="meta">@Bean(&#123;&quot;user&quot;, &quot;jyc&quot;&#125;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            user.setName(<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java API配置元信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 命名Bean的注册方式</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerUserBeanDefinition</span><span class="params">(BeanDefinitionRegistry registry, String beanName)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>).addPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jiyongchao&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断如果beanName参数存在时</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            registry.registerBeanDefinition(beanName, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非命名的Bean注册方法</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(), registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化Bean的方式"><a href="#实例化Bean的方式" class="headerlink" title="实例化Bean的方式"></a>实例化Bean的方式</h2><p>Bean实例化：</p>
<ol>
<li><p>常规方式</p>
<ul>
<li>通过构造器（配置元信息：XML、Java注解和Java API）</li>
<li>通过静态工厂方法（配置元信息：XML和Java API）</li>
<li>通过Bean工厂方法（配置元信息：XML和Java API）</li>
<li>通过FactoryBean（配置元信息：XML、Java注解和Java API）</li>
</ul>
</li>
<li><p>特殊方式</p>
<ul>
<li>通过ServiceLoaderFactoryBean（配置元信息：XML、Java注解和Java API）</li>
<li>通过AutowireCapableBeanFactory#createBean（java.lang.Class，int，boolean）</li>
<li>通过BeanDefinitionResgistry#registerBeanDefinition（String，BeanDefinition）</li>
</ul>
<p> 常规方式实例化的示例：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  静态方法实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user-by-static-method&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUser&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  实例方法实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user-by-instance-method&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUser&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  Bean工厂实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.definition.factory.DefaultUserFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  FactoryBean实例化Bean  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user-by-factory-bean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.definition.factory.UserFactoryBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中UserFactoryBean为：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User Bean的FactoryBean的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试输出：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bean实例化示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/bean-instantiation-context.xml&quot;</span>);</span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user-by-static-method&quot;</span>, User.class);</span><br><span class="line">        User userByInstanceMethod = beanFactory.getBean(<span class="string">&quot;user-by-instance-method&quot;</span>, User.class);</span><br><span class="line">        User userByFactoryBean = beanFactory.getBean(<span class="string">&quot;user-by-instance-method&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(userByInstanceMethod);</span><br><span class="line">        System.out.println(userByFactoryBean);</span><br><span class="line"></span><br><span class="line">        System.out.println(user == userByInstanceMethod);</span><br><span class="line">        System.out.println(user == userByFactoryBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 特殊方式的示例：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactoryServiceLoader&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.definition.factory.UserFactory&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 测试输出：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialBeanInstantiationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BeanFactory beanFactory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/special-bean-instantiation-context.xml&quot;</span>);</span><br><span class="line">        ServiceLoader serviceLoader = beanFactory.getBean(<span class="string">&quot;userFactoryServiceLoader&quot;</span>, ServiceLoader.class);</span><br><span class="line">        displayServiceLoader(serviceLoader);</span><br><span class="line">        demoServiceLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demoServiceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;UserFactory&gt; serviceLoader = ServiceLoader.load(UserFactory.class, Thread.currentThread().getContextClassLoader());</span><br><span class="line">        displayServiceLoader(serviceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayServiceLoader</span><span class="params">(ServiceLoader&lt;UserFactory&gt; serviceLoader)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;UserFactory&gt; iterator = serviceLoader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            UserFactory userFactory = iterator.next();</span><br><span class="line">            System.out.println(userFactory.createUser());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过AutowireCapableBeanFactory实例化：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/special-bean-instantiation-context.xml&quot;</span>);</span><br><span class="line">     <span class="comment">// 通过ApplicationContext获取AutowireCapableBeanFactory</span></span><br><span class="line">     AutowireCapableBeanFactory beanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">     <span class="comment">// 通过AutowireCapableBeanFactory创建UserFactory对象</span></span><br><span class="line">     UserFactory userFactory = beanFactory.createBean(DefaultUserFactory.class);</span><br><span class="line">     System.out.println(userFactory.createUser());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化Bean的方式"><a href="#初始化Bean的方式" class="headerlink" title="初始化Bean的方式"></a>初始化Bean的方式</h2><p> Bean的初始化（Initialization）：</p>
<ol>
<li>@PostConstruct标注方法</li>
<li>实现InitializingBean接口的afterPropertiesSet()方法</li>
<li>自定义初始化方法<ul>
<li>XML配置：&lt;bean init-method=”init” … /&gt;</li>
<li>Java注解：@Bean(initMethod=”init”)</li>
<li>Java API：AbstractBeanDefinition#setInitMethodName(String)</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>初始化的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultUserFactory</span> <span class="keyword">implements</span> <span class="title">UserFactory</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.基于@PostConstruct注解</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;@PostConstruct: UserFactory 初始化中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterPropertiesSet: UserFactory 初始化中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUserFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义初始化方法： initUserFactory： UserFactory 初始化中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInitializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanInitializationDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        UserFactory userFactory = applicationContext.getBean(UserFactory.class);</span><br><span class="line">        applicationContext.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;initUserFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserFactory <span class="title">userFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终实际上都会调用的AbstractBeanDefinition的setInitMethodName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitMethodName</span><span class="params">(<span class="meta">@Nullable</span> String initMethodName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.initMethodName = initMethodName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三者的执行顺序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span>: UserFactory 初始化中....</span><br><span class="line">afterPropertiesSet: UserFactory 初始化中....</span><br><span class="line">自定义初始化方法： initUserFactory： UserFactory 初始化中....</span><br></pre></td></tr></table></figure>

<h2 id="延迟初始化Bean"><a href="#延迟初始化Bean" class="headerlink" title="延迟初始化Bean"></a>延迟初始化Bean</h2><p>Bean延迟初始化（Lazy Initialization）</p>
<ol>
<li>XML配置：&lt;bean lazy-init=”true” …/&gt;</li>
<li>Java注解：@Lazy(true)</li>
</ol>
<p>Spring容器返回的对象和非延迟的对象存在怎样的差异？</p>
<p>非延迟初始化在Spring应用上下文启动完成后，被初始化。而延迟初始化是在依赖查找和依赖注入的时候才会进行初始化。</p>
<h2 id="销毁Bean"><a href="#销毁Bean" class="headerlink" title="销毁Bean"></a>销毁Bean</h2><p>Bean销毁（Destroy）</p>
<ol>
<li>@PreDestory标注方法</li>
<li>实现DisposableBean接口的destory()方法</li>
<li>自定义销毁方法<ul>
<li>XML配置：&lt;bean destory=”destory” …/&gt;</li>
<li>Java注解：@Bean(destory=”destory”)</li>
<li>Java API: AbstractBeanDefinition#setDestoryMethodName(String)</li>
</ul>
</li>
</ol>
<p>销毁的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultUserFactory</span> <span class="keyword">implements</span> <span class="title">UserFactory</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;@PreDestroy: UserFactory 销毁中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DisposableBean#destroy: UserFactory 销毁中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义销毁方法：doDestory()： UserFactory 销毁中....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDestoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanDestoryDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 非延迟初始化在Spring应用上下文启动完成后，被初始化。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;应用上下文已启动...&quot;</span>);</span><br><span class="line">        UserFactory userFactory = applicationContext.getBean(UserFactory.class);</span><br><span class="line">        System.out.println(userFactory);</span><br><span class="line">        System.out.println(<span class="string">&quot;应用上下文准备关闭...&quot;</span>);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;应用上下文已关闭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;doDestory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserFactory <span class="title">userFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过不同时机的打印，可以观察到Bean的销毁的时机就是在应用上下文关闭的时候。</p>
<p>三者不同方式的执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">应用上下文已启动...</span><br><span class="line">应用上下文准备关闭...</span><br><span class="line"><span class="meta">@PreDestroy</span>: UserFactory 销毁中....</span><br><span class="line">DisposableBean#destroy: UserFactory 销毁中....</span><br><span class="line">自定义销毁方法：doDestory()： UserFactory 销毁中....</span><br><span class="line">应用上下文已关闭...</span><br></pre></td></tr></table></figure>

<h2 id="垃圾回收Spring-Bean"><a href="#垃圾回收Spring-Bean" class="headerlink" title="垃圾回收Spring Bean"></a>垃圾回收Spring Bean</h2><p>Bean垃圾回收（GC）</p>
<ol>
<li>关闭Spring容器（应用上下文）</li>
<li>执行GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bena垃圾回收的示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanGarbageCollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanInitializationDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Spring 应用上下文已关闭&quot;</span>);</span><br><span class="line">        <span class="comment">// 强制触发GC</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们重写了DefaultUserFactory中的finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前DefaultUserFactory 对象正在被垃圾回收&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h2><h3 id="如何注册一个Spring-Bean？"><a href="#如何注册一个Spring-Bean？" class="headerlink" title="如何注册一个Spring Bean？"></a>如何注册一个Spring Bean？</h3><p>通过BeanDefinition和外部单体对象来注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单体Bean注册示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonBeanRegistrationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册外部单例对象</span></span><br><span class="line">        UserFactory userFactory = <span class="keyword">new</span> DefaultUserFactory();</span><br><span class="line">        <span class="comment">// 创建一个外部UserFactory对象</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();</span><br><span class="line">        <span class="comment">// 注册外部单例对象</span></span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;userFactory&quot;</span>, userFactory);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        UserFactory userFactoryByLookup = beanFactory.getBean(<span class="string">&quot;userFactory&quot;</span>, UserFactory.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;userFactory == userFactoryByLookup: &quot;</span> + (userFactory == userFactoryByLookup));</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是Spring-BeanDefinition？"><a href="#什么是Spring-BeanDefinition？" class="headerlink" title="什么是Spring BeanDefinition？"></a>什么是Spring BeanDefinition？</h3><p>BeanDefinition是关于Bean定义的元信息的接口，允许我们通过getter、setter方法方式来进行存储信息。</p>
<h3 id="Spring容器是怎样管理注册Bean"><a href="#Spring容器是怎样管理注册Bean" class="headerlink" title="Spring容器是怎样管理注册Bean"></a>Spring容器是怎样管理注册Bean</h3><p>如IoC配置元信息读取和解析、依赖查找和注入以及Bean生命周期等。</p>
<h1 id="依赖查找"><a href="#依赖查找" class="headerlink" title="依赖查找"></a>依赖查找</h1><h2 id="依赖查找简介"><a href="#依赖查找简介" class="headerlink" title="依赖查找简介"></a>依赖查找简介</h2><ol>
<li>单一类型依赖查找<ul>
<li>JNDI - javax.naming.Context#lookup(javax.naming.Name)</li>
<li>JavaBeans - java.beans.beancontext.BeanContext</li>
</ul>
</li>
<li>集合类型依赖查找<ul>
<li>java.beans.beancontext.BeanContext</li>
</ul>
</li>
<li>层次性依赖查找<ul>
<li>java.beans.beancontext.BeanContext</li>
</ul>
</li>
</ol>
<h2 id="单一类型依赖查找"><a href="#单一类型依赖查找" class="headerlink" title="单一类型依赖查找"></a>单一类型依赖查找</h2><p>单一类型依赖查找接口-BeanFactory</p>
<ol>
<li>根据Bean名称查找<ul>
<li>getBean(String)</li>
<li>Spring 2.5 覆盖默认参数：getBean(String,Object…)</li>
</ul>
</li>
<li>根据Bean类型查找<ul>
<li>Bean实时查找<ul>
<li>Spring 3.0 getBean(Class)</li>
<li>Spring 4.1 覆盖默认参数：getBean(Class,Object…)</li>
</ul>
</li>
<li>Spring 5.1 Bean延迟查找<ul>
<li>getBeanProvider(Class)</li>
<li>getBeanProvider(ResolvableType)</li>
</ul>
</li>
</ul>
</li>
<li>根据Bean名称 + 类型查找：getBean(String,Class) </li>
</ol>
<p>利用ObejctProvider进行依赖查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ObjectProvider进行依赖查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObejctProviderDemo</span> </span>&#123; <span class="comment">// @Configuration是非必须的注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ObejctProviderDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        lookupByObejctProvider(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloworld</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法名就是Bean名称 = “helloworld”</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByObejctProvider</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);</span><br><span class="line">        System.out.println(beanProvider.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合类型依赖查找"><a href="#集合类型依赖查找" class="headerlink" title="集合类型依赖查找"></a>集合类型依赖查找</h2><p>集合类型依赖查找接口-ListableBeanFactory</p>
<ol>
<li>根据Bean类型查找<ul>
<li>根据同类型Bean名称列表<ul>
<li>getBeanNamesForType（Class）</li>
<li>Spring 4.2 getBeanNamesForType（ResolvableType）</li>
</ul>
</li>
<li>获取同类型Bean实例列表<ul>
<li>getBeanOfType（Class）以及重载方法</li>
</ul>
</li>
</ul>
</li>
<li>通过注解类型查找<ul>
<li>Spring 3.0 获取标注类型Bean名称列表<ul>
<li>getBeanNamesForAnnotation（Class&lt;? extends Annotation&gt;）</li>
</ul>
</li>
<li>Spring 3.0 获取标注类型Bean实例列表<ul>
<li>getBeansWithAnnotation（Class&lt;? extends Annotation&gt;）</li>
</ul>
</li>
<li>Spring 3.0 获取指定名称 + 标注类型Bean 实例</li>
</ul>
</li>
</ol>
<p>相关的示例实际上在之前就已经提到过了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过注解查找</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByAnnotationType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">          ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">          Map&lt;String, User&gt; users = (Map)listableBeanFactory.getBeansWithAnnotation(Super.class);</span><br><span class="line">          System.out.println(<span class="string">&quot;查找到的所有标注@Super的User集合对象：&quot;</span> + users);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 按照类型查找集合对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> beanFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupCollectionType</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">          ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;</span><br><span class="line">          Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);</span><br><span class="line">          System.out.println(<span class="string">&quot;查找到的所有的User集合对象：&quot;</span> + users);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="层次性依赖查找"><a href="#层次性依赖查找" class="headerlink" title="层次性依赖查找"></a>层次性依赖查找</h2><p>层次性依赖查找接口-HierachicalBeanFactory</p>
<ol>
<li>双亲BeanFactory：getParentBeanFacotry</li>
<li>层次性查找：<ul>
<li>根据Bean名称查找<ul>
<li>基于containsLocalBean方法实现</li>
</ul>
</li>
<li>根据Bean类型查找实例列表<ul>
<li>单一类型：BeanFactoryUtils#beanOfType</li>
<li>集合类型BeanFactoryUtils#beanOfTypeIncludingAncestors</li>
</ul>
</li>
<li>根据Java注解查找名称列表<ul>
<li>BeanFactoryUtils#beanNamesForTypeIncludingAncestors</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="延迟依赖查找"><a href="#延迟依赖查找" class="headerlink" title="延迟依赖查找"></a>延迟依赖查找</h2><p>Bean延迟依赖查找接口</p>
<ol>
<li>org.springframework.beans.factory.ObjectFactory</li>
<li>org.springframwork.beans.factory.ObjecyProvider<ul>
<li>Spring 5 对Java8特性扩展<ul>
<li>函数式接口<ul>
<li>getIfAvailable(Supplier)</li>
<li>ifAvailable(Consumer)</li>
</ul>
</li>
<li>Stream扩展-stream()</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>相关示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObejctProviderDemo</span> </span>&#123; <span class="comment">// @Configuration是非必须的注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ObejctProviderDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        lookupByObejctProvider(applicationContext);</span><br><span class="line">        lookupIfAvailable(applicationContext);</span><br><span class="line">        lookupByStreamOps(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByStreamOps</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);</span><br><span class="line"><span class="comment">//        Iterable&lt;String&gt; stringIterable = beanProvider;</span></span><br><span class="line"><span class="comment">//        for (String string : stringIterable) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(string);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        beanProvider.stream().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupIfAvailable</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// User对象并不存在</span></span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectProvider = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        User user = userObjectProvider.getIfAvailable(User::createUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前User对象: &quot;</span> + user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloworld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookupByObejctProvider</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);</span><br><span class="line">        System.out.println(beanProvider.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安全依赖查找"><a href="#安全依赖查找" class="headerlink" title="安全依赖查找"></a>安全依赖查找</h2><p>安全性指的是没有查找到Bean的时候，是否会抛出异常。有关依赖查找安全性对比如下</p>
<table>
<thead>
<tr>
<th>依赖查找类型</th>
<th>代表实现</th>
<th>是否安全</th>
</tr>
</thead>
<tbody><tr>
<td>单一类型查找</td>
<td>BeanFactory#getBean</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td>ObjectFactory#getObject</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td>ObjectProvider#getIfAvailable</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td>是</td>
</tr>
<tr>
<td>集合类型查找</td>
<td>ListableBeanFactory#getBeansOfType</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td>ObjectProvider#stream</td>
<td>是</td>
</tr>
</tbody></table>
<p>注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的BeanFactory接口。</p>
<p>类型安全的依赖查找的相关示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型安全的依赖查找示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeSafetyDependencyLookupDemp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(TypeSafetyDependencyLookupDemp.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 演示BeanFactory#getBean方法的安全性</span></span><br><span class="line">        displayBeanFactoryGetBean(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ObjectFactory#getObject方法的安全性</span></span><br><span class="line">        displayBeanFactoryGetObject(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ObjectProvider#ifAvailable方法的安全性</span></span><br><span class="line">        displayObjectProviderIfAvailable(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ListableBeanFactory#getBeansOfTYpe方法的安全性</span></span><br><span class="line">        displayListableBeanFactoryGetBeansType(applicationContext);</span><br><span class="line">        <span class="comment">// 演示ObjectProvider#stream方法的安全性</span></span><br><span class="line">        displayObjectProviderStreamOps(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectProviderStreamOps</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; userObjectProvider = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        printBeansException(<span class="string">&quot;displayObjectProviderStreamOps&quot;</span>, () -&gt; userObjectProvider.stream().forEach(System.out::println));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayListableBeanFactoryGetBeansType</span><span class="params">(ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        printBeansException(<span class="string">&quot;displayListableBeanFactoryGetBeansType&quot;</span>,() -&gt; beanFactory.getBeanNamesForType(User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectProviderIfAvailable</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        ObjectProvider&lt;User&gt; objectProvider = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        printBeansException(<span class="string">&quot;displayObjectProviderIfAvailable&quot;</span>, objectProvider::getIfAvailable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayBeanFactoryGetObject</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ObjectProvider is ObjectFactory</span></span><br><span class="line">        ObjectFactory&lt;User&gt; userObjectFactory = applicationContext.getBeanProvider(User.class);</span><br><span class="line">        printBeansException(<span class="string">&quot;displayBeanFactoryGetObject&quot;</span>, userObjectFactory::getObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayBeanFactoryGetBean</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        printBeansException(<span class="string">&quot;displayBeanFactoryGetBean&quot;</span>, () -&gt; beanFactory.getBean(User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBeansException</span><span class="params">(String source, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Source from: &quot;</span> + source);</span><br><span class="line">        System.err.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException exception) &#123;</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内建可查找的依赖"><a href="#内建可查找的依赖" class="headerlink" title="内建可查找的依赖"></a>内建可查找的依赖</h2><p>AbastractApplicationContext内建可查找的依赖：</p>
<table>
<thead>
<tr>
<th>Bean名称</th>
<th>Bena实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>environment</td>
<td>Environment对象</td>
<td>外部化配置以及Profiles</td>
</tr>
<tr>
<td>systemProperties</td>
<td>java.util.Properties对象</td>
<td>Java系统属性</td>
</tr>
<tr>
<td>systemEnvironment</td>
<td>java.util.Map对象</td>
<td>操作系统环境变量</td>
</tr>
<tr>
<td>messageSource</td>
<td>MessageSource对象</td>
<td>国际化文案</td>
</tr>
<tr>
<td>lifecycleProcessor</td>
<td>lifecycleProcessor对象</td>
<td>Lifecycle Bean处理器</td>
</tr>
<tr>
<td>applicationEventMulticaster</td>
<td>ApplicationEventMulticaster对象</td>
<td>Spring事件广播器</td>
</tr>
</tbody></table>
<p>注解驱动Spring应用上下文内建可查找的依赖（部分）：</p>
<table>
<thead>
<tr>
<th>Bean名称</th>
<th>Bean实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>org.springframework.context.event.internalConfigurationAnnotationProcessor</td>
<td>ConfigurationClassPostProcessor对象</td>
<td>处理Spring配置类</td>
</tr>
<tr>
<td>org.springframework.context.event.internalAutowiredAnnotationProcessor</td>
<td>AutowiredAnnotationBeanPostProcessor对象</td>
<td>处理@Autowired以及@Value注解</td>
</tr>
<tr>
<td>org.springframework.context.event.internalCommonAnnotationProcessor</td>
<td>CommonAnnotationBeanPostProcessor对象</td>
<td>（条件激活）处理JSR-250注解，如@PostConstruct等</td>
</tr>
<tr>
<td>org.springframework.context.event.internalEventListenerProcessor</td>
<td>EventListenerMethodProcessor对象</td>
<td>处理标注@EventListener的Spring事件监听方法</td>
</tr>
<tr>
<td>org.springframework.context.event.internalListenerFactory</td>
<td>DefaultEventListenerFactory对象</td>
<td>@EventListener事件监听方法适配为ApplicationListener</td>
</tr>
<tr>
<td>org.springframework.context.event.internalPersistenceAnnotationProcessor</td>
<td>PersistenceAnnotationProcessor对象</td>
<td>条件激活处理JPA注解场景</td>
</tr>
</tbody></table>
<p>这些内建的Bean的初始化都是在AnnotationConfigUtils中完成的。</p>
<h2 id="依赖查找中典型异常"><a href="#依赖查找中典型异常" class="headerlink" title="依赖查找中典型异常"></a>依赖查找中典型异常</h2><p>BeansException子类型</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>触发条件（举例）</th>
<th>场景举例</th>
</tr>
</thead>
<tbody><tr>
<td>NoSuchBeanDefinitionException</td>
<td>当查找Bean不存在于IoC容器时</td>
<td>BeanFactory#getBean<br />ObjectFactory#getObject</td>
</tr>
<tr>
<td>NoUniqueBeanDefinitionException</td>
<td>类型查找时，IoC容器存在多个Bean实例</td>
<td>BeanFactory#getBean(Class)</td>
</tr>
<tr>
<td>BeanInstantiationException</td>
<td>当Bean所对应的类型非具体类时</td>
<td>BeanFactory#getBean</td>
</tr>
<tr>
<td>BeanCreationException</td>
<td>当Bean初始化过程中</td>
<td>Bean初始化方法执行异常时</td>
</tr>
<tr>
<td>BeanDefinitionStoreException</td>
<td>当BeanDefinition配置元信息非法时</td>
<td>XML配置资源无法打开时</td>
</tr>
</tbody></table>
<p>NoUniqueBeanDefinitionException示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NoUniqueBeanDefinitionException示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoUniqueBeanDefinitionExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(NoUniqueBeanDefinitionExceptionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            applicationContext.getBean(String.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoUniqueBeanDefinitionException e) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;Spring应用上下文存在%d 个 %s 类型的Bean,具体原因: %s%n&quot;</span>, e.getNumberOfBeansFound(),</span><br><span class="line">                    String.class.getName(), e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bean1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bean2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bean2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bean3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bean3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanInstantiationException示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanInstantiationException示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册BeanDefinition</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(CharSequence.class);</span><br><span class="line">        <span class="comment">// CharSequence是一个接口，所以实例化的时候会报错</span></span><br><span class="line">        applicationContext.registerBeanDefinition(<span class="string">&quot;errorBean&quot;</span>, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanCreationException示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanCreationException示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCreationExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 注册BeanDefinition</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(POJO.class);</span><br><span class="line">        applicationContext.registerBeanDefinition(<span class="string">&quot;errorBean&quot;</span>, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">POJO</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Throwable(<span class="string">&quot;init(): For purposers...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;afterPropertiesSet(): For purposes...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h2><h3 id="ObjectFactory与BeanFactory的区别"><a href="#ObjectFactory与BeanFactory的区别" class="headerlink" title="ObjectFactory与BeanFactory的区别"></a>ObjectFactory与BeanFactory的区别</h3><p>ObjectFactory与BeanFactory均提供依赖查找的能力，不过ObjectFactory仅关注一个或一种类型的Bean依赖查找，并且自身不具备依赖查找的能力，能力由BeanFactory输出。</p>
<p>BeanFactory则提供了单一类型、集合类型以及层次性等多种依赖查找方式。</p>
<h3 id="BeanFactory-getBean操作是否线程安全？"><a href="#BeanFactory-getBean操作是否线程安全？" class="headerlink" title="BeanFactory.getBean操作是否线程安全？"></a>BeanFactory.getBean操作是否线程安全？</h3><p>BeanFactory.getBean方法的执行是线程安全的，操作过程中会增加互斥锁。</p>
<h3 id="Spring的依赖查找和依赖注入在来源上有什么区别？"><a href="#Spring的依赖查找和依赖注入在来源上有什么区别？" class="headerlink" title="Spring的依赖查找和依赖注入在来源上有什么区别？"></a>Spring的依赖查找和依赖注入在来源上有什么区别？</h3><p>待定…</p>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h2 id="依赖注入的模式和类型"><a href="#依赖注入的模式和类型" class="headerlink" title="依赖注入的模式和类型"></a>依赖注入的模式和类型</h2><ol>
<li>手动模式-配置或者编程的方式，提前安排注入规则<ul>
<li>XML资源配置元信息</li>
<li>Java注解配置元信息</li>
<li>API配置元信息</li>
</ul>
</li>
<li>自动模式-实现方提供依赖自动关联的方式，按照内建的注入规则<ul>
<li>Autowring(自动绑定)</li>
</ul>
</li>
</ol>
<p>依赖注入类型：</p>
<table>
<thead>
<tr>
<th>依赖注入类型</th>
<th>配置元数据举例</th>
</tr>
</thead>
<tbody><tr>
<td>Setter方法</td>
<td><proepty name="user" ref="userBean" /></td>
</tr>
<tr>
<td>构造器</td>
<td><constructor-arg name="user" ref="userBean" /></td>
</tr>
<tr>
<td>字段</td>
<td>@Autowired<br />User user;</td>
</tr>
<tr>
<td>方法</td>
<td>@Autowired<br />public void user(User user) {…}</td>
</tr>
<tr>
<td>接口回调</td>
<td>class MyBean implements BeanFactoryAware{…}</td>
</tr>
</tbody></table>
<h2 id="自动绑定"><a href="#自动绑定" class="headerlink" title="自动绑定"></a>自动绑定</h2><p>Autowiring modes:</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>默认值，未激活Autowiring，需要手动指定依赖注入对象</td>
</tr>
<tr>
<td>byName</td>
<td>根据被注入属性的名称作为Bean名称进行依赖查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>byType</td>
<td>根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>constructor</td>
<td>特殊byType类型，用于构造器参数</td>
</tr>
</tbody></table>
<p>可以参考：org.springframework.beans.factory.annotation.Autowire。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Autowire</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Constant that indicates no autowiring at all.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NO(AutowireCapableBeanFactory.AUTOWIRE_NO),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Constant that indicates autowiring bean properties by name.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BY_NAME(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Constant that indicates autowiring bean properties by type.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BY_TYPE(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Autowire(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return whether this represents an actual autowiring value.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether actual autowiring was specified</span></span><br><span class="line"><span class="comment">	 * (either BY_NAME or BY_TYPE)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutowire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span> == BY_NAME || <span class="keyword">this</span> == BY_TYPE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动绑定的不足之处：</p>
<ol>
<li>构造器参数以及property上面的设置通常会覆盖掉Autowiring，也不能绑定一些简单的类型，比如String、Classes、properties</li>
<li>Autowiring无法把控注入的时候的精确性，会导致一些不确定的情况发生。</li>
<li>wiring很难在工具上产生一些文档或者相关提示。</li>
<li>如果应用上下文中存在多个Bean的定义，会发生歧义性，可能会抛出NoUniqueBeanDefinitionException。</li>
</ol>
<h2 id="Setter注入"><a href="#Setter注入" class="headerlink" title="Setter注入"></a>Setter注入</h2><p>Setter注入实现方法：</p>
<ol>
<li>手动模式：<ul>
<li>XML资源配置元信息</li>
<li>Java注解配置元信息</li>
<li>API配置元信息</li>
</ul>
</li>
<li>自动模式<ul>
<li>byName</li>
<li>byType</li>
</ul>
</li>
</ol>
<p>这里我们新建一个UserHolder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> User&#125; 的holder类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过XML的方式注入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;user&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过XML的方式注入演示的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于XML资源的依赖，Setter方法注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlDependencySetterInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/MTEA-INF/dependency-setter-injection.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 加载XML资源，解析并且生成BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        <span class="comment">//依赖查找并且创建Bean</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基于注解的依赖注入的演示示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于注解的Setter方法注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDependencySetterInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(AnnotationDependencySetterInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/MTEA-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line"></span><br><span class="line">        UserHolder userHolder = applicationContext.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        UserHolder userHolder = <span class="keyword">new</span> UserHolder();</span><br><span class="line">        userHolder.setUser(user);</span><br><span class="line">        <span class="keyword">return</span> userHolder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于Api的依赖注入的演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于API的Setter方法注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiDependencySetterInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        BeanDefinition userBeanDefinition = createUserBeanDefinition();</span><br><span class="line">        <span class="comment">// 注册UserHolder的BeanDefinition</span></span><br><span class="line">        applicationContext.registerBeanDefinition(<span class="string">&quot;UserHolder&quot;</span>,userBeanDefinition);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/MTEA-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line"></span><br><span class="line">        UserHolder userHolder = applicationContext.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为&#123;<span class="doctag">@link</span> UserHolder&#125; 生成&#123;<span class="doctag">@link</span> BeanDefinition&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">createUserBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(UserHolder.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyReference(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;SuperUser&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动配置的主要应用场景在XML文件当中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--这里可以通过byType或者byName进行注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--        &lt;property name=&quot;user&quot; ref=&quot;user&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><p>构造器注入的实现方法：</p>
<ol>
<li>手动模式<ul>
<li>XML资源配置元信息</li>
<li>Java注解配置元信息</li>
<li>API配置元信息</li>
</ul>
</li>
<li>自动模式<ul>
<li>constructor</li>
</ul>
</li>
</ol>
<p>XML资源配置的方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;SuperUser&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>XML资源配置方式的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于XML资源的依赖，构造器注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlDependencyConstructorInjectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-constructor-injection.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 加载XML资源，解析并且生成BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        <span class="comment">//依赖查找并且创建Bean</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(UserHolder.class);</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java注解方式的核心部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserHolder(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>API配置元信息的方式的核心部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为&#123;<span class="doctag">@link</span> UserHolder&#125; 生成&#123;<span class="doctag">@link</span> BeanDefinition&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">createUserBeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(UserHolder.class);</span><br><span class="line">    beanDefinitionBuilder.addConstructorArgReference(<span class="string">&quot;SuperUser&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器自动绑定的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.dependcy.injection.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h2><p>实现方法：</p>
<ol>
<li>手动模式<ul>
<li>@Autowird</li>
<li>@Resource</li>
<li>@inject（可选）</li>
</ul>
</li>
</ol>
<p>字段注入的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于注解的字段注入依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDependencyFiledInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="comment">//static @Autowired会忽略掉静态字段</span></span><br><span class="line">    UserHolder userHolder;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserHolder userHolder2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 配置Class也是 Spring Bean</span></span><br><span class="line">        applicationContext.register(AnnotationDependencyFiledInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line"></span><br><span class="line">        AnnotationDependencyFiledInjectionDemo demo = applicationContext.getBean(AnnotationDependencyFiledInjectionDemo.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Autowired字段关联</span></span><br><span class="line">        UserHolder userHolder = demo.userHolder;</span><br><span class="line">        <span class="comment">// @Resource</span></span><br><span class="line">        UserHolder userHolder2 = demo.userHolder2;</span><br><span class="line">        System.out.println(userHolder);</span><br><span class="line">        System.out.println(userHolder2);</span><br><span class="line"></span><br><span class="line">        System.out.println(userHolder == userHolder2);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserHolder(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h2><ol>
<li>手动模式<ul>
<li>@Autowird</li>
<li>@Resource</li>
<li>@inject（可选）</li>
<li>@Bean</li>
</ul>
</li>
</ol>
<p>方法注入的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserHolder userHolder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserHolder userHolder2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUserHolder</span><span class="params">(UserHolder userHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userHolder = userHolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initUserHolder2</span><span class="params">(UserHolder userHolder2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userHolder2 = userHolder2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserHolder <span class="title">userHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserHolder(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口回调注入"><a href="#接口回调注入" class="headerlink" title="接口回调注入"></a>接口回调注入</h2><p>Aware系列接口回调</p>
<ol>
<li><p>自动模式</p>
<table>
<thead>
<tr>
<th>内建接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BeanFactoryAware</td>
<td>获取IoC容器-BeanFactory</td>
</tr>
<tr>
<td>ApplicationContextAware</td>
<td>获取Spring应用上下文-ApplicationConetxt对象</td>
</tr>
<tr>
<td>EnvironmentAware</td>
<td>获取Environment对象</td>
</tr>
<tr>
<td>ResourceLoaderAware</td>
<td>获取资源加载器对象-ResourceLoader</td>
</tr>
<tr>
<td>BeanClassLoaderAware</td>
<td>获取加载当前Bean Class的ClassLoader</td>
</tr>
<tr>
<td>BeanNameAware</td>
<td>获取当前Bean名称</td>
</tr>
<tr>
<td>MessageSourceAware</td>
<td>获取MessageSource对象，用于Spring国际化</td>
</tr>
<tr>
<td>ApplicationEventPublisherAware</td>
<td>获取ApplicationEventPublishAware对象，用于Spring事件</td>
</tr>
<tr>
<td>EmbeddedValueResolverAware</td>
<td>获取StringValueResolver对象，用占位符处理</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>接口回调示例：</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于&#123;<span class="doctag">@link</span> org.springframework.beans.factory.Aware&#125; 接口回调的示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwareInterfaceDependencyInjectionDemo</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AwareInterfaceDependencyInjectionDemo.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        AwareInterfaceDependencyInjectionDemo.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AwareInterfaceDependencyInjectionDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(beanFactory == context.getBeanFactory());</span><br><span class="line">        System.out.println(applicationContext == context);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="依赖注入类型选择"><a href="#依赖注入类型选择" class="headerlink" title="依赖注入类型选择"></a>依赖注入类型选择</h2><p>注入选型</p>
<ol>
<li>低依赖：构造器注入</li>
<li>多以来：Setter方法注入</li>
<li>便利性：字段注入</li>
<li>声明类：方法注入</li>
</ol>
<h2 id="基础类型注入"><a href="#基础类型注入" class="headerlink" title="基础类型注入"></a>基础类型注入</h2><p>基础类型</p>
<ol>
<li>原生类型（Primitive）：boolean、byte、char、short、int、float、long、double</li>
<li>标量类型（Scalar）：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID</li>
<li>常规类型（General）：Object、String、TimeZone、Calendar、Optional等</li>
<li>Spring类型：Resource、InputSource、Formatter等。</li>
</ol>
<h2 id="集合类型注入"><a href="#集合类型注入" class="headerlink" title="集合类型注入"></a>集合类型注入</h2><p>集合类型</p>
<ol>
<li>数组类型（Array）：原生类型、标量类型、常规类型、Spring类型</li>
<li>集合类型（Collection）<ul>
<li>Collection：List、Set（SortedSet、NavigableSet、EnumSet）</li>
<li>Map：Properties</li>
</ul>
</li>
</ol>
<h2 id="限定注入"><a href="#限定注入" class="headerlink" title="限定注入"></a>限定注入</h2><ol>
<li>使用注解@Qualifier限定<ul>
<li>通过Bean名称限定</li>
<li>通过分组限定</li>
</ul>
</li>
<li>基于注解@Qualifier扩展限定<ul>
<li>自定义注解，如Spring Cloud @LoadBalanced</li>
</ul>
</li>
</ol>
<p>使用注解@Qualifer限定Bean的名称的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.annotation.Qualifier&#125; 使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// SuperUser -&gt; primary = true</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user&quot;)</span> <span class="comment">// 指定Bean名称或者ID</span></span><br><span class="line">    <span class="keyword">private</span> User namedUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.namedUser = &quot;</span> + demo.namedUser);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用@Qulifier对注入的Bean可以进行逻辑上的分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.annotation.Qualifier&#125; 使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// SuperUser -&gt; primary = true</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user&quot;)</span> <span class="comment">// 指定Bean名称或者ID</span></span><br><span class="line">    <span class="keyword">private</span> User namedUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; allUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; qualifierUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span> <span class="comment">// 进行逻辑分组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        <span class="comment">// 输出SuperUSer Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        <span class="comment">// 输出 user Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.namedUser = &quot;</span> + demo.namedUser);</span><br><span class="line">        <span class="comment">// 输出 SuperUSer、user,注意这里输出的不是所有的user对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.allUsers = &quot;</span> + demo.allUsers);</span><br><span class="line">        <span class="comment">// 输出 user1、user2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.qualifierUsers = &quot;</span> + demo.qualifierUsers);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注解的定义我们可以看到@Qualifier注解还可以作用到注解上面，也就是说可以对这个注解进行一些自定义的扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UserGroup &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义注解来进行分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.annotation.Qualifier&#125; 使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// SuperUser -&gt; primary = true</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;user&quot;)</span> <span class="comment">// 指定Bean名称或者ID</span></span><br><span class="line">    <span class="keyword">private</span> User namedUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; allUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; qualifierUsers;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@UserGroup</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;User&gt; groupedUsers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span> <span class="comment">// 进行逻辑分组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@UserGroup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@UserGroup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        QualifierAnnotationDependencyInjectionDemo demo = applicationContext.getBean(QualifierAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        <span class="comment">// 输出SuperUSer Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        <span class="comment">// 输出 user Bean</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.namedUser = &quot;</span> + demo.namedUser);</span><br><span class="line">        <span class="comment">// 输出 SuperUSer、user,注意这里输出的不是所有的user对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.allUsers = &quot;</span> + demo.allUsers);</span><br><span class="line">        <span class="comment">// 输出 user1、user2、user3和user4,这个时候这个集合元素也增加了,这种方式了类似继承</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.qualifierUsers = &quot;</span> + demo.qualifierUsers);</span><br><span class="line">        <span class="comment">// 输出 user3和user4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;demo.groupedUsers = &quot;</span> + demo.groupedUsers);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来查看以下@LoadBalanced注解的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoadBalanced &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟依赖注入"><a href="#延迟依赖注入" class="headerlink" title="延迟依赖注入"></a>延迟依赖注入</h2><ol>
<li>使用API ObjectFactory延迟注入<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
<li>使用API ObjectProvider延迟注入（推荐，这里主要是基于安全性的考量）<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
</ol>
<p>使用ObjectProvider延迟注入的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.ObjectProvider&#125; 实现延迟依赖注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyAnnotationDependencyInjectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;  <span class="comment">// 实时注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectProvider&lt;User&gt; userObjectProvider; <span class="comment">//延迟注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectProvider&lt;Set&lt;User&gt;&gt; usersObjectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(LazyAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        LazyAnnotationDependencyInjectionDemo demo = applicationContext.getBean(LazyAnnotationDependencyInjectionDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.userObjectProvider = &quot;</span> + demo.userObjectProvider);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.usersObjectFactory&quot;</span> + demo.usersObjectFactory);</span><br><span class="line">        demo.userObjectProvider.forEach(System.out::println);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖处理的过程"><a href="#依赖处理的过程" class="headerlink" title="依赖处理的过程"></a>依赖处理的过程</h2><p>基础知识：</p>
<ol>
<li>入口-DefaultListableBeanFactory#resolveDependency</li>
<li>依赖描述符-DependencyDescriptor</li>
<li>自定义绑定候选对象处理器-AutowireCandidateResolver</li>
</ol>
<p>首先观察以下依赖的描述类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyDescriptor</span> <span class="keyword">extends</span> <span class="title">InjectionPoint</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 被注入的容器类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; declaringClass;</span><br><span class="line">	<span class="comment">// 方法名称</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String methodName;</span><br><span class="line">	<span class="comment">// 构造器参数</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">	<span class="comment">// 参数索引</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> parameterIndex;</span><br><span class="line">	<span class="comment">// 属性名称</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> String fieldName;</span><br><span class="line">	<span class="comment">// 是不是必须的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> required;</span><br><span class="line">	<span class="comment">// 是不是饥饿的，@Lazy注解</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> eager;</span><br><span class="line">	<span class="comment">// 嵌入层次</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nestingLevel = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 包含类</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt; containingClass;</span><br><span class="line">	<span class="comment">// 泛型处理</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> ResolvableType resolvableType;</span><br><span class="line">	<span class="comment">// 类型描述</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> TypeDescriptor typeDescriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先改造以下我们之前看到的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解驱动的依赖注入过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDependencyInjectionResolutionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;  <span class="comment">// DependencyDescriptor -&gt;</span></span><br><span class="line">                        <span class="comment">// 必须（required=true）</span></span><br><span class="line">                        <span class="comment">// 实时注入（eager=true）</span></span><br><span class="line">                        <span class="comment">// 通过类型查找（User.class）</span></span><br><span class="line">                        <span class="comment">// 字段名称（“user”）</span></span><br><span class="line">                        <span class="comment">// 是否首要（primary=true）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(AnnotationDependencyInjectionResolutionDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(applicationContext);</span><br><span class="line">        String xmlResourcePath = <span class="string">&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(xmlResourcePath);</span><br><span class="line">        AnnotationDependencyInjectionResolutionDemo demo = applicationContext.getBean(AnnotationDependencyInjectionResolutionDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo.user = &quot;</span> + demo.user);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在DefaultListableBeanFactory#resolveDependency处打个断点进行观察：</p>
<p><img src="./assets/1622905372372.png" alt="1622905372372"></p>
<p>方法会继续往下执行到doResolveDependency方法：</p>
<p><img src="./assets/1622905643169.png" alt="1622905643169"></p>
<p>集合注入和单个类型的注入略微有点差别，首先我们增加一个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>          <span class="comment">// 集合类型的依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String,User&gt; users;  <span class="comment">// user SuperUser</span></span><br></pre></td></tr></table></figure>

<p>这个时候在返回的时候就会进行判断，判断返回的类型是什么，然后然后把结果放进去进行返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		Stream&lt;Object&gt; stream = matchingBeans.keySet().stream()</span><br><span class="line">				.map(name -&gt; descriptor.resolveCandidate(name, type, <span class="keyword">this</span>))</span><br><span class="line">				.filter(bean -&gt; !(bean <span class="keyword">instanceof</span> NullBean));</span><br><span class="line">		<span class="keyword">if</span> (((StreamDependencyDescriptor) descriptor).isOrdered()) &#123;</span><br><span class="line">			stream = stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stream;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">		Class&lt;?&gt; componentType = type.getComponentType();</span><br><span class="line">		ResolvableType resolvableType = descriptor.getResolvableType();</span><br><span class="line">		Class&lt;?&gt; resolvedArrayType = resolvableType.resolve(type);</span><br><span class="line">		<span class="keyword">if</span> (resolvedArrayType != type) &#123;</span><br><span class="line">			componentType = resolvableType.getComponentType().resolve();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (componentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, componentType,</span><br><span class="line">				<span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">		Object result = converter.convertIfNecessary(matchingBeans.values(), resolvedArrayType);</span><br><span class="line">		<span class="keyword">if</span> (result <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">			Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">			<span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Arrays.sort((Object[]) result, comparator);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;</span><br><span class="line">		Class&lt;?&gt; elementType = descriptor.getResolvableType().asCollection().resolveGeneric();</span><br><span class="line">		<span class="keyword">if</span> (elementType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, elementType,</span><br><span class="line">				<span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">		Object result = converter.convertIfNecessary(matchingBeans.values(), type);</span><br><span class="line">		<span class="keyword">if</span> (result <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">			<span class="keyword">if</span> (((List&lt;?&gt;) result).size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				Comparator&lt;Object&gt; comparator = adaptDependencyComparator(matchingBeans);</span><br><span class="line">				<span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">					((List&lt;?&gt;) result).sort(comparator);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">// Map类型</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">           <span class="comment">// 获取到users字段的Map的泛型信息</span></span><br><span class="line">		ResolvableType mapType = descriptor.getResolvableType().asMap();</span><br><span class="line">		Class&lt;?&gt; keyType = mapType.resolveGeneric(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (String.class != keyType) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; valueType = mapType.resolveGeneric(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (valueType == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, valueType,</span><br><span class="line">				<span class="keyword">new</span> MultiElementDescriptor(descriptor));</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.addAll(matchingBeans.keySet());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> matchingBeans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进行集合类型的注入时，定义Bean的顺序也就是加载Bean的顺序，也是初始化Bean的时候的顺序。</p>
<p>在Java8之后，也可以注入Optional类型的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Optional&lt;User&gt; userOptional;</span><br></pre></td></tr></table></figure>

<p>当注入的类型时延迟查找时，实际上会返回一个代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Lazy</span></span><br><span class="line">   <span class="keyword">private</span> User lazyUser;</span><br></pre></td></tr></table></figure>

<p>总的来说，依赖注入的处理主要就是由以下两个方法来完成的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String requestingBeanName,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">       <span class="comment">// 对于Optional类型的判断</span></span><br><span class="line">	<span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">		<span class="keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">			ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">				descriptor, requestingBeanName);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">			result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> shortcut;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">		Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				String strVal = resolveEmbeddedValue((String) value);</span><br><span class="line">				BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; containsBean(beanName) ?</span><br><span class="line">						getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">				value = evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">			&#125;</span><br><span class="line">			TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : getTypeConverter());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (UnsupportedOperationException ex) &#123;</span><br><span class="line">				<span class="comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span></span><br><span class="line">				<span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">						converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">						converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">		<span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> multipleBeans;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">				raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String autowiredBeanName;</span><br><span class="line">		Object instanceCandidate;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">			<span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line">					<span class="keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line">					<span class="comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line">					<span class="comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// We have exactly one match.</span></span><br><span class="line">			Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">			autowiredBeanName = entry.getKey();</span><br><span class="line">			instanceCandidate = entry.getValue();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">			autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instanceCandidate <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">			instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Object result = instanceCandidate;</span><br><span class="line">		<span class="keyword">if</span> (result <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">				raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">			&#125;</span><br><span class="line">			result = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Autowird注入"><a href="#Autowird注入" class="headerlink" title="@Autowird注入"></a>@Autowird注入</h2><p>@Autowired注入总体过程：</p>
<ol>
<li>元信息解析</li>
<li>依赖查找</li>
<li>依赖注入（字段、方法）</li>
</ol>
<p>核心处理方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">             <span class="comment">// 标注了@Autowired注解的字段</span></span><br><span class="line">			Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">			Object value;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					value = resolvedCachedArgument(beanName, <span class="keyword">this</span>.cachedFieldValue);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">					<span class="comment">// Unexpected removal of target bean for cached argument -&gt; re-resolve</span></span><br><span class="line">					value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				value = resolveFieldValue(field, bean, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 有可能时非public字段</span></span><br><span class="line">				ReflectionUtils.makeAccessible(field);</span><br><span class="line">                 <span class="comment">// 最终通过反射的方式将依赖注入的对象设置到属性上</span></span><br><span class="line">				field.set(bean, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>在XML中配置信息解析的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		metadata.inject(bean, beanName, pvs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会在set方法执行之前就执行，并且这个时候还没有进行类型转换。当这个类有父类的时候，会进行属性合并的操作，并且是在postProcessProperties之前执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">		InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">		metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>一直会找到所有父类中的属性的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">	MergedAnnotations annotations = MergedAnnotations.from(ao);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; type : <span class="keyword">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">		MergedAnnotation&lt;?&gt; annotation = annotations.get(type);</span><br><span class="line">		<span class="keyword">if</span> (annotation.isPresent()) &#123;</span><br><span class="line">			<span class="keyword">return</span> annotation;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上述方法的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">			MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">			<span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 可以看到就是在这里排除掉了static的字段</span></span><br><span class="line">				<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">						logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">				currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到在postProcessMergedBeanDefinition就完成了Bean的元信息的组装，并且在postProcessProperties执行的时候会包含调用DefaultListableBeanFactory#resolveDependency方法的过程。</p>
<h2 id="Inject和-Autowired联系"><a href="#Inject和-Autowired联系" class="headerlink" title="@Inject和@Autowired联系"></a>@Inject和@Autowired联系</h2><p>@Inject注入过程</p>
<ul>
<li>如果JSR-330存在于ClassPath中，就直接复用AutowiredAnnotationBeanPostProcessor的实现。</li>
</ul>
<p>在源代码中可以看到相关的逻辑：</p>
<p>这里首先要关注一个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到autowiredAnnotationTypes实际上是一个有序的Set集合，接下来是具体处理的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 依次插入Autowired、Value、inject</span></span><br><span class="line">	<span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">	<span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">				ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">		logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		<span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到实际上还可以进行复合注解，并且在处理的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">	MergedAnnotations annotations = MergedAnnotations.from(ao);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; type : <span class="keyword">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">		MergedAnnotation&lt;?&gt; annotation = annotations.get(type);</span><br><span class="line">		<span class="keyword">if</span> (annotation.isPresent()) &#123;</span><br><span class="line">			<span class="keyword">return</span> annotation;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果要使用@Inject注解，就需要引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以发现@Inject和@Autowired注解在处理的上完全一样的，都是使用AutowiredAnnotationBeanPostProcessor来处理依赖注入的过程。</p>
<h2 id="Java通用注解原理"><a href="#Java通用注解原理" class="headerlink" title="Java通用注解原理"></a>Java通用注解原理</h2><p>CommonAnnotationBeanPostProcessor</p>
<ol>
<li>注入注解<ul>
<li>javax.xml.ws.WebServiceRef</li>
<li>javax.ejb.EJB</li>
<li>javax.annotation.Resource</li>
</ul>
</li>
<li>生命周期注解<ul>
<li>javax.annotation.PostConstruct</li>
<li>javax.annotation.PreDestory</li>
</ul>
</li>
</ol>
<p>CommonAnnotationBeanPostProcessor和AutowiredAnnotationBeanPostProcessor大概的实现逻辑是如出一辙的，只是在细微的地方略有差别。</p>
<p>CommonAnnotationBeanPostProcessor实现了InitDestroyAnnotationBeanPostProcessor接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InitDestroyAnnotationBeanPostProcessor</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>在InitDestroyAnnotationBeanPostProcessor中也可以看到postProcessMergedBeanDefinition这个方法：</p>
<p><img src="./assets/1622945426099.png" alt="1622945426099"></p>
<p>这里只是元信息不太一样，这主要是LifecycleMetadata中包含了初始化和销毁两个阶段。</p>
<p>同样CommonAnnotationBeanPostProcessor也有postProcessProperties的方法：</p>
<p><img src="./assets/1622945839012.png" alt="1622945839012"></p>
<p>对于生命周期的注解的处理，可以从构造方法中看出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 优先级是倒数第四位的</span></span><br><span class="line">		setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>);</span><br><span class="line">		setInitAnnotationType(PostConstruct.class);</span><br><span class="line">		setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">		ignoreResourceType(<span class="string">&quot;javax.xml.ws.WebServiceContext&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>CommonAnnotationBeanPostProcessor会在AutowiredAnnotationBeanPostProcessor之前进行处理，这一点，可以通过实现的PriorityOrdered接口，看到属性中定义的顺序来进行确认。</p>
<h2 id="自定义依赖注入注解"><a href="#自定义依赖注入注解" class="headerlink" title="自定义依赖注入注解"></a>自定义依赖注入注解</h2><ol>
<li>基于AutowiredAnnotationBeanPostProcessor实现</li>
<li>自定义实现<ul>
<li>生命周期处理<ul>
<li>InstantiationAwareBeanPostProcessor</li>
<li>MergedBeanDefinitionPostProcessor</li>
</ul>
</li>
<li>元数据<ul>
<li>InjectedElement</li>
<li>InjectionMetadata</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>基于AutowiredAnnotationBeanPostProcessor实现自定义依赖注入相对比较容易，如果使用自定义实现，就比较麻烦。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAutowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们不对@Autowired做任何的扩展，仅仅使用它进行元标注，定义完成之后使用MyAutowired进行注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAutowired</span></span><br><span class="line">  <span class="keyword">private</span> Optional&lt;User&gt; userOptional;</span><br></pre></td></tr></table></figure>

<p>发现依然可以正常地工作，接下来我们自定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义依赖注入注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectedUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将我们自定义的注解类型添加到AutowiredAnnotationBeanPostProcessor中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean(name = AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)</span> <span class="comment">//注意这里是static方法，会提前初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AutowiredAnnotationBeanPostProcessor <span class="title">beanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AutowiredAnnotationBeanPostProcessor beanPostProcessor = <span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor();</span><br><span class="line">        <span class="comment">// 替换原有注解处理，使用新注解@InjectedUser，原来的注解会失效</span></span><br><span class="line"><span class="comment">//        beanPostProcessor.setAutowiredAnnotationType(InjectedUser.class);</span></span><br><span class="line">        <span class="comment">// 保留原来的方式，添加新的注解，@Autowired + @InjectedUser</span></span><br><span class="line">        Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(Autowired.class, Inject.class, InjectedUser.class));</span><br><span class="line">        beanPostProcessor.setAutowiredAnnotationTypes(autowiredAnnotationTypes);</span><br><span class="line">        <span class="keyword">return</span> beanPostProcessor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试我们的注解是否生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InjectedUser</span></span><br><span class="line">  <span class="keyword">private</span> User myInjectedUser;</span><br></pre></td></tr></table></figure>

<p>答案是肯定的。如何实现新老注解的兼容的注入方法呢？</p>
<p>首先注入一个AutowiredAnnotationBeanPostProcessor，并设置我们自定义的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@Order(Ordered.LOWEST_PRECEDENCE - 3)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AutowiredAnnotationBeanPostProcessor <span class="title">beanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       AutowiredAnnotationBeanPostProcessor beanPostProcessor = <span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor();</span><br><span class="line">       beanPostProcessor.setAutowiredAnnotationType(InjectedUser.class);</span><br><span class="line">       <span class="keyword">return</span> beanPostProcessor;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    在AnnotationConfigUtils#registerAnnotationConfigProcessors中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果AutowiredAnnotationBeanPostProcessor这个Bean存在的话，就不注册，不存在的会注册一个默认的，因为我们这里注入AutowiredAnnotationBeanPostProcessor采用的static，就会首先使用我们注册的AutowiredAnnotationBeanPostProcessor来进行依赖注入，这时候，在应用上下文中有两个AutowiredAnnotationBeanPostProcessor来进行处理。</p>
<h2 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h2><h3 id="有多少种依赖注入的方式"><a href="#有多少种依赖注入的方式" class="headerlink" title="有多少种依赖注入的方式"></a>有多少种依赖注入的方式</h3><p>构造器注入、Setter注入、字段注入、方法注入、接口回调注入</p>
<h3 id="你偏好构造器注入还是Setter注入"><a href="#你偏好构造器注入还是Setter注入" class="headerlink" title="你偏好构造器注入还是Setter注入?"></a>你偏好构造器注入还是Setter注入?</h3><p>两种依赖注入的方式均可以使用，如果是必须依赖的话，那么推荐使用构造器注入，Setter注入用于可选依赖。</p>
<h3 id="Spring依赖注入的来源有哪些？"><a href="#Spring依赖注入的来源有哪些？" class="headerlink" title="Spring依赖注入的来源有哪些？"></a>Spring依赖注入的来源有哪些？</h3><p>待续…</p>
<h1 id="Spring-IoC依赖来源"><a href="#Spring-IoC依赖来源" class="headerlink" title="Spring IoC依赖来源"></a>Spring IoC依赖来源</h1><h2 id="依赖查找的来源"><a href="#依赖查找的来源" class="headerlink" title="依赖查找的来源"></a>依赖查找的来源</h2><p>查找来源：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody><tr>
<td>Spring BeanDefinition</td>
<td><code>&lt;bean id=&quot;user&quot; class=&quot;org...User&quot;&gt;</code></td>
</tr>
<tr>
<td></td>
<td>@Bean<br />public User user(){…}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API实现</td>
</tr>
</tbody></table>
<h2 id="依赖注入的来源"><a href="#依赖注入的来源" class="headerlink" title="依赖注入的来源"></a>依赖注入的来源</h2><p>注入来源：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody><tr>
<td>Spring BeanDefinition</td>
<td><code>&lt;bean id=&quot;user&quot; class=&quot;org...User&quot;&gt;</code></td>
</tr>
<tr>
<td></td>
<td>@Bean<br />public User user(){…}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API实现</td>
</tr>
<tr>
<td>非Spring容器管理对象（游离对象）</td>
<td></td>
</tr>
</tbody></table>
<p>AbstractApplicationContext#refresh()方法会调用prepareBeanFactory(beanFactory)方法，这个方法中会注入一些Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line"><span class="comment">// 注意接下来的都是当前ApplicationContext对象</span></span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>实际上，注入了四个类型，两个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依赖来源示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入在postProcessProperties方法执行，早于setter注入，也早于PostConstruct</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanFactory == applicationContext: &quot;</span> + (beanFactory == applicationContext));</span><br><span class="line">        System.out.println(<span class="string">&quot;beanFactory == applicationContext.getBeanFactory: &quot;</span> + (beanFactory == applicationContext.getAutowireCapableBeanFactory()));</span><br><span class="line">        System.out.println(<span class="string">&quot;resourceLoader == applicationContext: &quot;</span> + (resourceLoader == applicationContext));</span><br><span class="line">        System.out.println(<span class="string">&quot;applicationEventMulticaster == applicationContext: &quot;</span> + (applicationEventPublisher == applicationContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initByLookup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getBean(BeanFactory.class);</span><br><span class="line">        getBean(ResourceLoader.class);</span><br><span class="line">        getBean(ApplicationContext.class);</span><br><span class="line">        getBean(ApplicationEventPublisher.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> beanFactory.getBean(beanType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;当前类型&quot;</span> + beanType.getName() + <span class="string">&quot;无法在BeanFactory中查找&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(DependencySourceDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">        DependencySourceDemo demo = applicationContext.getBean(DependencySourceDemo.class);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring容器管理和游离对象"><a href="#Spring容器管理和游离对象" class="headerlink" title="Spring容器管理和游离对象"></a>Spring容器管理和游离对象</h2><p>依赖对象：</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>Spring Bean对象</th>
<th>生命周期管理</th>
<th>配置元信息</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Spring BeanDefinition</td>
<td>是</td>
<td>是</td>
<td>有</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>单体对象</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>Resolvable Dependency</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>依赖注入</td>
</tr>
</tbody></table>
<h2 id="Spring-BeanDefinition作为依赖来源"><a href="#Spring-BeanDefinition作为依赖来源" class="headerlink" title="Spring BeanDefinition作为依赖来源"></a>Spring BeanDefinition作为依赖来源</h2><p>要素：</p>
<ol>
<li>元数据：BeanDefinition</li>
<li>注册：BeanDefinitionRegistry#registerBeanDefinition</li>
<li>类型：延迟和非延迟</li>
<li>顺序：Bean生命周期顺序按照注册顺序</li>
</ol>
<p>BeanDefinitionRegistry有且仅有一个实现，就是DefaultListableBeanFactory，首先有这样两个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map of bean definition objects, keyed by bean name</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment">// List of bean definition names, in registration order.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<p>在registerBeanDefinition方法中会这样保存数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br></pre></td></tr></table></figure>

<p>可以看到这里除了保存beanName和beanDefinition，还单独保存了beanName，这样做的原因就是ConcurrentHashMap是无序的，而ArrayList是有序的，后面在初始化的时候，会根据这个List里面的Bean的名称，按照次序依次进行初始化操作。</p>
<h2 id="单体对象作为依赖来源"><a href="#单体对象作为依赖来源" class="headerlink" title="单体对象作为依赖来源"></a>单体对象作为依赖来源</h2><p>要素：</p>
<ol>
<li>来源：外部普通Java对象（不一定是POJO）</li>
<li>注册：SingletonBeanRegistry#registerSinleton</li>
</ol>
<p>限制：</p>
<ol>
<li>无生命周期管理</li>
<li>无法实现延迟初始化Bean</li>
</ol>
<h2 id="Resolvable-Dependency作为依赖来源"><a href="#Resolvable-Dependency作为依赖来源" class="headerlink" title="Resolvable Dependency作为依赖来源"></a>Resolvable Dependency作为依赖来源</h2><p>要素：</p>
<ul>
<li>注册：ConfigurableListableBeanFactory#registerResolvableDependency</li>
</ul>
<p>限制：</p>
<ol>
<li>无生命周期管理</li>
<li>无法延迟初始化Bean</li>
<li>无法通过依赖查找</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResolvableDependency作为依赖来源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolvableDependencySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ResolvableDependencySourceDemo.class);</span><br><span class="line">        <span class="comment">// 只能用于类型方面的依赖注入</span></span><br><span class="line">        applicationContext.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;</span><br><span class="line">            beanFactory.registerResolvableDependency(String.class,<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外部化配置作为依赖来源"><a href="#外部化配置作为依赖来源" class="headerlink" title="外部化配置作为依赖来源"></a>外部化配置作为依赖来源</h2><p>要素：</p>
<ul>
<li>类型：非常规Spring对象依赖来源</li>
</ul>
<p>限制：</p>
<ol>
<li>无生命周期管理</li>
<li>无法实现延迟初始化Bean</li>
<li>无法通过依赖查找</li>
</ol>
<p>外部化配置的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部化配置作为依赖来源示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;META-INF/default.properties&quot;,encoding = &quot;GBK&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalConfigurationDependencySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.resource&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是中文，这里会显示操作系统登录的用户名，而不是在配置文件中配置的信息。这是因为user.name是一个系统属性。</span></span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;user.name&#125;&quot;)</span></span><br><span class="line"><span class="comment">//    private String name;</span></span><br><span class="line">    <span class="comment">// 直接输出会显示乱码,需要设置编码</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;usr.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ExternalConfigurationDependencySourceDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        ExternalConfigurationDependencySourceDemo demo = applicationContext.getBean(ExternalConfigurationDependencySourceDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + demo.id);</span><br><span class="line">        System.out.println(<span class="string">&quot;resource: &quot;</span> + demo.resource);</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + demo.name);</span><br><span class="line"></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理就是DefaultListableBeanFactory#doResolveDependency中：</p>
<p><img src="./assets/1622979982114.png" alt="1622979982114"></p>
<p>会通过接下来的方法进行替换，将属性替换为配置文件中的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strVal = resolveEmbeddedValue((String) value);</span><br></pre></td></tr></table></figure>

<h2 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h2><h3 id="依赖注入和依赖查找的依赖来源是否相同？"><a href="#依赖注入和依赖查找的依赖来源是否相同？" class="headerlink" title="依赖注入和依赖查找的依赖来源是否相同？"></a>依赖注入和依赖查找的依赖来源是否相同？</h3><p>否，依赖查找的来源仅限于Spring BeanDefinition以及单例对象，而依赖注入的来源还包括了Resolvable Dependency以及@Value所标注的外部化配置。</p>
<h3 id="单例对象能在IoC容器启动后注册吗？"><a href="#单例对象能在IoC容器启动后注册吗？" class="headerlink" title="单例对象能在IoC容器启动后注册吗？"></a>单例对象能在IoC容器启动后注册吗？</h3><p>可以的，单例对象注册与BeanDefinition不同，BeanDefinition会被ConfigurableListableBeanFactory#freezeConfiguration()方法影响，从而冻结注册，单例对象则没有这个限制。</p>
<h3 id="Spring依赖注入的来源有哪些？-1"><a href="#Spring依赖注入的来源有哪些？-1" class="headerlink" title="Spring依赖注入的来源有哪些？"></a>Spring依赖注入的来源有哪些？</h3><p>Spring BeanDefinition、单例对象、Resolvable Dependency、@Value外部化配置</p>
<h1 id="Spring-Bean作用域"><a href="#Spring-Bean作用域" class="headerlink" title="Spring Bean作用域"></a>Spring Bean作用域</h1><h2 id="作用域简介"><a href="#作用域简介" class="headerlink" title="作用域简介"></a>作用域简介</h2><table>
<thead>
<tr>
<th>来源</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>默认Spring Bean作用域，一个BeanFactory有且仅有一个实例</td>
</tr>
<tr>
<td>prototype</td>
<td>原型作用域，每次依赖查找和依赖注入生成新Bean对象</td>
</tr>
<tr>
<td>request</td>
<td>将Spring Bean存储在ServletRequest上下文中</td>
</tr>
<tr>
<td>session</td>
<td>将Spring Bean存储在HttpSession中</td>
</tr>
<tr>
<td>application</td>
<td>将Spring Bean存储在ServletContext中</td>
</tr>
</tbody></table>
<p>笼统而言，我们只要记住单例和原型两种即可，其余三种主要是为了服务端模板引擎渲染，包括JSP、Velocity、FreeMarker。</p>
<h2 id="singleton作用域"><a href="#singleton作用域" class="headerlink" title="singleton作用域"></a>singleton作用域</h2><p>单例模式是在一定范围内是全局共享的，但是这个范围是有限的。通过观察BeanDefinition源代码可以发现，其实只有singleton和prototype这两个作用域相关的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否是单例</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 是否是原型</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>单例模式的示例图：</p>
<p><img src="./assets/20141217143318093.png" alt="img"></p>
<p>这里有一个误区就是，singleton和prototype并没有互斥的关系，是可以同时存在的，当然，如果同时存在的话，可能行为会有一些问题。</p>
<h2 id="prototype作用域"><a href="#prototype作用域" class="headerlink" title="prototype作用域"></a>prototype作用域</h2><p>多例模式的示意图：</p>
<p><img src="./assets/20141217143404577.png" alt="img"></p>
<p>多例和单例比较的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bean的作用域示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanScopeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 默认的scop就是“singleton”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">singletonUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">prototypeUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(String.valueOf(System.nanoTime()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,User&gt; users;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scopedBeansByInjection</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        BeanScopeDemo beanScopeDemo = applicationContext.getBean(BeanScopeDemo.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.singletonUser = &quot;</span> + beanScopeDemo.singletonUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.singletonUser1 = &quot;</span> + beanScopeDemo.singletonUser1);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.prototypeUser1 = &quot;</span> + beanScopeDemo.prototypeUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.prototypeUser2 = &quot;</span> + beanScopeDemo.prototypeUser1);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.prototypeUser3 = &quot;</span> + beanScopeDemo.prototypeUser2);</span><br><span class="line">        System.out.println(<span class="string">&quot;beanScopeDemo.users = &quot;</span> + beanScopeDemo.users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scopedBeansByLookup</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            User singletonUser = applicationContext.getBean(<span class="string">&quot;singletonUser&quot;</span>, User.class);</span><br><span class="line">            <span class="comment">// singletonUser是共享的Bean对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;singletonUser = &quot;</span> + singletonUser.getId());</span><br><span class="line">            <span class="comment">// prototypeUser是每次依赖查找都会生成新的Bean对象</span></span><br><span class="line">            User prototypeUser = applicationContext.getBean(<span class="string">&quot;prototypeUser&quot;</span>, User.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;prototypeUser = &quot;</span> + prototypeUser.getId());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanScopeDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 结论一：</span></span><br><span class="line">        <span class="comment">// singleton Bean无论依赖查找还是依赖注入均为同一个对象</span></span><br><span class="line">        <span class="comment">// prototype Bean无论依赖查找还是依赖注入均为新生成的对象</span></span><br><span class="line">        <span class="comment">// 结论二：</span></span><br><span class="line">        <span class="comment">// 如果依赖注入集合类型的对象，singleton Bean和prototype Bean均会存在一个</span></span><br><span class="line">        <span class="comment">// prototype Bean有别于其他地方的依赖注入</span></span><br><span class="line">        scopedBeansByLookup(applicationContext);</span><br><span class="line">        scopedBeansByInjection(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>Spring容器没有办法管理prototype Bean的完整生命周期，也没有办法记录实例的存在。销毁回调方法将不会执行，可以利用BeanPostProcess进行清扫工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;createUser&quot;</span>);</span><br><span class="line">        user.setId(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User Bean [&quot;</span> + beanName + <span class="string">&quot;]初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User Bean [&quot;</span> + beanName + <span class="string">&quot;]销毁化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行刚才的例子不难看出，初始化的方法每次还是会被调用，但是销毁方法只有单例的Bean才会调用，那么如何销毁prototype的Bean呢？一种做法就是前面提到的BeanPostProcess：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">applicationContext.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Bean名称: %s 在初始化后回调...%n&quot;</span>, bean.getClass().getName(), beanName);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个方法里面可以执行一些销毁的逻辑，但是使用这种方式，可能会有一些意想不到的结果，因为创建好的prototype的Bean通常而言都是马上要使用的，而不需要在它上面增加一些额外的操作，更为推荐的方式，是在维护prototype的Bean的类中，利用它的生命周期方法，对于所管理的prototype类型的类进行销毁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanScopeDemo</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 默认的scop就是“singleton”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">singletonUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">prototypeUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(String.valueOf(System.nanoTime()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;singletonUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User singletonUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;prototypeUser&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User prototypeUser2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(BeanScopeDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前BeanScopeDemo Bean 正在销毁中&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.prototypeUser.destory();</span><br><span class="line">        <span class="keyword">this</span>.prototypeUser1.destory();</span><br><span class="line">        <span class="keyword">this</span>.prototypeUser2.destory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : <span class="keyword">this</span>.users.entrySet()) &#123;</span><br><span class="line">            String beanName = entry.getKey();</span><br><span class="line">            BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition.isPrototype()) &#123;</span><br><span class="line">                User user = entry.getValue();</span><br><span class="line">                user.destory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前BeanScopeDemo Bean 销毁已完成...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="request作用域"><a href="#request作用域" class="headerlink" title="request作用域"></a>request作用域</h2><ol>
<li>配置<ul>
<li>XML - <code>&lt;bean class=&quot;...&quot; scope=&quot;request&quot;&gt;</code></li>
<li>Java注解 - @RequestScope或@Scope（WebApplicationContext.SCOPE_REQUEST）</li>
</ul>
</li>
<li>实现<ul>
<li>API - RequestScope</li>
</ul>
</li>
</ol>
<h2 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session作用域</h2><ol>
<li>配置<ul>
<li>XML - <code>&lt;bean class=&quot;...&quot; scope=&quot;session&quot;&gt;</code></li>
<li>Java注解 - @SessionScope或@Scope（WebApplicationContext.SCOPE_SESSION）</li>
</ul>
</li>
<li>实现<ul>
<li>API - SessionScope</li>
</ul>
</li>
</ol>
<p>request作用域的对象，每次请求都会返回一个新的对象，并且对象会经历初始化和销毁两个过程，而session作用域，在同一个cookie的情况下，每次返回的都是同一个对象，这个时候对象只会经历初始化的过程，而不会对Bean进行销毁。无论是request还是session，返回的对象都是经过cglib代理的对象。</p>
<h2 id="application作用域"><a href="#application作用域" class="headerlink" title="application作用域"></a>application作用域</h2><ol>
<li>配置<ul>
<li>XML - <code>&lt;bean class=&quot;...&quot; scope=&quot;application&quot;&gt;</code></li>
<li>Java注解 - @ApplicationScope或@Scope（WebApplicationContext.APPLICATION）</li>
</ul>
</li>
<li>实现<ul>
<li>API - ApplicationScope</li>
</ul>
</li>
</ol>
<p>application作用域的Bean可以在ServletContext中直接获取到。一个JavaWeb应用只创建一个ServletContext对象，应用在启动的时候创建ServletContext对象，在服务器关闭的时候销毁，使用ServletContext获取到的Bean对象也是经过cglib代理的对象，Bean的名称为<code>scopedTarget.beanName</code></p>
<h2 id="自定义Bean作用域"><a href="#自定义Bean作用域" class="headerlink" title="自定义Bean作用域"></a>自定义Bean作用域</h2><ol>
<li><p>实现Scope</p>
<ul>
<li>org.springframework.beans.factory.config.Scope</li>
</ul>
</li>
<li><p>注册Scope</p>
<ul>
<li><p>API - org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope</p>
</li>
<li><p>配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;scopes&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>自定义作用的相关示例，首先进行定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCOP_NAME = <span class="string">&quot;thread-local&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NamedThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = <span class="keyword">new</span> NamedThreadLocal(<span class="string">&quot;thread-local-scope&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空</span></span><br><span class="line">        Map&lt;String, Object&gt; context = getContext();</span><br><span class="line">        Object object = context.get(name);</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            object = objectFactory.getObject();</span><br><span class="line">            context.put(name, object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; context = getContext();</span><br><span class="line">        <span class="keyword">return</span> context.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveContextualObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; context = getContext();</span><br><span class="line">        <span class="keyword">return</span> context.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConversationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(thread.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进行注册并且测试是否成功：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScopeDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(ThreadLocalScope.SCOP_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(String.valueOf(System.nanoTime()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(ThreadLocalScopeDemo.class);</span><br><span class="line">        applicationContext.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;</span><br><span class="line">                    beanFactory.registerScope(ThreadLocalScope.SCOP_NAME, <span class="keyword">new</span> ThreadLocalScope());</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        scopedBeansByLookup(applicationContext);</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scopedBeansByLookup</span><span class="params">(AnnotationConfigApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单个线程下，返回的永远是同一个Bean</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line"><span class="comment">//            User user = applicationContext.getBean(&quot;user&quot;, User.class);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;user = &quot; + user.getId());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                User user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">                System.out.printf(<span class="string">&quot;[Thread id: %d] user = %s%n&quot;</span>, Thread.currentThread().getId(), user);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">            <span class="comment">// 强制线程执行完成</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-7"><a href="#面试题-7" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring内建的Bean的作用域有几种？"><a href="#Spring内建的Bean的作用域有几种？" class="headerlink" title="Spring内建的Bean的作用域有几种？"></a>Spring内建的Bean的作用域有几种？</h3><p>sington、prototype、request、session、application以及websocket</p>
<h3 id="singleton-Bean是否在一个应用中是唯一的？"><a href="#singleton-Bean是否在一个应用中是唯一的？" class="headerlink" title="singleton Bean是否在一个应用中是唯一的？"></a>singleton Bean是否在一个应用中是唯一的？</h3><p>否，singleton bean仅在当前Spring IoC容器（BeanFactory）中是单例对象。</p>
<h3 id="“application”-Bean是否被其他方案他替代？"><a href="#“application”-Bean是否被其他方案他替代？" class="headerlink" title="“application” Bean是否被其他方案他替代？"></a>“application” Bean是否被其他方案他替代？</h3><p>可以的，实际上，”application” Bean与”singleton” Bean没有本质区别。</p>
<h1 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h1><h2 id="元信息配置阶段"><a href="#元信息配置阶段" class="headerlink" title="元信息配置阶段"></a>元信息配置阶段</h2><p>BeanDefinition的配置方式：</p>
<ol>
<li>面向资源<ul>
<li>XML配置</li>
<li>Properties资源配置</li>
</ul>
</li>
<li>面向注解</li>
<li>面向API</li>
</ol>
<p>这里除了Properties资源配置我们没有见到过外，其他的都有相关的示例。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意这里必须这么写，不能写user.class</span></span><br><span class="line"><span class="meta">user.(class)</span> = <span class="string">org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User</span></span><br><span class="line"><span class="meta">user.id</span> = <span class="string">001</span></span><br><span class="line"><span class="meta">user.name</span> = <span class="string">吉永超</span></span><br><span class="line"><span class="meta">user.city</span> = <span class="string">HANGZHOU</span></span><br></pre></td></tr></table></figure>

<p>相关的演示示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMetadataConfigurationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 实例化PropertiesBeanDefinitionReader</span></span><br><span class="line">        PropertiesBeanDefinitionReader propertiesBeanDefinitionReader = <span class="keyword">new</span> PropertiesBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;classpath:/META-INF/user.properties&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = propertiesBeanDefinitionReader.loadBeanDefinitions(location);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 通过Bean ID和类型进行依赖查找</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元信息解析阶段"><a href="#元信息解析阶段" class="headerlink" title="元信息解析阶段"></a>元信息解析阶段</h2><p>主要分为两种：</p>
<ol>
<li>面向资源BeanDefinition解析<ul>
<li>BeanDefinitionReader</li>
<li>XML解析器 - BeanDefinitionParser</li>
</ul>
</li>
<li>面向注解BeanDefinition解析<ul>
<li>AnnotatedBeanDefinitionReader</li>
</ul>
</li>
</ol>
<p>面向资源的情况我们在之前也有过相关的讨论，这里只介绍面向注解的BeanDefinition解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedBeanDefinitionParsingDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 基于Java 注解的 AnnotatedBeanDefinitionReader的实现</span></span><br><span class="line">        AnnotatedBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(beanFactory);</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCountBefore = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">// 注册当前类（非Componenet Class）</span></span><br><span class="line">        beanDefinitionReader.registerBean(AnnotatedBeanDefinitionParsingDemo.class);</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCountAfter = beanFactory.getBeanDefinitionCount();</span><br><span class="line">        <span class="keyword">int</span> beanDefinitionCount = beanDefinitionCountAfter - beanDefinitionCountBefore;</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanDefinitionCount);</span><br><span class="line">        <span class="comment">// 普通Class作为Component注册到Spring IoC容器后，通常Bean的名称为类名的首字母小写（annotatedBeanDefinitionParsingDemo）</span></span><br><span class="line">        <span class="comment">// Bean名称生成来自于BeanNameGenerator，注解实现AnnotationBeanNameGenerator</span></span><br><span class="line">        AnnotatedBeanDefinitionParsingDemo demo = beanFactory.getBean(<span class="string">&quot;annotatedBeanDefinitionParsingDemo&quot;</span>, AnnotatedBeanDefinitionParsingDemo.class);</span><br><span class="line">        System.out.println(demo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认生成Bean的名称的部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">	String beanClassName = definition.getBeanClassName();</span><br><span class="line">	Assert.state(beanClassName != <span class="keyword">null</span>, <span class="string">&quot;No bean class name set&quot;</span>);</span><br><span class="line">	String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line">	<span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注册阶段"><a href="#注册阶段" class="headerlink" title="注册阶段"></a>注册阶段</h2><p>BeanDefinition注册的核心接口：BeanDefinitionRegistry，它有且仅有一个实现类就是DefaultListableBeanFactory。DefaultListableBeanFactory#registerBeanDefinition的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">		Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    	<span class="comment">// 当已经存在BeanDefinition的时候</span></span><br><span class="line">		<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 允许Bean重复注册</span></span><br><span class="line">			<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">				<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">				<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">							existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">							<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">							<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 注册一个新的BeanDefinition</span></span><br><span class="line">			<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">				<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                      <span class="comment">// 这里的beanDefinitionMap的类型是Map&lt;String, BeanDefinition&gt;,key就是Bean的名称，value就是对应的BeanDefinition</span></span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                      <span class="comment">// 这里之所以还要维护一个beanDefinitionNames是为了记住注册时候的Bean的顺序。</span></span><br><span class="line">					List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">					updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">					updatedDefinitions.add(beanName);</span><br><span class="line">					<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">					removeManualSingletonName(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Still in startup registration phase</span></span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">			resetBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">			clearByTypeCache();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanDefinition合并阶段"><a href="#BeanDefinition合并阶段" class="headerlink" title="BeanDefinition合并阶段"></a>BeanDefinition合并阶段</h2><p>BeanDefinition合并：</p>
<ol>
<li>父子BeanDefinition合并<ul>
<li>当前BeanFactory查找</li>
<li>层次性BeanFactory查找</li>
</ul>
</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergedBeanDefinitionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(location);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(encodedResource);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	String beanName = transformedBeanName(name);</span><br><span class="line">	<span class="comment">// Efficiently check whether bean definition exists in this factory.</span></span><br><span class="line">	<span class="keyword">if</span> (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((ConfigurableBeanFactory) getParentBeanFactory()).getMergedBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Resolve merged bean definition locally.</span></span><br><span class="line">       <span class="comment">// 当前的BeanFactory</span></span><br><span class="line">	<span class="keyword">return</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">		RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line">		RootBeanDefinition previous = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line">		<span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || mbd.stale) &#123;</span><br><span class="line">			previous = mbd;</span><br><span class="line">			<span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line">				<span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">					mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">				BeanDefinition pbd;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line">					<span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">						pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						BeanFactory parent = getParentBeanFactory();</span><br><span class="line">						<span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">							pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line">									<span class="string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +</span><br><span class="line">											<span class="string">&quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Deep copy with overridden values.</span></span><br><span class="line">				mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line">				mbd.overrideFrom(bd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">			<span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">				mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line">			<span class="comment">// Let&#x27;s correct this on the fly here, since this might be the result of</span></span><br><span class="line">			<span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line">			<span class="comment">// definition will not have inherited the merged outer bean&#x27;s singleton status.</span></span><br><span class="line">			<span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">				mbd.setScope(containingBd.getScope());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line">			<span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line">			<span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">			copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mbd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bean-Class加载阶段"><a href="#Bean-Class加载阶段" class="headerlink" title="Bean Class加载阶段"></a>Bean Class加载阶段</h2><ol>
<li>ClassLoader类加载</li>
<li>Java Security安全控制</li>
<li>ConfigurableBeanFactory临时ClassLoader（场景比较有限）</li>
</ol>
<p>加载的核心代码代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; resolveBeanClass(<span class="meta">@Nullable</span> ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">	String className = getBeanClassName();</span><br><span class="line">	<span class="keyword">if</span> (className == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt; resolvedClass = ClassUtils.forName(className, classLoader);</span><br><span class="line">	<span class="keyword">this</span>.beanClass = resolvedClass;</span><br><span class="line">	<span class="keyword">return</span> resolvedClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最开始的beanClass实际上是一个String类型，然后通过AppClassLoader加载到Class对象并赋值给beanClass这个属性，这个属性本身是一个Object类型的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Object beanClass;</span><br></pre></td></tr></table></figure>

<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h3 id="实例化前阶段"><a href="#实例化前阶段" class="headerlink" title="实例化前阶段"></a>实例化前阶段</h3><p>非主流生命周期-Bena实例化前阶段</p>
<ul>
<li>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</li>
</ul>
<p>首先我们给出这个接口的使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 添加BeanPostProcesssor实现</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>;</span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(location);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(encodedResource);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;SuperUser&quot;</span>,beanName) &amp;&amp; SuperUser.class.equals(beanClass)) &#123;</span><br><span class="line">                <span class="comment">// 把配置好的SuperUser Bean覆盖</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SuperUser();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 保持Spring IoC容器的实例化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码分析，可以看到postProcessBeforeInstantiation方法被调用之后返回了这个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">			Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">			<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用关系，不难看出，在实例化Bean的时候，如果上述的方法返回的不是一个空对象，就直接返回，不在进行实例化的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例化阶段"><a href="#实例化阶段" class="headerlink" title="实例化阶段"></a>实例化阶段</h3><p>Spring中实例化方式：</p>
<ol>
<li>传统实例化方式<ul>
<li>实例化策略 - InstantiationStrategy</li>
</ul>
</li>
<li>构造器注入</li>
</ol>
<p>传统的方式可以在AbstractAutowireCapableBeanFactory#instantiateBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>构造器注入，我们可以构造一个例子来进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在之前的例子上稍作修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 添加BeanPostProcesssor实现</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>,<span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;SuperUser&quot;</span>,beanName) &amp;&amp; SuperUser.class.equals(beanClass)) &#123;</span><br><span class="line">                <span class="comment">// 把配置好的SuperUser Bean覆盖</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SuperUser();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 保持Spring IoC容器的实例化操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以总结一下，Bean的实例化主要有两种类型，并且使用构造器注入的时候，是按照类型来进行注入的，底层是使用的我们在依赖注入章节中介绍过的resolveDependency方法来实现的。</p>
<h3 id="Bean实例化后阶段"><a href="#Bean实例化后阶段" class="headerlink" title="Bean实例化后阶段"></a>Bean实例化后阶段</h3><p>对于Spring Bean实例化后阶段，我们可以理解为是Bean属性赋值（Populate）的判断：InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation。可以结合Bean实例化前阶段一起对照查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;SuperUser&quot;</span>, beanName) &amp;&amp; SuperUser.class.equals(beanClass)) &#123;</span><br><span class="line">              <span class="comment">// 把配置好的SuperUser Bean覆盖</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> SuperUser();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 保持Spring IoC容器的实例化操作</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;user&quot;</span>, beanName) &amp;&amp; User.class.equals(bean.getClass())) &#123;</span><br><span class="line">              User user = (User) bean;</span><br><span class="line">              user.setId(<span class="string">&quot;33&quot;</span>);</span><br><span class="line">              user.setName(<span class="string">&quot;jjjjjj&quot;</span>);</span><br><span class="line">              <span class="comment">// &quot;user&quot;对象不允许属性赋值（填入）（配置元信息 -&gt; 属性值）</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里相当于可以拦截掉所有的属性赋值，并且可以进行一些自定义的赋值，此时Bean的实例化已经完成了，但是属性赋值还没进行。</p>
<h2 id="属性赋值前阶段"><a href="#属性赋值前阶段" class="headerlink" title="属性赋值前阶段"></a>属性赋值前阶段</h2><p>Bean属性值信息的类：</p>
<ul>
<li>PropertyValues</li>
</ul>
<p>Bean属性赋值前回调</p>
<ul>
<li>Spring1.2-5.0：InstantiationAwareBeanPostProcessor#postProcessPropertyValues</li>
<li>Spring 5.1：InstantiationAwareBeanPostProcessor#postProcessProperties</li>
</ul>
<p>他们都是在BeanFactory赋值之前的回调操作，PropertyValues就是从配置文件里面读入的值，这个方法的作用就是可以修改从配置文件里面读入的值，默认情况下不做任何修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，这里的返回值是null。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>还在在我们之前的例子上稍作修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">// 要注意如果postProcessAfterInstantiation返回的是false的话，这个方法不会被调用，因为相当于返回的Bean已经被替换了。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">                <span class="comment">// 假设&lt;property name=&quot;number&quot; value=&quot;1&quot; /&gt;配置的话，那么在PropertyValues中就包含一个PropertyValues(number=1)</span></span><br><span class="line">                <span class="keyword">final</span> MutablePropertyValues propertyValues;</span><br><span class="line">                <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">                    propertyValues = (MutablePropertyValues) pvs;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等价于&lt;property name=&quot;number&quot; value=&quot;1&quot; /&gt;</span></span><br><span class="line">                propertyValues.addPropertyValue(<span class="string">&quot;number&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (propertyValues.contains(<span class="string">&quot;description&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// PropertyValue是不可变的</span></span><br><span class="line"><span class="comment">//                    PropertyValue description = propertyValues.getPropertyValue(&quot;description&quot;);</span></span><br><span class="line">                    propertyValues.removePropertyValue(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">                    propertyValues.addPropertyValue(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;The user holder V2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> propertyValues;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们演示了两种情况，一种是number这个属性本来是没有值的，通过这个Api的拦截，我们手动给他赋上了值，而description这个属性，是我们在XML文件中，定义好了属性值，从结果来看，这个属性值也成功的被修改了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userHolder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.lifecycle.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;number&quot; value=&quot;1&quot;/&gt;--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">value</span>=<span class="string">&quot;The user holder&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改后的UserHolder类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&quot;, number=&quot;</span> + number +</span><br><span class="line">                <span class="string">&quot;, description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的源码：</p>
<p><img src="./SpringFramework.assets/image-20210614105732908.png" alt="image-20210614105732908"></p>
<p>最后将准备好的pvs对象赋值给BeanWrapper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">	applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="接口回调阶段"><a href="#接口回调阶段" class="headerlink" title="接口回调阶段"></a>接口回调阶段</h3><p>Spring Aware接口：</p>
<ul>
<li>BeanNameAware</li>
<li>BeanClassLoaderAware</li>
<li>BeanFactoryAware</li>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ResourceLoaderAware</li>
<li>ApplicationEventPublisherAware</li>
<li>MessageSourceAware</li>
<li>ApplicationContextAware</li>
</ul>
<blockquote>
<p>这里列出的顺序同时也是调用时候的顺序，这一点，源代码中也有体现：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">				ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">				<span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">					((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>另外一些相关的方法在ApplicationContextAwareProcessor#invokeAwareInterfaces：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">			((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">			((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">			((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationStartupAware) &#123;</span><br><span class="line">			((ApplicationStartupAware) bean).setApplicationStartup(<span class="keyword">this</span>.applicationContext.getApplicationStartup());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">			((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>但是第二部分的回调接口无法通过BeanFacotry的方式得到回调，我们需要对之前的代码进行一定的重构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInstantiationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        executeBeanFactory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        executApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册</span></span><br><span class="line"><span class="comment">//        beanFactory.addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor());</span></span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext();</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        applicationContext.setConfigLocations(locations);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        User user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        SuperUser superUser = applicationContext.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        UserHolder userHolder = applicationContext.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在XML文件中，注入MyInstantiationAwareBeanPostProcessor：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.lifecycle.MyInstantiationAwareBeanPostProcessor&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以在UserHolder中实现这些接口，进行观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHolder</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserHolder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;user=&quot;</span> + user +</span><br><span class="line">                <span class="string">&quot;, number=&quot;</span> + number +</span><br><span class="line">                <span class="string">&quot;, description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, beanName=&#x27;&quot;</span> + beanName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserHolder</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现，通过BeanFacotry的方式，无法获取到EnvironmentAware对象的回调，而ApplicationContext则可以，这是因为在AbstractApplicationContext#prepareBeanFactory中，BeanFactory注册了ApplicationContextAwareProcessor这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>

<p>而我们前面提到过，第二部分的接口的回调，需要执行ApplicationContextAwareProcessor#invokeAwareInterfaces方法，而ApplicationContextAwareProcessor又是一个非public的类，因此，在我们创建的BeanFactory无法操作这个类。总来的来说，通过BeanFactory可以获取到BeanNameAware、BeanClassLoaderAware、BeanFactoryAware这三个接口的回调，而如果使用AppliactionContext来进行操作，就可以获取到更多的回调，这也从另一个角度说明了AppliacitonContext和BeanFactory的区别。</p>
<h3 id="初始化前阶段"><a href="#初始化前阶段" class="headerlink" title="初始化前阶段"></a>初始化前阶段</h3><p>方法回调：</p>
<ul>
<li>BeanPostProcessor#postProcessBeforeInitialization</li>
</ul>
<p>因为InstantiationAwareBeanPostProcessor继承了BeanPostProcessor，因此我们还是调整MyInstantiationAwareBeanPostProcessor的方法来进行观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">           UserHolder userHolder = (UserHolder) bean;</span><br><span class="line">           userHolder.setDescription(<span class="string">&quot;The user holder V3&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> userHolder;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>为了跟前面加以区别，这里我们增加一个调用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanInitilzationLifecycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        executeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到userHolder的description属性成功的变成了v3，相关的源码的实现在AbstractAutowireCapableBeanFactory#pplyBeanPostProcessorsBeforeInitialization：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">            <span class="comment">// 可能返回的是一个代理对象，并不是原有的对象</span></span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>在之前，我们有提到过Bean初始化操作：</p>
<ul>
<li>@PostConstruct标注方法</li>
<li>实现InitializingBean接口的afterPropertiesSet()方法</li>
<li>自定义初始化方法</li>
</ul>
<blockquote>
<p>@PostConstruct标注方法需要注解驱动，因为这种方式需要依赖于ApplicationContext的，并且所依赖的ApplicationContext是需要有注解驱动能力的。</p>
</blockquote>
<p>我们在UserHolder中添加它的初始化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 依赖于注解驱动，当前场景：BeanFactory，因此直接运行，并不会执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostConstruct</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPostConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V4&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;initPostConstruct() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V5&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;afterPropertiesSet() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V6&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;init() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里因为我们是BeanFactory的场景，因此需要手动添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> CommonAnnotationBeanPostProcessor());</span><br></pre></td></tr></table></figure>

<p>相应的源码在AbstractAutowireCapableBeanFactory#invokeInitMethods方法当中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// afterPropertiesSet方法：</span></span><br><span class="line">		<span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">		<span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">					<span class="keyword">throw</span> pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自定义初始化方法</span></span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">			String initMethodName = mbd.getInitMethodName();</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">					!(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">					!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">				invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化后阶段"><a href="#初始化后阶段" class="headerlink" title="初始化后阶段"></a>初始化后阶段</h3><p>方法的回调：</p>
<ul>
<li>BeanPostProcessor#postProcessAfterInitialization</li>
</ul>
<p>还是对我们的MyInstantiationAwareBeanPostProcessor进行添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">          UserHolder userHolder = (UserHolder) bean;</span><br><span class="line">          userHolder.setDescription(<span class="string">&quot;The user holder V7&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> userHolder;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，关于Bean的初始化操作，总共可以分为下面几个阶段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;, getAccessControlContext());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 接口回调</span></span><br><span class="line">		invokeAwareMethods(beanName, bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object wrappedBean = bean;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">           <span class="comment">// 初始化前方法</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 初始化方法</span></span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">				beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">           <span class="comment">// 初始化后方法</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化完成阶段"><a href="#初始化完成阶段" class="headerlink" title="初始化完成阶段"></a>初始化完成阶段</h3><p>方法回调：</p>
<ul>
<li>SmartInitializingSingleton#afterSingletonsInstantiated</li>
</ul>
<p> 同样的，还是操作Userholder类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V8&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;afterSingletonsInstantiated() = &quot;</span> + description);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>直接去运行，发现并没有打印出我们预期的结果，这是因为这个方法调用的地方在DefaultListableBeanFactory#preInstantiateSingletons，而这个方法需要显示的调用才会执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SmartInitializingSingleton 通常在Spring AppliactionContext场景使用</span></span><br><span class="line"><span class="comment">// preInstantiateSingletons将已注册的BeanDefinition初始化成Spring Bean</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>

<p>在AbstractApplicationContext#finishBeanFactoryInitialization方法中，我们可以看到这里就调用了preInstantiateSingletons方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>提供这个方法的主要原因是之前的BeanPostProcessor接口提供的回调，可能Bean会存在初始化不完全的情况，使用这个方法的时候就不用担心有Bean初始化不完全的情况发生。</p>
<h2 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h2><h3 id="销毁前阶段"><a href="#销毁前阶段" class="headerlink" title="销毁前阶段"></a>销毁前阶段</h3><p>方法回调：</p>
<ul>
<li>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</li>
</ul>
<p>实现一下这个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDestructionAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">DestructionAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;userHolder&quot;</span>, beanName) &amp;&amp; UserHolder.class.equals(bean.getClass())) &#123;</span><br><span class="line">            UserHolder userHolder = (UserHolder) bean;</span><br><span class="line">            userHolder.setDescription(<span class="string">&quot;The user holder V9&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Bean生命周期的完整的演示示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLifeCycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        <span class="comment">// 方法一：添加BeanPostProcesssor实现InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="comment">// 方法二：将MyInstantiationAwareBeanPostProcessor作为Bean注册</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> CommonAnnotationBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 添加MyDestructionAwareBeanPostProcessor执行销毁前回调</span></span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> MyDestructionAwareBeanPostProcessor());</span><br><span class="line">        <span class="comment">// 基于XML资源BeanDefinitionReader 实现</span></span><br><span class="line">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        String[] locations = &#123;<span class="string">&quot;META-INF/dependency-lookup-context.xml&quot;</span>, <span class="string">&quot;META-INF/bean-constructor-dependency-injection.xml&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> beanNumbers = xmlBeanDefinitionReader.loadBeanDefinitions(locations);</span><br><span class="line">        System.out.println(<span class="string">&quot;已加载的BeanDefinitiond的数量：&quot;</span> + beanNumbers);</span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">        <span class="comment">// 不需要合并BeanDefinition</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="comment">// 需要合并BeanDefinition</span></span><br><span class="line">        SuperUser superUser = beanFactory.getBean(<span class="string">&quot;SuperUser&quot;</span>, SuperUser.class);</span><br><span class="line">        System.out.println(superUser.toString());</span><br><span class="line">        <span class="comment">// 构造器注入式按照类型注入，底层resolveDependency</span></span><br><span class="line">        UserHolder userHolder = beanFactory.getBean(<span class="string">&quot;userHolder&quot;</span>, UserHolder.class);</span><br><span class="line">        <span class="comment">// SmartInitializingSingleton 通常在Spring AppliactionContext场景使用</span></span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line"></span><br><span class="line">        beanFactory.destroyBean(<span class="string">&quot;userHolder&quot;</span>, userHolder);</span><br><span class="line">        <span class="comment">// Bean销毁并不意味这Bean垃圾回收了</span></span><br><span class="line">        System.out.println(userHolder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别需要注意的是，这里的销毁并不是这个对象被GC掉了，GC和Bean的销毁是两个不同的概念。</p>
</blockquote>
<h3 id="销毁阶段-1"><a href="#销毁阶段-1" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p>Bean销毁（Destory）：</p>
<ul>
<li>@PreDestory标注方法</li>
<li>实现DisposableBean接口的destory()方法</li>
<li>自定义销毁方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V10&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;PreDestroy() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V11&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;PreDestroy() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.description = <span class="string">&quot;The user holder V12&quot;</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;PreDestroy() = &quot;</span> + description);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在XML中指定自定义的销毁方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userHolder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.bean.lifecycle.UserHolder&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;doDestory&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;number&quot; value=&quot;1&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">value</span>=<span class="string">&quot;The user holder&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在BeanFactory场景下还是需要手动进行调用，而在ApplicationContext中，是会自动调用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.destroyBean(<span class="string">&quot;userHolder&quot;</span>, userHolder);</span><br></pre></td></tr></table></figure>

<h2 id="Bean垃圾收集"><a href="#Bean垃圾收集" class="headerlink" title="Bean垃圾收集"></a>Bean垃圾收集</h2><p>Bean垃圾回收（GC）的过程：</p>
<ol>
<li>关闭Spring容器（应用上下文）</li>
<li>执行GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ol>
<p>首先在UserHolder中重写finalize()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;UserHolder is finalized ...&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行销毁方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁BeanFactory中的单例Bean</span></span><br><span class="line">   beanFactory.destroySingletons();</span><br><span class="line">   <span class="comment">// 强制GC</span></span><br><span class="line">   System.gc();</span><br><span class="line">   <span class="comment">// 等待一段时间</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException exception) &#123;</span><br><span class="line">       exception.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   System.gc();</span><br></pre></td></tr></table></figure>

<h2 id="面试题-8"><a href="#面试题-8" class="headerlink" title="面试题"></a>面试题</h2><h3 id="BeanPostProcess使用场景有哪些？"><a href="#BeanPostProcess使用场景有哪些？" class="headerlink" title="BeanPostProcess使用场景有哪些？"></a>BeanPostProcess使用场景有哪些？</h3><p>BeanPostProcess提供了Spring Bean初始化前和初始化后的生命周期回调，分别对应postProcessBeforeInitialization以及postProcessAfterInitialization方法，允许对关心的Bean进行扩展，甚至是替换，</p>
<p>其中ApplicationContext相关的Aware回调也是基于BeanPostProcess实现，即ApplicationContextAwareProcessor。</p>
<h3 id="BeanFactoryPostProcess与BeanPostProcess的区别"><a href="#BeanFactoryPostProcess与BeanPostProcess的区别" class="headerlink" title="BeanFactoryPostProcess与BeanPostProcess的区别"></a>BeanFactoryPostProcess与BeanPostProcess的区别</h3><p>BeanFactroyPostProcessor是Spring BeanFacrtory（实际为ConfigurableListableBeanFactory）的后置处理器，用于扩展BeanFacotry，或通过BeanFactory进行依赖查找和依赖注入。</p>
<p>BeanFactroyPostProcessor必须有Spring ApplicationContext执行，BeanFactory无法与其直接交互。而BeanPostProcess直接与BeanFactory关联，属于N对1的关系。</p>
<h3 id="BeanFactory是怎样处理Bean生命周期？"><a href="#BeanFactory是怎样处理Bean生命周期？" class="headerlink" title="BeanFactory是怎样处理Bean生命周期？"></a>BeanFactory是怎样处理Bean生命周期？</h3><p>BeanFactory的默认实现为DefaultListableBeanFactory，其中Bean生命周期与方法映射如下：</p>
<ul>
<li>BeanDefinition注册阶段 - regsiterBeanDefinition</li>
<li>BeanDefinition合并阶段 - getMergedBeanDefinition</li>
<li>Bean实例化前阶段 - resolveBeforeInstantiation</li>
<li>Bean实例化阶段 - createBeanInstance</li>
<li>Bean实例化后阶段- populateBean</li>
<li>Bean属性赋值前阶段 - populateBean</li>
<li>Bean属性赋值阶段 - populateBean</li>
<li>Bean Aware接口回调阶段 - initializeBean</li>
<li>Bean初始化前阶段- initializeBean</li>
<li>Bean初始化阶段- initializeBean</li>
<li>Bean初始化后阶段- initializeBean</li>
<li>Bean初始化完成阶段 - preInstantiateSingtons</li>
<li>Bean销毁前阶段- destoryBean</li>
<li>Bean销毁阶段 - destoryBean</li>
</ul>
<h1 id="Spring-配置元信息"><a href="#Spring-配置元信息" class="headerlink" title="Spring 配置元信息"></a>Spring 配置元信息</h1><p>配置元信息主要可以分为以下五个方面：</p>
<ol>
<li>Spring Bean配置元信息 - BeanDefinition</li>
<li>Spring Bean属性元信息 - PropertyValues</li>
<li>Spring 容器配置元信息</li>
<li>Spring 外部化配置元信息 - PropertySource</li>
<li>Spring Profile 元信息 - @Profile</li>
</ol>
<h2 id="Spring-Bean配置元信息"><a href="#Spring-Bean配置元信息" class="headerlink" title="Spring Bean配置元信息"></a>Spring Bean配置元信息</h2><p>Bean的配置元信息 - BeanDefinition主要包括了：</p>
<ul>
<li>GenericBeanDefinition：通用型BeanDefinition</li>
<li>RootBeanDefinition：无parent的BeanDefinition或者合并后BeanDefinition</li>
<li>AnnotatedBeanDefinition：注解标注的BeanDefinition</li>
</ul>
<blockquote>
<p>AnnotatedBeanDefinition中的AnnotationMetadata有两种具体的实现，StandardAnnotationMetadata是基于Java注解实现的，SimpleAnnotationMetadata是基于ASM实现的。</p>
</blockquote>
<h2 id="Spring-Bean属性元信息"><a href="#Spring-Bean属性元信息" class="headerlink" title="Spring Bean属性元信息"></a>Spring Bean属性元信息</h2><ol>
<li>Bean属性元信息 - PropertyValues<ul>
<li>可修改实现 - MutablePropertyValues</li>
<li>元素成员 - PropertyValue</li>
</ul>
</li>
<li>Bean属性上下文存储 - AttributeAccessor</li>
<li>Bean元信息元素 - BeanMetadataElement</li>
</ol>
<p>其中第一种我们已经见过很多次了，这里主要演示第二种和第三种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfigurationMetadataDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BeanDefinition 的定义（声明）</span></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jycoder&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取AbstractBeanDefinition</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 声明BeanDefinition</span></span><br><span class="line">        <span class="comment">// 附件属性(不影响Bean 实例化、属性赋值、初始化)</span></span><br><span class="line">        beanDefinition.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jiyongchao&quot;</span>);</span><br><span class="line">        <span class="comment">// 当前BeanDefinition来自何方,也是起存储的作用</span></span><br><span class="line">        beanDefinition.setSource(BeanConfigurationMetadataDemo.class);</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ObjectUtils.nullSafeEquals(<span class="string">&quot;user&quot;</span>, beanName) &amp;&amp; User.class.equals(bean.getClass())) &#123;</span><br><span class="line">                    BeanDefinition bd = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (BeanConfigurationMetadataDemo.class.equals(bd.getSource())) &#123; <span class="comment">// 通过source来判断</span></span><br><span class="line">                        <span class="comment">// TODO</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 属性（存储）上下文</span></span><br><span class="line">                    String name = (String) bd.getAttribute(<span class="string">&quot;jiyongchao&quot;</span>); <span class="comment">// 这里的name就是jiyongchao</span></span><br><span class="line">                    User user = (User) bean;</span><br><span class="line">                    user.setName(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring容器配置元信息"><a href="#Spring容器配置元信息" class="headerlink" title="Spring容器配置元信息"></a>Spring容器配置元信息</h2><p>Spring XML配置元信息 - Beans元素相关</p>
<table>
<thead>
<tr>
<th>Beans元素属性</th>
<th>默认直</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>profile</td>
<td>null（留空）</td>
<td>Spring Profiles配置值</td>
</tr>
<tr>
<td>default-lazt-init</td>
<td>default</td>
<td>当outter beans “default-lazy-init”属性存在时，继承该值，否则为”false”</td>
</tr>
<tr>
<td>default-merge</td>
<td>default</td>
<td>当outter beans “default-merge”属性存在时，继承该值，否则为”false”</td>
</tr>
<tr>
<td>default-autowire</td>
<td>default</td>
<td>当outter beans “default-autowire”属性存在时，继承该值，否则为”false”</td>
</tr>
<tr>
<td>default-autowire-candidates</td>
<td>null（留空）</td>
<td>默认Spring Beans 名称pattern</td>
</tr>
<tr>
<td>default-init-method</td>
<td>null（留空）</td>
<td>默认Spring Beans 自定义初始化方法</td>
</tr>
<tr>
<td>default-destory-method</td>
<td>null（留空）</td>
<td>默认Spring Beans 自定义销毁方法</td>
</tr>
</tbody></table>
<blockquote>
<p>outter beans指的是在XML文件中通过import导入资源的方法注册Bean，导入方就是外部，被导入方就是内部。</p>
</blockquote>
<p>Spring XML配置元信息 - 应用上下文</p>
<table>
<thead>
<tr>
<th>XML元素</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;context:annotation-config /&gt;</td>
<td>激活Spring注解驱动</td>
</tr>
<tr>
<td>&lt;context:componenet-scan /&gt;</td>
<td>Spring@Component以及自定义注解扫描</td>
</tr>
<tr>
<td>&lt;context:load-time-weaver /&gt;</td>
<td>激活Spring LoadTimeWeaver</td>
</tr>
<tr>
<td>&lt;context:mbean-export /&gt;</td>
<td>暴露Spring Beans作为JMX Beans</td>
</tr>
<tr>
<td>&lt;context:mbean-server /&gt;</td>
<td>将当前平台作为MBeanServer</td>
</tr>
<tr>
<td>&lt;context:property-placeholder /&gt;</td>
<td>加载外部化配置资源作为Spring属性配置</td>
</tr>
<tr>
<td>&lt;context:property-override /&gt;</td>
<td>利用外部化配置资源覆盖Spring属性值</td>
</tr>
</tbody></table>
<blockquote>
<p>mbean：Java Management Extensions</p>
</blockquote>
<p>关于Beans的元素相关的配置可以在<code>BeanDefinitionParserDelegate#populateDefaults</code>中看到。</p>
<h2 id="基于XML资源装载Spring-Bean配置元信息"><a href="#基于XML资源装载Spring-Bean配置元信息" class="headerlink" title="基于XML资源装载Spring Bean配置元信息"></a>基于XML资源装载Spring Bean配置元信息</h2><p>Spring Bean配置元信息</p>
<table>
<thead>
<tr>
<th>XML元素</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;beans:beans /&gt;</td>
<td>单XML资源下的多个Spring Beans配置</td>
</tr>
<tr>
<td>&lt;beans:bean /&gt;</td>
<td>单个Spring Bean定义（BeanDefinition）配置</td>
</tr>
<tr>
<td>&lt;beans:alias /&gt;</td>
<td>为Spring Bean定义（BeanDefinition）映射别名</td>
</tr>
<tr>
<td>&lt;beans:import /&gt;</td>
<td>加载外部Spring XML配置资源</td>
</tr>
</tbody></table>
<blockquote>
<p>通常情况下我们会使用默认的namespace，这里使用beans来更加明确的说明，这里的底层实现都是XmlBeanDefinitionReader。</p>
</blockquote>
<p>装在的核心方法在XmlBeanDefinitionReader#registerBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">		<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">		<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于Properties资源装载Spring-Bean配置元信息"><a href="#基于Properties资源装载Spring-Bean配置元信息" class="headerlink" title="基于Properties资源装载Spring Bean配置元信息"></a>基于Properties资源装载Spring Bean配置元信息</h2><p>Spring Bean 配置元信息</p>
<table>
<thead>
<tr>
<th>Properties属性名</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>(class)</td>
<td>Bean类全称限定名</td>
</tr>
<tr>
<td>(abstract)</td>
<td>是否为抽象的BeanDefinition</td>
</tr>
<tr>
<td>(parent)</td>
<td>指定parent BeanDefinition名称</td>
</tr>
<tr>
<td>(lazy-init)</td>
<td>是否为延迟初始化</td>
</tr>
<tr>
<td>(ref)</td>
<td>应用其他Bean的名称</td>
</tr>
<tr>
<td>(scope)</td>
<td>设置Bean的scope属性</td>
</tr>
<tr>
<td>${n}</td>
<td>n表示第n+1个构造器参数</td>
</tr>
</tbody></table>
<blockquote>
<p>底层实现：PropertiesBeanDefinitionReader</p>
</blockquote>
<p>接下来我们定义一个properties文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># User BeanDefinition 定义</span><br><span class="line">user.(<span class="class"><span class="keyword">class</span>) </span>= org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User</span><br><span class="line">user.id = <span class="number">1</span></span><br><span class="line">user.name = jiyongchao</span><br><span class="line">user.city = HANGZHOU</span><br></pre></td></tr></table></figure>

<p>尝试获取解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesBeanDefinitionReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        PropertiesBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> PropertiesBeanDefinitionReader(beanFactory);</span><br><span class="line">        String location = <span class="string">&quot;classpath:/META-INF/users-config-definitions.properties&quot;</span>;</span><br><span class="line">        <span class="comment">// 默认通过ISO-8859-1</span></span><br><span class="line">        ResourceLoader resourceLoader = <span class="keyword">new</span> DefaultResourceLoader();</span><br><span class="line">        <span class="comment">// 通过指定的Classpath获取Resource对象</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="comment">// 转换成带字符编码的EncodedResource对象</span></span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = beanDefinitionReader.loadBeanDefinitions(encodedResource);</span><br><span class="line">        System.out.printf(<span class="string">&quot;已加载%d 个BeanDefinition\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">        User user = beanFactory.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关核心代码在PropertiesBeanDefinitionReader#loadBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource, <span class="meta">@Nullable</span> String prefix)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Loading properties bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> (InputStream is = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				getPropertiesPersister().load(props, <span class="keyword">new</span> InputStreamReader(is, encodedResource.getEncoding()));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				getPropertiesPersister().load(props, is);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = registerBeanDefinitions(props, prefix, encodedResource.getResource().getDescription());</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Could not parse properties from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用properties的方式读取BeanDefinition的时候，如果出现Bean重复定义的情况，Spring会忽略后面定义的Bean的相关信息。</p>
</blockquote>
<h2 id="基于Java注解的Spring-Bean配置元信息"><a href="#基于Java注解的Spring-Bean配置元信息" class="headerlink" title="基于Java注解的Spring Bean配置元信息"></a>基于Java注解的Spring Bean配置元信息</h2><p>Spring模式注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Repository</td>
<td>数据仓储模式注解</td>
<td>2.0</td>
</tr>
<tr>
<td>@Component</td>
<td>通用组件模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Service</td>
<td>服务模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Controller</td>
<td>Web控制器模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类模式注解</td>
<td>3.0</td>
</tr>
</tbody></table>
<p>由于注解是不能集成的，所以采用元注解（元标注的方式来实现），其他注解都可以看成是<code>@Component</code>的”派生”注解。</p>
<p>Spring Bean依赖注入注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>Bean依赖注入，支持多种依赖查找的方式</td>
<td>2.5</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>细粒度的@Autowired依赖查找</td>
<td>2.5</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Java注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Resource</td>
<td>类似于@Autowired</td>
<td>2.5</td>
</tr>
<tr>
<td>@Inject</td>
<td>类似于@Autowired</td>
<td>2.5</td>
</tr>
</tbody></table>
<p>Spring Bean条件装配注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Profile</td>
<td>配置化条件装配</td>
<td>3.1</td>
</tr>
<tr>
<td>@Conditional</td>
<td>编程条件装配</td>
<td>4.0</td>
</tr>
</tbody></table>
<p>我们可以看一下@Profile注解的@Conditional：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">		MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line">		<span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Object value : attrs.get(<span class="string">&quot;value&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是Spring Bean声明周期回调注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@PostConstruct</td>
<td>替换XML标签或者实现接口</td>
<td>2.5</td>
</tr>
<tr>
<td>@PreDestory</td>
<td>替换XML标签或者实现接口</td>
<td>2.5</td>
</tr>
</tbody></table>
<h2 id="Spring-Bean配置元信息底层实现"><a href="#Spring-Bean配置元信息底层实现" class="headerlink" title="Spring Bean配置元信息底层实现"></a>Spring Bean配置元信息底层实现</h2><p>Spring BeanDefinition解析与注册的方式：</p>
<table>
<thead>
<tr>
<th>实现场景</th>
<th>实现类</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>XML资源</td>
<td>XmlBeanDefinitionReader</td>
<td>1.0</td>
</tr>
<tr>
<td>Properties</td>
<td>PropertiesBeanDefinitionReader</td>
<td>1.0</td>
</tr>
<tr>
<td>Java注解</td>
<td>AnnotatedBeanDefinitionReader</td>
<td>3.0</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是AnnotatedBeanDefinitionReader与BeanDefinition并没有任何直接的关系，而XmlBeanDefinitionReader和PropertiesBeanDefinitionReader都继承了AbstractBeanDefinitionReader。</p>
</blockquote>
<h3 id="XML资源的方式"><a href="#XML资源的方式" class="headerlink" title="XML资源的方式"></a>XML资源的方式</h3><p>Spring XML资源BeanDefinition解析与注册：</p>
<ul>
<li>核心API - XmlBeanDefinitionReader</li>
<li>底层 - BeanDefinitionDocumentReader<ul>
<li>XML解析 - Java DOM Level 3 API</li>
<li>BeanDefinition 解析  - BeanDefinitionParserDelegate</li>
<li>BeanDefinition注册 - BeanDefinitionRegistry</li>
</ul>
</li>
</ul>
<blockquote>
<p>BeanDefinitionDocumentReader有且仅有一个实现，DefaultBeanDefinitionDocumentReader，它里面的preProcessXml和postProcessXml方法都是空实现，可以让我们在加载XML资源的前后做一些自定义的操作，使用的时候只需要继承DefaultBeanDefinitionDocumentReader，然后设置XmlBeanDefinitionReader所使用的加载类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =</span><br><span class="line">			DefaultBeanDefinitionDocumentReader.class;</span><br></pre></td></tr></table></figure>

<h3 id="Properties资源的方式"><a href="#Properties资源的方式" class="headerlink" title="Properties资源的方式"></a>Properties资源的方式</h3><p>Spring Properties资源BeanDefinition解析与注册：</p>
<ul>
<li>核心API - PropertiesBeanDefinitionReader<ul>
<li>资源<ul>
<li>字节流 - Resource</li>
<li>字符流 - EncodedResource</li>
</ul>
</li>
<li>底层<ul>
<li>存储 - java.util.Properties</li>
<li>BeanDefinition解析 - API内部实现</li>
<li>BeanDefinition注册 - BeanDefinitionRegistry</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>通过这种方式装在的Bean的名称就是”.”之前的字符。</p>
</blockquote>
<h3 id="Java注解的方式"><a href="#Java注解的方式" class="headerlink" title="Java注解的方式"></a>Java注解的方式</h3><p>Spring Java注册BeanDefintiion解析与注册：</p>
<ul>
<li>核心API - AnnotatedBeanDefinitionReader<ul>
<li>资源<ul>
<li>类对象 - java.lang.Class</li>
</ul>
</li>
<li>底层<ul>
<li>条件评估 - ConditionEvaluator</li>
<li>Bean范围解析 - ScopeMetadataResolver</li>
<li>BeanDefinition解析 - 内部API实现</li>
<li>BeanDefinition处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations</li>
<li>BeanDefinition注册 - BeanDefinitionRegistry</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实现的核心源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		abd.setInstanceSupplier(supplier);</span><br><span class="line">		ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">		abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">		String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line">		<span class="comment">// 如果Bean上面有@Lazy或者@Primary等等，这个方法会把相关的信息赋值给BeanDefinition</span></span><br><span class="line">		AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">		<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">					abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">					abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">				customizer.customize(abd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">		definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于XML资源装载Spring-容器配置元信息"><a href="#基于XML资源装载Spring-容器配置元信息" class="headerlink" title="基于XML资源装载Spring 容器配置元信息"></a>基于XML资源装载Spring 容器配置元信息</h2><p>Spring IoC容器相关XML配置：</p>
<table>
<thead>
<tr>
<th>命名空间</th>
<th>所属模块</th>
<th>Schema资源URL</th>
</tr>
</thead>
<tbody><tr>
<td>beans</td>
<td>spring-beans</td>
<td><a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a></td>
</tr>
<tr>
<td>context</td>
<td>spring-context</td>
<td><a href="http://www.springframework.org/schema/context/beans/spring-context.xsd">http://www.springframework.org/schema/context/beans/spring-context.xsd</a></td>
</tr>
<tr>
<td>aop</td>
<td>spring-aop</td>
<td><a href="http://www.springframework.org/schema/aop/spring-aop.xsd">http://www.springframework.org/schema/aop/spring-aop.xsd</a></td>
</tr>
<tr>
<td>tx</td>
<td>spring-tx</td>
<td><a href="http://www.springframework.org/schema/tx/spring-tx.xsd">http://www.springframework.org/schema/tx/spring-tx.xsd</a></td>
</tr>
<tr>
<td>util</td>
<td>spring-util</td>
<td><a href="http://www.springframework.org/schema/util/spring-util.xsd">http://www.springframework.org/schema/util/spring-util.xsd</a></td>
</tr>
<tr>
<td>tool</td>
<td>spring-beans</td>
<td><a href="http://www.springframework.org/schema/tool/spring-tool.xsd">http://www.springframework.org/schema/tool/spring-tool.xsd</a></td>
</tr>
</tbody></table>
<blockquote>
<p>如果需要支持事务，需要单独引入spring-tx。</p>
</blockquote>
<h2 id="基于Java注解配置Spring-容器配置元信息"><a href="#基于Java注解配置Spring-容器配置元信息" class="headerlink" title="基于Java注解配置Spring 容器配置元信息"></a>基于Java注解配置Spring 容器配置元信息</h2><p>Spring IoC容器装配注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@ImportResource</td>
<td>替换XML元素<import></td>
<td>3.0</td>
</tr>
<tr>
<td>@Import</td>
<td>导入Configuration Class</td>
<td>3.0</td>
</tr>
<tr>
<td>@ComponenetScan</td>
<td>扫描指定package下标注Spring模式注解的类</td>
<td>3.1</td>
</tr>
</tbody></table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:/META-INF/dependency-lookup-context.xml&quot;)</span></span><br><span class="line"><span class="meta">@Import(User.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedSpringIoCContainerConfigurationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AnnotatedSpringIoCContainerConfigurationDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        Map&lt;String, User&gt; userMap = context.getBeansOfType(User.class);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : userMap.entrySet()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;User Bean name:%s,content: %s \n&quot;</span>, entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring IoC配置属性注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@PropertySource</td>
<td>配置属性抽象PropertySource注解</td>
<td>3.1</td>
</tr>
<tr>
<td>@PropertySources</td>
<td>@PropertySource集合注解</td>
<td>4.0</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:/META-INF/users-config-definitions.properties&quot;)</span> <span class="comment">//Java8 + @Repeatable</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/META-INF/users-config-definitions.properties&quot;)</span></span><br><span class="line"><span class="comment">//@PropertySources(@PropertySource(value = &quot;1&quot;))</span></span><br></pre></td></tr></table></figure>

<h2 id="基于Extensible-XML-authoring扩展Spring-XML元素"><a href="#基于Extensible-XML-authoring扩展Spring-XML元素" class="headerlink" title="基于Extensible XML authoring扩展Spring XML元素"></a>基于Extensible XML authoring扩展Spring XML元素</h2><p>Spring XML扩展的步骤：</p>
<ol>
<li>编写XML Schema文件：定义XML结构</li>
<li>自定义NamespaceHandler实现：命名空间绑定</li>
<li>定义BeanDefinitionParser实现：XML元素与BeanDefinition解析</li>
<li>注册XML扩展：命名空间与XML Schema映射</li>
</ol>
<p>定义XML结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:users</span>=<span class="string">&quot;http://jycoder.org/schema/users&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://jycoder.org/schema/users&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">users:user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;jiyongchao&quot;</span> <span class="attr">city</span>=<span class="string">&quot;SHANGHAI&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>命名空间绑定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsersNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将&quot;user&quot;元素注册对应的BeanDefinitionParser实现</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;user&quot;</span>,<span class="keyword">new</span> UserBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML元素与BeanDefinition解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        setPropertyValue(<span class="string">&quot;id&quot;</span>, element, builder);</span><br><span class="line">        setPropertyValue(<span class="string">&quot;name&quot;</span>, element, builder);</span><br><span class="line">        setPropertyValue(<span class="string">&quot;City&quot;</span>, element, builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String attributeName, Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        String attributeValue = element.getAttribute(attributeName);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(attributeValue)) &#123;</span><br><span class="line">            builder.addPropertyValue(attributeName, attributeValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间与XML Schema映射：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义namespacehanlder</span></span><br><span class="line"><span class="meta">http\://jycoder.org/schema/users</span>=<span class="string">org.jyc.thinking.in.spring.bean.metadata.UsersNamespaceHandler</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">http\://jycoder.org/schema/users.xsd</span>=<span class="string">org/jyc/thinking/in/spring/bean/metadata/users.xsd</span></span><br></pre></td></tr></table></figure>

<p>测试我们编写的案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensibleXmlAuthoringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;classpath:/META-INF/users-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取User Bean对象</span></span><br><span class="line">        User user = beanFactory.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于Properties资源装载外部化配置"><a href="#基于Properties资源装载外部化配置" class="headerlink" title="基于Properties资源装载外部化配置"></a>基于Properties资源装载外部化配置</h2><ol>
<li>注解驱动：<ul>
<li>org.springframework.context.annotation.PropertySource</li>
<li>org.springframework.context.annotation.PropertySources</li>
</ul>
</li>
<li>API编程：<ul>
<li>org.springframework.core.env.PropertySource</li>
<li>org.springframework.core.env.PropertySources</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:/META-INF/users-config-definitions.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourceDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">(<span class="meta">@Value(&quot;$&#123;user.id&#125;&quot;)</span> String id, <span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 扩展Environment中的PropertySources</span></span><br><span class="line">        <span class="comment">// 添加PropertySources操作必须在refresh方法之前完成</span></span><br><span class="line">        Map&lt;String, Object&gt; propertiesSource = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        propertiesSource.put(<span class="string">&quot;user.name&quot;</span>, <span class="string">&quot;xiao ji&quot;</span>);</span><br><span class="line">        org.springframework.core.env.PropertySource propertySource = <span class="keyword">new</span> MapPropertySource(<span class="string">&quot;first-property-source&quot;</span>, propertiesSource);</span><br><span class="line">        context.getEnvironment().getPropertySources().addFirst(propertySource);</span><br><span class="line">        context.register(AnnotatedSpringIoCContainerConfigurationDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        Map&lt;String, User&gt; userMap = context.getBeansOfType(User.class);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, User&gt; entry : userMap.entrySet()) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;User Bean name:%s,content: %s \n&quot;</span>, entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(context.getEnvironment().getPropertySources());</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于yml资源装载外部化配置"><a href="#基于yml资源装载外部化配置" class="headerlink" title="基于yml资源装载外部化配置"></a>基于yml资源装载外部化配置</h2><p>使用API编程：</p>
<ul>
<li>org.springframework.beans.factory.config.YamlProcessor<ul>
<li>org.springframework.beans.factory.config.YamlMapFactoryBean</li>
<li>org.springframework.beans.factory.config.YamlPropertiesFactoryBean</li>
</ul>
</li>
</ul>
<p>定义YAML文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">吉永超</span></span><br></pre></td></tr></table></figure>

<p>定义XML文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;yamlMap&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.YamlMapFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;resources&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:/META-INF/user.yaml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试我们的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBasedYamlPropertySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        reader.loadBeanDefinitions(<span class="string">&quot;classpath:/META-INF/yaml-property-source-context.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取User Bean对象</span></span><br><span class="line">        User user = beanFactory.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PropertySource默认是没有yaml格式的实现的，我们可以自己实现一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertySourceFactory</span> <span class="keyword">implements</span> <span class="title">PropertySourceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        YamlPropertiesFactoryBean yamlPropertiesFactoryBean = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        yamlPropertiesFactoryBean.setResources(resource.getResource());</span><br><span class="line">        Properties yamlProperties = yamlPropertiesFactoryBean.getObject();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(name, yamlProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用YAML的方式装载外部化配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(name = &quot;yamlPropertySource&quot;,</span></span><br><span class="line"><span class="meta">        value = &quot;classpath:/META-INF/user.yaml&quot;,</span></span><br><span class="line"><span class="meta">        factory = YamlPropertySourceFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedYamlPropertySourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">(<span class="meta">@Value(&quot;$&#123;user.id&#125;&quot;)</span> String id, <span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(AnnotatedYamlPropertySourceDemo.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-9"><a href="#面试题-9" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring内建的XML-Schema常见有哪些？"><a href="#Spring内建的XML-Schema常见有哪些？" class="headerlink" title="Spring内建的XML Schema常见有哪些？"></a>Spring内建的XML Schema常见有哪些？</h3><p>见基于XML资源装载Spring 容器配置元信息章节表格。</p>
<h3 id="Spring配置元信息有哪些？"><a href="#Spring配置元信息有哪些？" class="headerlink" title="Spring配置元信息有哪些？"></a>Spring配置元信息有哪些？</h3><ul>
<li>Bean配置元信息：通过媒介（如XML、Properties）等，解析BeanDefinition</li>
<li>IoC容器配置元信息：通过媒介（如XML、Properties等），控制IoC容器行为，比如注解驱动，AOP等</li>
<li>外部化配置：通过资源抽象（如Properties、YAML等），控制PropertySource</li>
<li>Spring Profile：通过外部化配置，提供条件分支流程</li>
</ul>
<h3 id="Extensible-XML-authoring的缺点？"><a href="#Extensible-XML-authoring的缺点？" class="headerlink" title="Extensible XML authoring的缺点？"></a>Extensible XML authoring的缺点？</h3><ul>
<li>高复杂度：开发人员需要熟悉XML schema、Spring.handlers，Spring.schemas以及Spring API</li>
<li>嵌套元素支持较弱：通常需要使用方法递归或者嵌套解析的方式处理嵌套（子）元素</li>
<li>XML处理性能较差：Spring XML基于DOM Levels API 实现，该API便于理解，然而性能较差</li>
<li>XML框架移植性较差：很难适配高性能和便利性的XML框架，如JAXB。</li>
</ul>
<h1 id="Spring-资源管理"><a href="#Spring-资源管理" class="headerlink" title="Spring 资源管理"></a>Spring 资源管理</h1><blockquote>
<p>为什么Spring不使用Java标准资源管理，而选择重新发明轮子？</p>
<ul>
<li>Java标准资源管理强大，然而扩展复杂，资源存储方式并不统一</li>
<li>Spring要自立门户</li>
<li>Spring “抄”、“超”、“潮”</li>
</ul>
</blockquote>
<h2 id="Java标准资源管理"><a href="#Java标准资源管理" class="headerlink" title="Java标准资源管理"></a>Java标准资源管理</h2><p>Java标准资源定位：</p>
<table>
<thead>
<tr>
<th>职责</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>面向资源</td>
<td>文件系统、artifact（jar、war、ear文件）以及远程资源（HTTP、FTP等）</td>
</tr>
<tr>
<td>API整合</td>
<td>java.lang.ClassLoader#getResource、java.io.File或java.net.URL</td>
</tr>
<tr>
<td>资源定位</td>
<td>java.net.URL或java.net.URI</td>
</tr>
<tr>
<td>面向流失存储</td>
<td>java.net.URLConnection</td>
</tr>
<tr>
<td>协议扩展</td>
<td>java.net.URLStreamHandler或java.net.URLStreamHandleFactory</td>
</tr>
</tbody></table>
<h2 id="Resource接口"><a href="#Resource接口" class="headerlink" title="Resource接口"></a>Resource接口</h2><p>资源接口：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>org.springframework.core.io.InputStreamResource</td>
</tr>
<tr>
<td>只读资源</td>
<td>org.springframework.core.io.Resource</td>
</tr>
<tr>
<td>可写资源</td>
<td>org.springframework.core.io.WritableResource</td>
</tr>
<tr>
<td>编码资源</td>
<td>org.springframework.core.io.support.EncodedResource</td>
</tr>
<tr>
<td>上下文资源</td>
<td>org.springframework.core.io.ContextResource</td>
</tr>
</tbody></table>
<h2 id="内建的Resource实现"><a href="#内建的Resource实现" class="headerlink" title="内建的Resource实现"></a>内建的Resource实现</h2><p>内建实现：</p>
<table>
<thead>
<tr>
<th>资源来源</th>
<th>资源协议</th>
<th>实现类</th>
</tr>
</thead>
<tbody><tr>
<td>Bean定义</td>
<td>无</td>
<td>org.springframework.beans.factory.support.BeanDefinitionResource</td>
</tr>
<tr>
<td>数组</td>
<td>无</td>
<td>org.springframework.core.io.ByteArrayResource</td>
</tr>
<tr>
<td>类路径</td>
<td>classpath:/</td>
<td>org.springframework.core.io.ClassPathResource</td>
</tr>
<tr>
<td>文件系统</td>
<td>file:/</td>
<td>org.springframework.core.io.FileSystemResource</td>
</tr>
<tr>
<td>URL</td>
<td>URL支持的协议</td>
<td>org.springframework.core.io.UrlResource</td>
</tr>
<tr>
<td>ServletContext</td>
<td>无</td>
<td>org.springframework.web.context.support.ServletContextResource</td>
</tr>
</tbody></table>
<h2 id="Resource接口扩展"><a href="#Resource接口扩展" class="headerlink" title="Resource接口扩展"></a>Resource接口扩展</h2><ol>
<li>可写资源接口<ul>
<li>org.springframework.core.io.WritableResource<ul>
<li>org.springframework.core.io.FileSystemResource</li>
<li>org.springframework.core.io.FileUrlResource（@since 5.0.2）</li>
<li>org.springframework.core.io.PathResource（@since 4.0 &amp; @Deprecated）</li>
</ul>
</li>
</ul>
</li>
<li>编码资源接口<ul>
<li>org.springframework.core.io.support.EncodedResource</li>
</ul>
</li>
</ol>
<p>使用编码资源接口进行操作的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodedFileSystemResourceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String currentJavaFilePath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/EncodedFileSystemResourceDemo.java&quot;</span>;</span><br><span class="line">        File currentJavaFile = <span class="keyword">new</span> File(currentJavaFilePath);</span><br><span class="line">        FileSystemResource fileSystemResource = <span class="keyword">new</span> FileSystemResource(currentJavaFile);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(fileSystemResource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符输入流</span></span><br><span class="line">        <span class="keyword">try</span> (Reader reader = encodedResource.getReader()) &#123;</span><br><span class="line">            System.out.println(IOUtils.toString(reader));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring资源加载器"><a href="#Spring资源加载器" class="headerlink" title="Spring资源加载器"></a>Spring资源加载器</h2><p>Resource加载器：</p>
<ul>
<li>org.springframework.core.io.ResourceLoader<ul>
<li>org.springframework.core.io.DefaultResourceLoader</li>
<li>org.springframework.core.io.FileSystemResourceLoader</li>
<li>org.springframework.core.io.ClassRelativeResourceLoader</li>
<li>org.springframework.context.support.AbstractApplicationContext</li>
</ul>
</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodedFileSystemResourceLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String currentJavaFilePath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/EncodedFileSystemResourceLoaderDemo.java&quot;</span>;</span><br><span class="line">        FileSystemResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">        Resource fileSystemResource = resourceLoader.getResource(currentJavaFilePath);</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(fileSystemResource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符输入流</span></span><br><span class="line">        <span class="keyword">try</span> (Reader reader = encodedResource.getReader()) &#123;</span><br><span class="line">            System.out.println(IOUtils.toString(reader));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring通配路径资源加载器"><a href="#Spring通配路径资源加载器" class="headerlink" title="Spring通配路径资源加载器"></a>Spring通配路径资源加载器</h2><ol>
<li>通配路径ResourceLoader<ul>
<li>org.springframework.core.io.support.ResourcePatternResolver</li>
<li>org.springframework.core.io.support.PathMatchingResourcePatternResolver</li>
</ul>
</li>
<li>路径匹配器<ul>
<li>org.springframework.util.PathMatcher<ul>
<li>Ant模式匹配实现 - org.springframework.util.AntPathMatcher</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Spring通配路径资源扩展"><a href="#Spring通配路径资源扩展" class="headerlink" title="Spring通配路径资源扩展"></a>Spring通配路径资源扩展</h2><ol>
<li>实现org.springframework.util.PathMatcher</li>
<li>重置PathMatcher<ul>
<li>PathMatchingResourcePatternResolver#setPathMatcher</li>
</ul>
</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedResourcePatternResolver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 读取当前package对应的所有的.java文件</span></span><br><span class="line">        <span class="comment">// *.java</span></span><br><span class="line">        String currentPackagePath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/bean-resource/src/main/java/org/jyc/thinking/in/spring/resource/&quot;</span>;</span><br><span class="line">        String locationPattern = currentPackagePath + <span class="string">&quot;*.java&quot;</span>;</span><br><span class="line">        PathMatchingResourcePatternResolver resourcePatternResolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">new</span> FileSystemResourceLoader());</span><br><span class="line"></span><br><span class="line">        resourcePatternResolver.setPathMatcher(<span class="keyword">new</span> JavaFilePathMatcher());</span><br><span class="line">        Resource[] resources = resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">        Stream.of(resources).map(ResourceUtils::getContent).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaFilePathMatcher</span> <span class="keyword">implements</span> <span class="title">PathMatcher</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPattern</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> path.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> path.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchStart</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">extractPathWithinPattern</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">extractUriTemplateVariables</span><span class="params">(String pattern, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Comparator&lt;String&gt; <span class="title">getPatternComparator</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">combine</span><span class="params">(String pattern1, String pattern2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中使用到的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getContent</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getContent(resource, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getContent</span><span class="params">(Resource resource, String encoding)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        EncodedResource encodedResource = <span class="keyword">new</span> EncodedResource(resource, encoding);</span><br><span class="line">        <span class="keyword">try</span> (Reader reader = encodedResource.getReader()) &#123;</span><br><span class="line">            <span class="keyword">return</span> IOUtils.toString(reader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入Spring-Resource"><a href="#依赖注入Spring-Resource" class="headerlink" title="依赖注入Spring Resource"></a>依赖注入Spring Resource</h2><p>可以基于@Value实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;classpath:/...&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br></pre></td></tr></table></figure>

<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectResourceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;classpath:/META-INF/default.properties&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource defaultPropertiesResource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;classpath*:/META-INF/*.properties&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] PropertiesResources;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user.dir&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String currentProjectRootPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(ResourceUtils.getContent(defaultPropertiesResource));</span><br><span class="line">        System.out.println(currentProjectRootPath);</span><br><span class="line">        Stream.of(PropertiesResources).map(ResourceUtils::getContent).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(InjectResourceDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 关闭应用上下文</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入ResourceLoader"><a href="#依赖注入ResourceLoader" class="headerlink" title="依赖注入ResourceLoader"></a>依赖注入ResourceLoader</h2><p>有多种方式可以依赖注入ResourceLoader：</p>
<ol>
<li>实现ResourceLoaderAware回调</li>
<li>@Autowired注入ResourceLoader</li>
<li>注入ApplicationContext作为ResourceLoader</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectResourceLoaderDemo</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader awareResourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ResourceLoader autowiredResourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AbstractApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;awareResourceLoader == autowiredResourceLoader: &quot;</span> + (autowiredResourceLoader == awareResourceLoader));</span><br><span class="line">        System.out.println(<span class="string">&quot;autowiredResourceLoader == applicationContext: &quot;</span> + (awareResourceLoader == applicationContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        applicationContext.register(InjectResourceLoaderDemo.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        <span class="comment">// 关闭应用上下文</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.awareResourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这三种不同的方式最终注入的是相同的对象，都是AbstractApplicationContext。</p>
</blockquote>
<h2 id="面试题-10"><a href="#面试题-10" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring配置资源中有哪些常见类型？"><a href="#Spring配置资源中有哪些常见类型？" class="headerlink" title="Spring配置资源中有哪些常见类型？"></a>Spring配置资源中有哪些常见类型？</h3><p>XML资源、Properties资源、YAML资源。</p>
<h3 id="请举例不同类型的Spring配置资源"><a href="#请举例不同类型的Spring配置资源" class="headerlink" title="请举例不同类型的Spring配置资源"></a>请举例不同类型的Spring配置资源</h3><p>XML资源：</p>
<ol>
<li>普通的BeanDefinition XML资源配置 - *.xml</li>
<li>Spring Schema资源 - *.xsd</li>
</ol>
<p>Properties资源：</p>
<ol>
<li>普通Properties格式资源 - *.properties</li>
<li>Spring Handler实现类映射文件 - META/spring.handlers</li>
<li>Spring Schema资源映射文件 - META-INF/spring.schemas</li>
</ol>
<p>YAML资源：</p>
<ol>
<li>普通YAML资源配置 - *.yaml或 *.yml</li>
</ol>
<h3 id="Java标准资源管理扩展的步骤"><a href="#Java标准资源管理扩展的步骤" class="headerlink" title="Java标准资源管理扩展的步骤"></a>Java标准资源管理扩展的步骤</h3><p>简易实现：</p>
<ul>
<li>实现URLStreamHandler并放置再sun.net.<a href="http://www.protocol.${protocol}.handler包下/">www.protocol.${protocol}.Handler包下</a></li>
</ul>
<p>自定义实现：</p>
<ul>
<li>实现URLStreamHandler</li>
<li>添加 -Djava.protocol.handler.pkgs启动参数，指向URLStreamHandler实现类的包下</li>
</ul>
<p>高级实现：</p>
<ul>
<li>实现URLStreamHandlerFactory并传递到URL之中</li>
</ul>
<h1 id="Spring-国际化"><a href="#Spring-国际化" class="headerlink" title="Spring 国际化"></a>Spring 国际化</h1><p>Spring国际化使用场景：</p>
<ul>
<li>普通国际化文案</li>
<li>Bean Validation校验国际化文案</li>
<li>Web站点页面渲染</li>
<li>Web MVC错误消息提示</li>
</ul>
<h2 id="Spring国际化接口"><a href="#Spring国际化接口" class="headerlink" title="Spring国际化接口"></a>Spring国际化接口</h2><p>核心接口：</p>
<ul>
<li>org.springframework.context.MessageSource</li>
</ul>
<p>主要概念：</p>
<ul>
<li>文案模板编码（code）</li>
<li>文案模板参数（args）</li>
<li>区域（Locale）</li>
</ul>
<h2 id="层次性的MessageSource"><a href="#层次性的MessageSource" class="headerlink" title="层次性的MessageSource"></a>层次性的MessageSource</h2><p>Spring层次性国际化接口：</p>
<ul>
<li>org.springframework.context.HierarchicalMessageSource</li>
</ul>
<h2 id="Java国际化标准实现"><a href="#Java国际化标准实现" class="headerlink" title="Java国际化标准实现"></a>Java国际化标准实现</h2><p>核心接口：</p>
<ul>
<li>抽象实现 - java.util.ResourceBundle</li>
<li>Properties资源实现 - java.util.PropertyResourceBundle</li>
<li>列举实现 - java.util.ListResourceBundle</li>
</ul>
<p>ResourceBundle核心特性：</p>
<ul>
<li>Key - Value设计</li>
<li>层次性设计</li>
<li>缓存设计</li>
<li>字符编码控制 - java.util.ResourceBundle.Control（@since 1.6）</li>
<li>Control SPI扩展 - java.util.spi.ResourceBundleControlProvider（@since 1.8）</li>
</ul>
<h2 id="Java文本格式化"><a href="#Java文本格式化" class="headerlink" title="Java文本格式化"></a>Java文本格式化</h2><p>核心接口：</p>
<ul>
<li>java.text.MessageFormat</li>
</ul>
<p>基本用法：</p>
<ul>
<li>设置消息格式模式 - new MessageFormat(…)</li>
<li>格式化 - format(new Objectp[]{…})</li>
</ul>
<p>消息格式模式：</p>
<ul>
<li>格式元素：{ArgumentIndex（,FormatType,（FormatStyle））}</li>
<li>FormatType：消息格式类型，可选项，每种类型在number、date、time和choice类型选其一</li>
<li>FormatStyle：消息格式风格，可选项，包括：short、medium、long、full、integer、currency、percent</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> planet = <span class="number">7</span>;</span><br><span class="line">        String event = <span class="string">&quot;a disturbance in the Force&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String result = MessageFormat.format(</span><br><span class="line">                <span class="string">&quot;At &#123;1,time,long&#125; on &#123;1,date&#125;, there was &#123;2&#125; on planet &#123;0,number,integer&#125;.&quot;</span>,</span><br><span class="line">                planet, <span class="keyword">new</span> Date(), event);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java文本格式化还有一些高级特性：</p>
<ul>
<li>重置消息格式模板</li>
<li>重置java.util.Locale</li>
<li>重置java.text.Format</li>
</ul>
<p>使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageFormatDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> planet = <span class="number">7</span>;</span><br><span class="line">        String event = <span class="string">&quot;a disturbance in the Force&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String messageFormatPattern = <span class="string">&quot;At &#123;1,time,long&#125; on &#123;1,date&#125;, there was &#123;2&#125; on planet &#123;0,number,integer&#125;.&quot;</span>;</span><br><span class="line">        MessageFormat messageFormat = <span class="keyword">new</span> MessageFormat(messageFormatPattern);</span><br><span class="line">        String result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;planet, <span class="keyword">new</span> Date(), event&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置MessageFormatPattern</span></span><br><span class="line">        messageFormatPattern = <span class="string">&quot;This is a text: &#123;0&#125;,&#123;1&#125;,&#123;2&#125;&quot;</span>;</span><br><span class="line">        messageFormat.applyPattern(messageFormatPattern);</span><br><span class="line">        result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;hello,world&quot;</span>, <span class="string">&quot;666&quot;</span>&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置Locale</span></span><br><span class="line">        messageFormat.setLocale(Locale.ENGLISH);</span><br><span class="line">        messageFormatPattern = <span class="string">&quot;At &#123;1,time,long&#125; on &#123;1,date&#125;, there was &#123;2&#125; on planet &#123;0,number,integer&#125;.&quot;</span>;</span><br><span class="line">        messageFormat.applyPattern(messageFormatPattern);</span><br><span class="line">        result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;planet, <span class="keyword">new</span> Date(), event&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置Format</span></span><br><span class="line">        <span class="comment">// 根据参数索引来设置 Pattern</span></span><br><span class="line">        messageFormat.setFormat(<span class="number">1</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        result = messageFormat.format(<span class="keyword">new</span> Object[]&#123;planet, <span class="keyword">new</span> Date(), event&#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MessageSource开箱实现"><a href="#MessageSource开箱实现" class="headerlink" title="MessageSource开箱实现"></a>MessageSource开箱实现</h2><p>基于ResourceBundle + MessageFormat组合MessageSource实现：</p>
<ul>
<li>org.springframework.context.support.ResourceBundleMessageSource</li>
</ul>
<p>可重载Properties + MessageFormat组合MessageSource实现：</p>
<ul>
<li>org.springframework.context.support.ReloadableResourceBundleMessageSource</li>
</ul>
<h2 id="Message的内建依赖"><a href="#Message的内建依赖" class="headerlink" title="Message的内建依赖"></a>Message的内建依赖</h2><p>MessageSource内建Bean可能来源：</p>
<ul>
<li>预注册Bean名称为：”messageSource”，类型为：MessageSource Bean</li>
<li>默认内建实现 - DelegatingMessageSource<ul>
<li>层次性查找MessageSource对象</li>
</ul>
</li>
</ul>
<p>相关的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">			<span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">				HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">				<span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">					<span class="comment">// registered already.</span></span><br><span class="line">					hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">			DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">			dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">			<span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">			beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot为什么要新建MessageSource-Bean"><a href="#SpringBoot为什么要新建MessageSource-Bean" class="headerlink" title="SpringBoot为什么要新建MessageSource Bean?"></a>SpringBoot为什么要新建MessageSource Bean?</h2><ol>
<li>AbstractApplicationContext的实现决定了MessageSource内建实现</li>
<li>Spring Boot通过外部化配置简化了MessageSource Bean构建</li>
<li>SPring Boot基于Bean Validation校验非常普遍</li>
</ol>
<p>实际上我们可以覆盖SpringBoot中自动装配的MessageSource Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedMessageSourceBeanDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Spring Boot场景中，Primary Configure Sources（Classes）高于*AutoConfiguration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReloadableResourceBundleMessageSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = SpringApplication.run(CustomizedMessageSourceBeanDemo.class, args);</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.containsBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">            beanFactory.getBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME);</span><br><span class="line">            <span class="comment">// 查找MessageSource Bean</span></span><br><span class="line">            MessageSource messageSource = applicationContext.getBean(AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">            System.out.println(messageSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-11"><a href="#面试题-11" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring国际化接口有哪些？"><a href="#Spring国际化接口有哪些？" class="headerlink" title="Spring国际化接口有哪些？"></a>Spring国际化接口有哪些？</h3><ol>
<li>核心接口 - MessageSource</li>
<li>层次性接口 - org.springframework.context.HierarchicalMessageSource</li>
</ol>
<h3 id="Spring有哪些MessageSource的内建实现？"><a href="#Spring有哪些MessageSource的内建实现？" class="headerlink" title="Spring有哪些MessageSource的内建实现？"></a>Spring有哪些MessageSource的内建实现？</h3><ul>
<li>org.springframework.context.support.ResourceBundleMessageSource</li>
<li>org.springframework.context.support.ReloadableResourceBundleMessageSource</li>
<li>org.springframework.context.support.StaticMessageSource</li>
<li>org.springframework.context.support.DelegatingMessageSource</li>
</ul>
<h3 id="如何实现配置自动更新MessageSource？"><a href="#如何实现配置自动更新MessageSource？" class="headerlink" title="如何实现配置自动更新MessageSource？"></a>如何实现配置自动更新MessageSource？</h3><p>主要技术：</p>
<ul>
<li>Java NIO 2：java.nio.file.watchService</li>
<li>Java Concurrency：java.util.concurrent.ExecutorService</li>
<li>Spring：org.springframework.context.support.AbstractMessageSource</li>
</ul>
<h1 id="Spring-校验"><a href="#Spring-校验" class="headerlink" title="Spring 校验"></a>Spring 校验</h1><p>Spring校验使用场景：</p>
<ul>
<li>Spring 常规校验（Validator）</li>
<li>Spring 数据绑定（DataBinder）</li>
<li>Spring Web参数绑定（WebDataBinder）</li>
<li>Spring WebMVC/WebFlux处理方法参数校验</li>
</ul>
<h2 id="Validator接口设计"><a href="#Validator接口设计" class="headerlink" title="Validator接口设计"></a>Validator接口设计</h2><p>接口职责：</p>
<ul>
<li>Spring内部校验接口，通过编程的方式校验目标对象</li>
</ul>
<p>核心方法：</p>
<ul>
<li>supports（Class）：校验目标类能否校验</li>
<li>validate（Object，Errors）：校验目标对象，并将校验失败的内容输出至Errors对象</li>
</ul>
<p>配套组件：</p>
<ul>
<li>错误收集器：org.springframework.validation.Errors</li>
<li>Validator工具类：org.springframework.validation.ValidationUtils</li>
</ul>
<p>在Java Doc中的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIMUM_PASSWORD_LENGTH = <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> UserLogin.class.isAssignableFrom(clazz);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">         ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;userName&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">         ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">         UserLogin login = (UserLogin) target;</span><br><span class="line">         <span class="keyword">if</span> (login.getPassword() != <span class="keyword">null</span></span><br><span class="line">               &amp;&amp; login.getPassword().trim().length() &lt; MINIMUM_PASSWORD_LENGTH) &#123;</span><br><span class="line">            errors.rejectValue(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;field.min.length&quot;</span>,</span><br><span class="line">                  <span class="keyword">new</span> Object[]&#123;Integer.valueOf(MINIMUM_PASSWORD_LENGTH)&#125;,</span><br><span class="line">                  <span class="string">&quot;The password must be at least [&quot;</span> + MINIMUM_PASSWORD_LENGTH + <span class="string">&quot;] characters in length.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Errors接口设计"><a href="#Errors接口设计" class="headerlink" title="Errors接口设计"></a>Errors接口设计</h2><p>接口职责：</p>
<ul>
<li>数据绑定和校验错误收集接口，与Java Bean和其属性有强关联性。</li>
</ul>
<p>核心方法：</p>
<ul>
<li>reject方法（重载）：收集错误文案</li>
<li>rejectValue方法（重载）：收集对象字段中的错误文案</li>
</ul>
<p>配套组件：</p>
<ul>
<li>Java Bean错误描述：org.springframework.validation.ObjectError</li>
<li>Java Bean属性错误描述：org.springframework.validation.FieldError</li>
</ul>
<h2 id="Errors的文案来源"><a href="#Errors的文案来源" class="headerlink" title="Errors的文案来源"></a>Errors的文案来源</h2><p>Errors文案生成步骤：</p>
<ol>
<li>选择Errors实现（org.springframework.validation.BeanPropertyBindingResult）</li>
<li>调用reject方法或rejectValue方法</li>
<li>获取Errors对象中ObjectError或FieldError</li>
<li>将ObjectError或FieldError中的code和args，关联MessageSource实现（如：ResourceBundleMessageSource）</li>
</ol>
<p>使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMessageDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建User对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 2.选择Errors - BeanPropertyBindingResult</span></span><br><span class="line">        Errors errors = <span class="keyword">new</span> BeanPropertyBindingResult(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.调用reject或者rejectValue</span></span><br><span class="line">        <span class="comment">// reject生成ObjectError</span></span><br><span class="line">        <span class="comment">// reject生成 FildError</span></span><br><span class="line">        errors.reject(<span class="string">&quot;user.properties.not.null&quot;</span>);</span><br><span class="line">        errors.rejectValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.required&quot;</span>);</span><br><span class="line">        <span class="comment">//4.FieldError is ObjectError</span></span><br><span class="line">        List&lt;ObjectError&gt; globalErrors = errors.getGlobalErrors();</span><br><span class="line">        FieldError fieldError = errors.getFieldError();</span><br><span class="line">        List&lt;ObjectError&gt; allErrors = errors.getAllErrors();</span><br><span class="line">        <span class="comment">// 5.通过ObjectError和FieldError中的code和args关联MessageSource实现</span></span><br><span class="line">        MessageSource messageSource = createMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : allErrors) &#123;</span><br><span class="line">            messageSource.getMessage(error.getCode(), error.getArguments(), Locale.getDefault());</span><br><span class="line">            System.out.println(messageSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MessageSource <span class="title">createMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StaticMessageSource staticMessageSource = <span class="keyword">new</span> StaticMessageSource();</span><br><span class="line">        staticMessageSource.addMessage(<span class="string">&quot;user.properties.not.null&quot;</span>, Locale.getDefault(), <span class="string">&quot;User 属性不能为空&quot;</span>);</span><br><span class="line">        staticMessageSource.addMessage(<span class="string">&quot;name.required&quot;</span>, Locale.getDefault(), <span class="string">&quot;name is not null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> staticMessageSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Validator"><a href="#自定义Validator" class="headerlink" title="自定义Validator"></a>自定义Validator</h2><p>实现org.springframework.validation.Validator接口，具体操作如下：</p>
<ul>
<li>实现supports方法</li>
<li>实现validate方法<ul>
<li>通过Errors对象收集错误<ul>
<li>ObjectError：对象（Bean）错误：</li>
<li>FieldError：对象（Bean）属性（Property）错误</li>
</ul>
</li>
<li>通过ObjectError和FieldError关联MessageSource实现获取最终文案</li>
</ul>
</li>
</ul>
<p>自定义Validator的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建Validator</span></span><br><span class="line">        Validator validator = <span class="keyword">new</span> UserValodator();</span><br><span class="line">        <span class="comment">// 2.判断是否支持目标对象的类型</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(validator.supports(user.getClass()));</span><br><span class="line">        <span class="comment">// 3.创建Errors对象</span></span><br><span class="line">        Errors errors = <span class="keyword">new</span> BeanPropertyBindingResult(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">        validator.validate(user, errors);</span><br><span class="line">        <span class="comment">// 4.获取MessageSource对象</span></span><br><span class="line">        MessageSource messageSource = createMessageSource();</span><br><span class="line">        <span class="comment">// 5.输出所有的错误文案</span></span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : errors.getAllErrors()) &#123;</span><br><span class="line">            String message = messageSource.getMessage(error.getCode(), error.getArguments(), Locale.getDefault());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserValodator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> User.class.equals(clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">            User user = (User) target;</span><br><span class="line">            ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;id.required&quot;</span>);</span><br><span class="line">            ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.required&quot;</span>);</span><br><span class="line">            String name = user.getName();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h2><p>Bean Validation 与 Validator适配：</p>
<ul>
<li>核心组件 - org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</li>
<li>依赖Bean Validation - JSR - 303 or JSR - 349 provider</li>
<li>Bean方法参数校验 - org.springframework.validation.beanvalidation.MethodValidationPostProcessor</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanValidationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/bean-validation-context.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Validator validator = applicationContext.getBean(Validator.class);</span></span><br><span class="line"><span class="comment">//        System.out.println(validator instanceof LocalValidatorFactoryBean);</span></span><br><span class="line">        UserProcessor userProcessor = applicationContext.getBean(UserProcessor.class);</span><br><span class="line">        userProcessor.processUser(<span class="keyword">new</span> User());</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@Validated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProcessor</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processUser</span><span class="params">(<span class="meta">@Valid</span> User user)</span> </span>&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Validated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的XML文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.jyc.thinking.in.spring.validation&quot;</span> /&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;validator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validator&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;validator&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到使用这种方式方便了很多，并且可以根据实际的需求对其进行扩展。</p>
<h2 id="面试题-12"><a href="#面试题-12" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring校验接口是哪个？"><a href="#Spring校验接口是哪个？" class="headerlink" title="Spring校验接口是哪个？"></a>Spring校验接口是哪个？</h3><p>org.springframework.validation.Validator</p>
<h3 id="Spring有哪些校验核心组件？"><a href="#Spring有哪些校验核心组件？" class="headerlink" title="Spring有哪些校验核心组件？"></a>Spring有哪些校验核心组件？</h3><ul>
<li>校验器：org.springframework.validation.Validator</li>
<li>错误收集器：org.springframework.validation.Errors</li>
<li>Java Bean错误描述：org.springframework.validation.ObjectError</li>
<li>Java Bean属性错误描述：org.springframework.validation.FieldError</li>
<li>Bean Validation适配：org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</li>
</ul>
<h3 id="请通过示例演示Spring-Bean的校验？"><a href="#请通过示例演示Spring-Bean的校验？" class="headerlink" title="请通过示例演示Spring Bean的校验？"></a>请通过示例演示Spring Bean的校验？</h3><p>// 待续…</p>
<h1 id="Spring-数据绑定"><a href="#Spring-数据绑定" class="headerlink" title="Spring 数据绑定"></a>Spring 数据绑定</h1><p>Spring数据绑定的使用场景：</p>
<ol>
<li>Spring BeanDefinition到Bean实例创建</li>
<li>Spring数据绑定（DataBinder）</li>
<li>Spring Web参数绑定（WebDataBinder）</li>
</ol>
<h2 id="Spring-数据绑定组件"><a href="#Spring-数据绑定组件" class="headerlink" title="Spring 数据绑定组件"></a>Spring 数据绑定组件</h2><ol>
<li>标准组件：<ul>
<li>org.springframework.validation.DataBinder</li>
</ul>
</li>
<li>Web组件：<ul>
<li>org.springframework.web.bind.WebDataBinder</li>
<li>org.springframework.web.bind.ServletRequestDataBinder</li>
<li>org.springframework.web.bind.support.WebRequestDataBinder</li>
<li>org.springframework.web.bind.support.WebExchangeDataBinder</li>
</ul>
</li>
</ol>
<p>DataBinder的核心属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>关联目标Bean</td>
</tr>
<tr>
<td>objectName</td>
<td>目标Bean名称</td>
</tr>
<tr>
<td>bindingResult</td>
<td>属性绑定结果</td>
</tr>
<tr>
<td>typeConverter</td>
<td>类型转化器</td>
</tr>
<tr>
<td>conversionService</td>
<td>类型转化服务</td>
</tr>
<tr>
<td>messageCodesResolver</td>
<td>校验错误文案Code处理器</td>
</tr>
<tr>
<td>validators</td>
<td>关联的Bean Validator实例集合</td>
</tr>
</tbody></table>
<p>DataBinder绑定方法bind（PropertyValues），会将PropertyValues key-Value内容映射到关联Bean（target）中的属性上。</p>
<h2 id="DataBinder元数据"><a href="#DataBinder元数据" class="headerlink" title="DataBinder元数据"></a>DataBinder元数据</h2><p>DataBinder元数据 - PropertyValues：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数据来源</td>
<td>BeanDefinition，主要来源XML资源配置BeanDefinition</td>
</tr>
<tr>
<td>数据结构</td>
<td>由一个或多个PropertyValue组成</td>
</tr>
<tr>
<td>成员结构</td>
<td>PropertyValue包含属性名称，以及属性值（包括原始值、类型转换后的值）</td>
</tr>
<tr>
<td>常见实现</td>
<td>MutablePropertyValue</td>
</tr>
<tr>
<td>Web扩展实现</td>
<td>ServletConfigPropertyValue，ServletRequestParameterPropertyValues</td>
</tr>
<tr>
<td>相关生命周期</td>
<td>InstantiationAwareBeanPostProcessor#postProcessProperties</td>
</tr>
</tbody></table>
<h2 id="DataBinder绑定控制参数"><a href="#DataBinder绑定控制参数" class="headerlink" title="DataBinder绑定控制参数"></a>DataBinder绑定控制参数</h2><p>DataBinder绑定特殊场景分析：</p>
<ul>
<li>当PropertyValues中包含名称的x的PropertyValue，目标对象B不存在x属性，当bind方法执行时，会发生什么？</li>
<li>当PropertyValues中包含名称的x的PropertyValue，目标对象B中存在x属性，当bind方法执行时，如何避免B属性x不被绑定？</li>
<li>当PropertyValues中包含x.y的PropertyValue，目标对象B中存在x属性（嵌套y属性），当bind方法执行时，会发生什么？</li>
</ul>
<p>相关的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建空白对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 1.创建DataBinder</span></span><br><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建PropertyValues</span></span><br><span class="line">        HashMap&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        source.put(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        source.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a.PropertyValues存在user中不存在的属性值</span></span><br><span class="line">        <span class="comment">// DataBinder特性一：忽略了未知的属性</span></span><br><span class="line">        source.put(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.PropertyValues存在一个嵌套属性，company.name</span></span><br><span class="line">        <span class="comment">// DataBinder特性二：支持嵌套属性</span></span><br><span class="line">        source.put(<span class="string">&quot;company.name&quot;</span>,<span class="string">&quot;jjjj&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(source);</span><br><span class="line"></span><br><span class="line">        dataBinder.bind(propertyValues);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.输出user</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DataBinder绑定控制参数：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ignoreUnknownFields</td>
<td>是否忽略未知字段，默认值：true</td>
</tr>
<tr>
<td>ignoreInvalidFields</td>
<td>是否忽略非法字段，默认值：false</td>
</tr>
<tr>
<td>autoGrowNestedPaths</td>
<td>是否自动增加嵌套路径，默认值：true</td>
</tr>
<tr>
<td>allowedFields</td>
<td>绑定字段白名单</td>
</tr>
<tr>
<td>disallowedFields</td>
<td>绑定字段黑名单</td>
</tr>
<tr>
<td>requiredFields</td>
<td>必须绑定字段</td>
</tr>
</tbody></table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建空白对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 1.创建DataBinder</span></span><br><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建PropertyValues</span></span><br><span class="line">        HashMap&lt;String, Object&gt; source = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        source.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        source.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;吉永超&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a.PropertyValues存在user中不存在的属性值</span></span><br><span class="line">        <span class="comment">// DataBinder特性一：忽略了未知的属性</span></span><br><span class="line">        source.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b.PropertyValues存在一个嵌套属性，company.name</span></span><br><span class="line">        <span class="comment">// DataBinder特性二：支持嵌套属性</span></span><br><span class="line">        source.put(<span class="string">&quot;company.name&quot;</span>, <span class="string">&quot;jjjj&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        source.put(&quot;company&quot;, new Company());</span></span><br><span class="line"><span class="comment">//        source.put(&quot;company.name&quot;,&quot;jjjj&quot;);</span></span><br><span class="line"></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.调整ignoreUnknownFields true（默认） -&gt; false</span></span><br><span class="line"><span class="comment">//        dataBinder.setIgnoreUnknownFields(false);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.调整自动增加嵌套路径true（默认） -&gt; false</span></span><br><span class="line">        dataBinder.setAutoGrowNestedPaths(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调整ignoreInvalidFields false（默认） -&gt; true</span></span><br><span class="line">        dataBinder.setIgnoreInvalidFields(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.白名单</span></span><br><span class="line">        dataBinder.setRequiredFields(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;city&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dataBinder.bind(propertyValues);</span><br><span class="line">        <span class="comment">// 输出user</span></span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.获取绑定结果（结果包含错误文案code，不会抛出异常）</span></span><br><span class="line">        BindingResult result = dataBinder.getBindingResult();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring底层Java-Beans替换实现"><a href="#Spring底层Java-Beans替换实现" class="headerlink" title="Spring底层Java Beans替换实现"></a>Spring底层Java Beans替换实现</h2><ol>
<li>Java Beans核心实现 - java.beans.BeanInfo<ul>
<li>属性（Property）<ul>
<li>java.beans.PropertyEditor</li>
</ul>
</li>
<li>方法（Method）</li>
<li>事件（Event）</li>
<li>表达式（Expression）</li>
</ul>
</li>
<li>Spring替代实现 - org.springframework.beans.BeanWrapper<ul>
<li>属性（Property）<ul>
<li>java.beans.PropertyEditor</li>
</ul>
</li>
<li>嵌套属性路径（nested path）</li>
</ul>
</li>
</ol>
<h2 id="BeanWrapper使用场景"><a href="#BeanWrapper使用场景" class="headerlink" title="BeanWrapper使用场景"></a>BeanWrapper使用场景</h2><ul>
<li>Spring底层JavaBeans基础设施的中心化接口</li>
<li>通常不会直接使用，间接用于BeanFactory和DataBinder</li>
<li>提供标准JavaBeans分析和操作，能够单独或批量存储Java Bean的属性（properties）</li>
<li>支持嵌套属性路径（nested path）</li>
<li>实现类 org.springframework.beans.BeanWrapperImpl</li>
</ul>
<h2 id="JavaBeans操作属性"><a href="#JavaBeans操作属性" class="headerlink" title="JavaBeans操作属性"></a>JavaBeans操作属性</h2><p>标准的JavaBeans是如何操作属性的？</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>java.beans.Introspector</td>
<td>JavaBeans 内省API</td>
</tr>
<tr>
<td>java.beans.BeanInfo</td>
<td>Java Bean 元信息API</td>
</tr>
<tr>
<td>java.beans.BeanDescriptor</td>
<td>Java Bean 信息描述符</td>
</tr>
<tr>
<td>java.beans.PropertyDescriptor</td>
<td>Java Bean 属性描述符</td>
</tr>
<tr>
<td>java.beans.MethodDescriptor</td>
<td>Java Bean 方法描述符</td>
</tr>
<tr>
<td>java.beans.EventSetDescriptor</td>
<td>Java Bean 事件集合描述符</td>
</tr>
</tbody></table>
<blockquote>
<p>PropertyDescriptor并不要求setter、getter方法均存在。</p>
</blockquote>
<p>可以使用如下示例进行观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBeansDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// stopClass排除（截止）类</span></span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(User.class, Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 属性描述符 PropertyDescriptor</span></span><br><span class="line">        <span class="comment">// 所有的Java类均继承 java.lang.Object方法</span></span><br><span class="line">        <span class="comment">// Class属性来自于Object#getClass() 方法</span></span><br><span class="line">        Stream.of(beanInfo.getPropertyDescriptors()).forEach(propertyDescriptor -&gt; &#123;</span><br><span class="line">            propertyDescriptor.getReadMethod(); <span class="comment">// Getter方法</span></span><br><span class="line">            propertyDescriptor.getWriteMethod(); <span class="comment">// Setter方法</span></span><br><span class="line">            System.out.println(propertyDescriptor);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输出User定义的方法 MethodDescriptor</span></span><br><span class="line">        Stream.of(beanInfo.getMethodDescriptors()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DataBinder数据校验"><a href="#DataBinder数据校验" class="headerlink" title="DataBinder数据校验"></a>DataBinder数据校验</h2><p>DataBinder与BeanWrapper的联系：</p>
<ul>
<li>bind方法生成BeanPropertyBindingResult</li>
<li>BeanPropertyBindingResult关联BeanWrapper</li>
</ul>
<h2 id="面试题-13"><a href="#面试题-13" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring数据绑定API是什么？"><a href="#Spring数据绑定API是什么？" class="headerlink" title="Spring数据绑定API是什么？"></a>Spring数据绑定API是什么？</h3><p>org.springframework.validation.DataBinder</p>
<h3 id="BeanWrapper与JavaBeans之间的关系是？"><a href="#BeanWrapper与JavaBeans之间的关系是？" class="headerlink" title="BeanWrapper与JavaBeans之间的关系是？"></a>BeanWrapper与JavaBeans之间的关系是？</h3><p>BeanWrapper是Spring底层JavaBeans基础设施的中心化接口。</p>
<h3 id="DataBinder是怎么完成属性类型转换的？"><a href="#DataBinder是怎么完成属性类型转换的？" class="headerlink" title="DataBinder是怎么完成属性类型转换的？"></a>DataBinder是怎么完成属性类型转换的？</h3><p>// …</p>
<h1 id="Spring-类型转换"><a href="#Spring-类型转换" class="headerlink" title="Spring 类型转换"></a>Spring 类型转换</h1><p>Spring类型转换的实现方案：</p>
<ol>
<li>基于JavaBeans接口的类型转换实现<ul>
<li>基于java.beans.PropertyEditor扩展</li>
</ul>
</li>
<li>Spring 3.0+ 通用类型转换实现</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>场景分析：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>基于JavaBeans接口的类型转换实现</th>
<th>Spring 3.0+通用类型转换实现</th>
</tr>
</thead>
<tbody><tr>
<td>数据绑定</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>BeanWrapper</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Bean属性类型转换</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>外部化属性类型转换</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<h2 id="基于JavaBeans接口的类型转换"><a href="#基于JavaBeans接口的类型转换" class="headerlink" title="基于JavaBeans接口的类型转换"></a>基于JavaBeans接口的类型转换</h2><ol>
<li>核心职责：<ul>
<li>将String类型转化为目标类型的对象</li>
</ul>
</li>
<li>扩展原理：<ul>
<li>Spring框架将文本内容传递到PropertyEditor实现的setAsText(String)方法</li>
<li>PropertyEditor#setAsText(String)方法实现将String类型转化为目标类型的对象</li>
<li>将目标类型的对象传入PropertyEditor#setAsValue(Object)方法</li>
<li>PropertyEditor#setAsValue(Object)方法实现需要临时存储传入对象</li>
<li>Spring框架将通过PropertyEditor#getValue()获取类型转换后的对象</li>
</ul>
</li>
</ol>
<p>我们可以模拟一下整个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToPropertiesPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.实现setAsText方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.将String类型转换成Properties类型</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> StringReader(text));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.临时存储Properties对象</span></span><br><span class="line">        setValue(properties);</span><br><span class="line">        <span class="comment">// next 获取临时Properties对象 # getValue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后观察输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyEditorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟Spring Framework的操作</span></span><br><span class="line">        <span class="comment">// 有一段文本name = &quot;吉永超&quot;;</span></span><br><span class="line">        String text = <span class="string">&quot;name = 吉永超&quot;</span>;</span><br><span class="line">        PropertyEditor propertyEditor = <span class="keyword">new</span> StringToPropertiesPropertyEditor();</span><br><span class="line">        propertyEditor.setAsText(text);</span><br><span class="line">        System.out.println(propertyEditor.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring内建PropertyEditor扩展"><a href="#Spring内建PropertyEditor扩展" class="headerlink" title="Spring内建PropertyEditor扩展"></a>Spring内建PropertyEditor扩展</h2><p>内建扩展（org.springframework.beans.propertyeditors）：</p>
<table>
<thead>
<tr>
<th>转换场景</th>
<th>实现类</th>
</tr>
</thead>
<tbody><tr>
<td>String -&gt; Byte数组</td>
<td>org.springframework.beans.propertyeditors.ByteArrayPropertyEditor</td>
</tr>
<tr>
<td>String -&gt; Char</td>
<td>org.springframework.beans.propertyeditors.CharacterEditor</td>
</tr>
<tr>
<td>String -&gt; Char 数组</td>
<td>org.springframework.beans.propertyeditors.CharArrayPropertyEditor</td>
</tr>
<tr>
<td>String -&gt; Charset</td>
<td>org.springframework.beans.propertyeditors.CharsetEditor</td>
</tr>
<tr>
<td>String -&gt; Class</td>
<td>org.springframework.beans.propertyeditors.ClassEditor</td>
</tr>
<tr>
<td>String -&gt; Currency</td>
<td>org.springframework.beans.propertyeditors.CurrencyEditor</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h2 id="自定义PropertyEditor扩展"><a href="#自定义PropertyEditor扩展" class="headerlink" title="自定义PropertyEditor扩展"></a>自定义PropertyEditor扩展</h2><p>实现步骤如下：</p>
<ol>
<li>扩展模式：<ul>
<li>扩展java.beans.PropertyEditorSupport类</li>
</ul>
</li>
<li>实现org.springframework.beans.PropertyEditorRegistrar<ul>
<li>实现registerCustomEditor（org.springframework.beans.PropertyEditorRegistry）方法</li>
<li>将PropertyEditorRegistry实现注册为Spring Bean</li>
</ul>
</li>
<li>向org.springframework.beans.PropertyEditorRegistry注册自定义PropertyEditor实现<ul>
<li>通用类型实现：registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor);</li>
<li>Java Bean属性类型实现：registerCustomEditor(Class&lt;?&gt; requiredType,  String propertyPath, PropertyEditor propertyEditor);</li>
</ul>
</li>
</ol>
<p>相关的示例，第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToPropertiesPropertyEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> <span class="keyword">implements</span> <span class="title">PropertyEditor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.实现setAsText方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">// 2.将String类型转换成Properties类型</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> StringReader(text));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.临时存储Properties对象</span></span><br><span class="line">        setValue(properties);</span><br><span class="line">        <span class="comment">// next 获取临时Properties对象 # getValue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAsText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = (Properties) getValue();</span><br><span class="line">        StringBuilder textBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            textBuilder.append(entry.getKey()).append(<span class="string">&quot;=&quot;</span>).append(entry.getValue()).append(System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步和第三步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Component // 3.将其声明为Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedPropertyEditorRegistrar</span> <span class="keyword">implements</span> <span class="title">PropertyEditorRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通用类型转换</span></span><br><span class="line">        <span class="comment">// 2.Java Bean属性类型转换</span></span><br><span class="line">        registry.registerCustomEditor(User.class, <span class="string">&quot;context&quot;</span>, <span class="keyword">new</span> StringToPropertiesPropertyEditor());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们不采用注解的方式，而是采用XML的方式进行配置，将CustomizedPropertyEditorRegistrar声明为Spring Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吉永超&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;context&quot;</span>&gt;</span> <span class="comment">&lt;!-- Properties类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                id = 1</span><br><span class="line">                name = 吉永超</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.jyc.thinking.in.spring.conversion.CustomizedPropertyEditorRegistrar&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCustomizedPropertyEditorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:/META-INF/property-editors-context.xml&quot;</span>);</span><br><span class="line">        User user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">// 关闭应用上下文</span></span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PropertyEditor的局限性"><a href="#PropertyEditor的局限性" class="headerlink" title="PropertyEditor的局限性"></a>PropertyEditor的局限性</h2><ul>
<li>违反单一原则<ul>
<li>java.beans.PropertyEditor接口职责太多，除了类型转换，还包括Java Beans事件和Java GUI交互</li>
</ul>
</li>
<li>java.beans.PropertyEditor实现类型局限<ul>
<li>来源类型只能为java.lang.String类型</li>
</ul>
</li>
<li>java.beans.PropertyEditor实现缺少类型安全<ul>
<li>除了实现类名可以表达语义，实现类无法感知目标转换类型</li>
</ul>
</li>
</ul>
<h2 id="Spring3-通用类型转换接口"><a href="#Spring3-通用类型转换接口" class="headerlink" title="Spring3 通用类型转换接口"></a>Spring3 通用类型转换接口</h2><ol>
<li>类型转换接口 - org.springframework.core.convert.converter.Converter&lt;S, T&gt;<ul>
<li>泛型参数S：来源类型，参数T：目标类型</li>
<li>核心方法：T convert(S)</li>
</ul>
</li>
<li>通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter<ul>
<li>核心方法：convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);</li>
<li>配对类型：org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</li>
<li>类型描述：org.springframework.core.convert.TypeDescriptor</li>
</ul>
</li>
</ol>
<h2 id="Spring内建类型转换器"><a href="#Spring内建类型转换器" class="headerlink" title="Spring内建类型转换器"></a>Spring内建类型转换器</h2><table>
<thead>
<tr>
<th>转换场景</th>
<th>实现类所在包名(package)</th>
</tr>
</thead>
<tbody><tr>
<td>日期/时间相关</td>
<td>org.springframework.format.datetime</td>
</tr>
<tr>
<td>Java 8 日期/时间相关</td>
<td>org.springframework.format.datetime.standard</td>
</tr>
<tr>
<td>通用实现</td>
<td>org.springframework.core.convert.support</td>
</tr>
</tbody></table>
<h2 id="Converter接口的局限性"><a href="#Converter接口的局限性" class="headerlink" title="Converter接口的局限性"></a>Converter接口的局限性</h2><ul>
<li>局限一：缺少Source Type和Target Type前置判断<ul>
<li>应对：增加org.springframework.core.convert.converter.ConditionalConverter实现</li>
</ul>
</li>
<li>局限二：仅能转换单一的Source Type和Target Type<ul>
<li>应对：使用org.springframework.core.convert.converter.GenericConverter代替</li>
</ul>
</li>
</ul>
<h2 id="GenericConverter接口"><a href="#GenericConverter接口" class="headerlink" title="GenericConverter接口"></a>GenericConverter接口</h2><p>org.springframework.core.convert.converter.GenericConverter的介绍：</p>
<table>
<thead>
<tr>
<th>核心要素</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>使用场景</td>
<td>用于”复合”类型转换场景，比如Collection、Map、数组等</td>
</tr>
<tr>
<td>转换范围</td>
<td>Set<ConvertiblePair> getConvertibleTypes()</td>
</tr>
<tr>
<td>配对类型</td>
<td>org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</td>
</tr>
<tr>
<td>转换方法</td>
<td>convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</td>
</tr>
<tr>
<td>类型描述</td>
<td>org.springframework.core.convert.TypeDescriptor</td>
</tr>
</tbody></table>
<blockquote>
<p>“复合”类型在进行转换的时候，可以利用Converter接口，对集合（或其他类型）中的元素进行转换。</p>
</blockquote>
<h2 id="优化GenericConverter接口"><a href="#优化GenericConverter接口" class="headerlink" title="优化GenericConverter接口"></a>优化GenericConverter接口</h2><p>GenericConverter局限性：</p>
<ul>
<li>缺少Source TYpe和Target Type前置判断</li>
<li>单一类型转换实现复杂</li>
</ul>
<p>GenericConverter优化接口 - ConditionalGenericConverter</p>
<ul>
<li>复合类型转换 ：org.springframework.core.convert.converter.GenericConverter</li>
<li>类型条件判断：org.springframework.core.convert.converter.ConditionalConverter</li>
</ul>
<h2 id="扩展Spring类型转换器"><a href="#扩展Spring类型转换器" class="headerlink" title="扩展Spring类型转换器"></a>扩展Spring类型转换器</h2><p>扩展的步骤：</p>
<ol>
<li>实现转换器接口<ul>
<li>org.springframework.core.convert.converter.Converter</li>
<li>org.springframework.core.convert.converter.ConverterFatory</li>
<li>org.springframework.core.convert.converter.GenericConverter</li>
</ul>
</li>
<li>注册转换器实现<ul>
<li>通过ConversionServiceFactoryBean（Spring Bean）</li>
<li>通过org.springframework.core.convert.ConversionService（API）</li>
</ul>
</li>
</ol>
<p>相关的示例如下，步骤一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesToStringConverter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Properties.class.equals(sourceType.getObjectType()) &amp;&amp; String.class.equals(targetType.getObjectType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> ConvertiblePair(Properties.class, String.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">        Properties properties = (Properties) source;</span><br><span class="line">        StringBuilder textBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            textBuilder.append(entry.getKey()).append(<span class="string">&quot;=&quot;</span>).append(entry.getValue()).append(System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:util=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&#x27;</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/util</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.jyc.thinking.in.spring.ioc.overview.dependency.domain.User&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;吉永超&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;context&quot;</span>&gt; &lt;!-- Properties类型 --&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                id = <span class="number">1</span></span><br><span class="line">                name = 吉永超</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;contextAsText&quot;</span> ref=<span class="string">&quot;context&quot;</span>/&gt; &lt;!--properties类型要转成String --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;util:properties id=<span class="string">&quot;context&quot;</span>&gt;</span><br><span class="line">        &lt;prop key=<span class="string">&quot;id&quot;</span>&gt;<span class="number">1</span>&lt;/prop&gt;</span><br><span class="line">        &lt;prop key=<span class="string">&quot;name&quot;</span>&gt;jiyongchao&lt;/prop&gt;</span><br><span class="line">    &lt;/util:properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明ConversionServiceFactoryBean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;conversionService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;converters&quot;</span> value=<span class="string">&quot;org.jyc.thinking.in.spring.conversion.PropertiesToStringConverter&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要格外注意的是，在注册ConversionServiceFactoryBean的时候，一定要指定名称为conversionService，因为在beanFactory进行查找的时候，会根据名称和类型共同查找，名称固定为conversionService。</p>
</blockquote>
<h2 id="统一类型转换服务"><a href="#统一类型转换服务" class="headerlink" title="统一类型转换服务"></a>统一类型转换服务</h2><p>org.springframework.core.convert.ConversionService说明：</p>
<table>
<thead>
<tr>
<th>实现类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GenericConversionService</td>
<td>通用ConversionService模板实现，不内置转化器实现</td>
</tr>
<tr>
<td>DefaultConversionService</td>
<td>基础ConversionService实现，内置常用转化器实现</td>
</tr>
<tr>
<td>FormattingConversionService</td>
<td>通用Formatter + GenericConversionService实现，不内置转化器和Formatter实现</td>
</tr>
<tr>
<td>DefaultFormattingConversionService</td>
<td>DefaultConversionService + 格式化 实现（如：JSR-354 Money &amp; Currency，JSR-310 Date-Time）</td>
</tr>
</tbody></table>
<h2 id="ConversionService作为依赖"><a href="#ConversionService作为依赖" class="headerlink" title="ConversionService作为依赖"></a>ConversionService作为依赖</h2><p>类型转换器底层接口 - org.springframework.beans.TypeConverter</p>
<ul>
<li>起始版本：Spring 2.0</li>
<li>核心方法 - convertlfNecessary重载方法</li>
<li>抽象实现 - org.springframework.beans.TypeConverterSupport</li>
<li>简单实现 - org.springframework.beans.SimpleTypeConverter</li>
</ul>
<p>类型转换器底层抽象实现 - org.springframework.beans.TypeConverterSupport</p>
<ul>
<li>实现接口 - org.springframework.beans.TypeConverter</li>
<li>扩展实现 - org.springframework.beans.PropertyEditorRegistrySupport</li>
<li>委派实现 - org.springframework.beans.TypeConverterDelegate</li>
</ul>
<p>类型转换器底层委派实现 - org.springframework.beans.TypeConverterDelegate</p>
<ul>
<li>构造来源 - org.springframework.beans.AbstractNestablePropertyAccessor实现<ul>
<li>org.springframework.beans.BeanWrapperImpl</li>
</ul>
</li>
<li>依赖 - java.beans.PropertyEditor实现<ul>
<li>默认内建时间 - org.springframework.beans.PropertyEditorRegistrySupport#registerDefaultEditors</li>
</ul>
</li>
<li>可选依赖 - org.springframework.core.convert.ConversionService实现</li>
</ul>
<p>整体的流程关键节点如下：</p>
<blockquote>
<p>AbstractApplicationContext -&gt; “conversionService” ConversionService Bean -&gt; configurableBeanFactory#setConversionService(conversionService) -&gt; AbstractAutowireCapableBeanFactory#instantiateBean -&gt; AbstractBeanFactory#getConversionServicee -&gt; BeanDefinition -&gt; BeanWrapper -&gt; 属性转换(数据来源：PropertyValues) -&gt; setPropertyValues(PropertyValues) -&gt; TypeConvert#convertIfNecessnary -&gt; TypeConverterDelegate -&gt; PropertyEditor or ConversionService</p>
</blockquote>
<h2 id="面试题-14"><a href="#面试题-14" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring类型转换实现有哪些？"><a href="#Spring类型转换实现有哪些？" class="headerlink" title="Spring类型转换实现有哪些？"></a>Spring类型转换实现有哪些？</h3><ol>
<li>基于JavaBeans PropertyEditor接口实现</li>
<li>Spring 3.0+通用类型转换实现</li>
</ol>
<h3 id="Spring类型转换器接口有哪些？"><a href="#Spring类型转换器接口有哪些？" class="headerlink" title="Spring类型转换器接口有哪些？"></a>Spring类型转换器接口有哪些？</h3><ul>
<li>类型转换接口 - org.springframework.core.convert.converter.Converter</li>
<li>通用类型转换接口 - org.springframework.core.convert.converter.GenericConverter</li>
<li>类型条件接口 - org.springframework.core.convert.converter.ConditionalConverter</li>
<li>综合类型转换接口 - org.springframework.core.convert.converter.ConditionalGenericConverter</li>
</ul>
<h3 id="TypeDescriptor是如何处理泛型？"><a href="#TypeDescriptor是如何处理泛型？" class="headerlink" title="TypeDescriptor是如何处理泛型？"></a>TypeDescriptor是如何处理泛型？</h3><p>// …</p>
<h1 id="Spring-泛型"><a href="#Spring-泛型" class="headerlink" title="Spring 泛型"></a>Spring 泛型</h1><h2 id="Java泛型基础"><a href="#Java泛型基础" class="headerlink" title="Java泛型基础"></a>Java泛型基础</h2><p>泛型类型：</p>
<ul>
<li>泛型类型是在类型上参数化的泛型类或接口</li>
</ul>
<p>泛型的使用场景：</p>
<ul>
<li>编译时强制类型检查</li>
<li>避免类型强转</li>
<li>实现通用算法</li>
</ul>
<p>泛型类型擦写：</p>
<ul>
<li>泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。类型擦除确保不会为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：<ul>
<li>将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为”Object”。因为，生成的字节码只包含普通类、接口和方法</li>
<li>必要时插入类型转换以保持类型安全</li>
<li>生成桥方法以保留扩展泛型类中的多态性</li>
</ul>
</li>
</ul>
<h2 id="Java-5类型接口"><a href="#Java-5类型接口" class="headerlink" title="Java 5类型接口"></a>Java 5类型接口</h2><p>Java 5类型接口 - java.lang.reflect.Type</p>
<table>
<thead>
<tr>
<th>派生类或接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>java.lang.Class</td>
<td>Java类API，如java.lang.String</td>
</tr>
<tr>
<td>java.lang.reflect.GenericArrayType</td>
<td>泛型数组类型</td>
</tr>
<tr>
<td>java.lang.reflect.ParameterizedType</td>
<td>泛型参数类型</td>
</tr>
<tr>
<td>java.lang.reflect.TypeVariable</td>
<td>泛型类型变量，如Collection<E> 中的E</td>
</tr>
<tr>
<td>java.lang.reflect.WildcardType</td>
<td>泛型统配类型</td>
</tr>
</tbody></table>
<p>Java泛型反射API：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>API</th>
</tr>
</thead>
<tbody><tr>
<td>泛型信息</td>
<td>java.lang.Class#getGenericInfo</td>
</tr>
<tr>
<td>泛型参数</td>
<td>java.lang.reflect#ParameterizedType</td>
</tr>
<tr>
<td>泛型父类</td>
<td>java.lang.Class#getGenericSuperclass</td>
</tr>
<tr>
<td>泛型接口</td>
<td>java.lang.Class#getGenericInterfaces</td>
</tr>
<tr>
<td>泛型声明</td>
<td>java.lang.reflect#GenericDeclaration</td>
</tr>
</tbody></table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericAPIDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原生类型 int long float</span></span><br><span class="line">        Class intClass = <span class="keyword">int</span>.class;</span><br><span class="line">        <span class="comment">// 数组类型 int[],Object[]</span></span><br><span class="line">        Class objectArrayClass = Object[].class;</span><br><span class="line">        <span class="comment">// 原始类型 raw types: java.lang.String</span></span><br><span class="line">        Class rawClass = String.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型参数类型 parameterized Type</span></span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) ArrayList.class.getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parameterizedType.getRawType() = java.util.AbstractList;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//泛型类型变量 Type Variable</span></span><br><span class="line"></span><br><span class="line">        System.out.println(parameterizedType.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &lt;E&gt;</span></span><br><span class="line">        Type[] typeVariables = parameterizedType.getActualTypeArguments();</span><br><span class="line"><span class="comment">//        Stream.of(parameterizedType.getActualTypeArguments()).forEach(System.out::println);</span></span><br><span class="line">        Stream.of(typeVariables).map(TypeVariable.class::cast).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring泛型类型辅助类"><a href="#Spring泛型类型辅助类" class="headerlink" title="Spring泛型类型辅助类"></a>Spring泛型类型辅助类</h2><p>核心API - org.springframework.core.GenericTypeResolver</p>
<ul>
<li><p>版本支持[2.5.2,）</p>
</li>
<li><p>处理类型相关（Type）相关方法</p>
<ul>
<li>resolveReturnType</li>
<li>resolveType</li>
</ul>
</li>
<li><p>处理泛型参数类型（ParameterizedType）相关方法</p>
<ul>
<li>resolveReturnTypeArgument</li>
<li>resolveTypeArgument</li>
<li>resolveTypeArguments</li>
</ul>
</li>
<li><p>处理泛型类型变量（TypeVariable）相关方法</p>
<ul>
<li>getTypeVariableMap</li>
</ul>
</li>
</ul>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypeResolverDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String Comparable&lt;String&gt; 具体化</span></span><br><span class="line">        displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, Comparable.class, <span class="string">&quot;getString&quot;</span>);</span><br><span class="line">        <span class="comment">// ArrayList&lt;Object&gt;是List泛型参数类型的具体化</span></span><br><span class="line">        displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, List.class, <span class="string">&quot;getList&quot;</span>);</span><br><span class="line">        <span class="comment">// StringList也是List泛型类型的具体化</span></span><br><span class="line">        displayReturnTypeGenericInfo(GenericTypeResolverDemo.class, List.class, <span class="string">&quot;getStringList&quot;</span>);</span><br><span class="line">        <span class="comment">// 具备 ParameterizedType返回。否则null</span></span><br><span class="line">        <span class="comment">// TypeVariable</span></span><br><span class="line">        Map&lt;TypeVariable, Type&gt; typeVariableMap = GenericTypeResolver.getTypeVariableMap(StringList.class);</span><br><span class="line">        System.out.println(typeVariableMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringList <span class="title">getStringList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Object&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123; <span class="comment">// 泛型参数具体化（字节码有记录）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayReturnTypeGenericInfo</span><span class="params">(Class&lt;?&gt; containingClass, Class&lt;?&gt; generic, String methodName, Class... argumentTypes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method method = containingClass.getMethod(methodName, argumentTypes);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; returnType = GenericTypeResolver.resolveReturnType(method, containingClass);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; returnTypeArgument = GenericTypeResolver.resolveReturnTypeArgument(method, generic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常规类作为方法返回值</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;GenericTypeResolver.resolveReturnType(%s,%s) = %s\n&quot;</span>, methodName, containingClass.getSimpleName(), returnType);</span><br><span class="line">        <span class="comment">// 常规类型不具备泛型参数类型List&lt;E&gt;</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;GenericTypeResolver.resolveReturnTypeArgument(%s,%s) = %s\n&quot;</span>, methodName, containingClass.getSimpleName(), returnTypeArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123; <span class="comment">// 泛型参数具体化（字节码有记录）</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型集合类型辅助类"><a href="#泛型集合类型辅助类" class="headerlink" title="泛型集合类型辅助类"></a>泛型集合类型辅助类</h2><p>核心API - org.springframework.core.GenericCollectionTypeSolver</p>
<ul>
<li><p>版本支持：[2.0,4.3]</p>
<ul>
<li>替换实现：org.springframework.core.ResolvableType</li>
</ul>
</li>
<li><p>处理Collection相关</p>
<ul>
<li>getCollection*Type</li>
<li>getMapValue*Type</li>
</ul>
<blockquote>
<p>GenericCollectionTypeSolver在高版本的Spring中已经移除，建议使用它的替换实现ResolvableType。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring方法参数封装"><a href="#Spring方法参数封装" class="headerlink" title="Spring方法参数封装"></a>Spring方法参数封装</h2><p>核心API - org.springframework.core.MethodParameter</p>
<ul>
<li><p>起始版本：[2.0,)</p>
</li>
<li><p>元信息</p>
<ul>
<li>关联的方法 - Method</li>
<li>关联的构造器 - Constuctor</li>
<li>构造器或方法参数索引 - parameterIndex</li>
<li>构造器或方法参数类型 - parameterType</li>
<li>构造器或方法参数泛型类型 - genericParameterType</li>
<li>构造器或方法参数名称 - parameterName</li>
<li>所在的类 - containingClass</li>
</ul>
<blockquote>
<p>parameterName是java8之后才存在。</p>
</blockquote>
</li>
</ul>
<h2 id="ResolvableType"><a href="#ResolvableType" class="headerlink" title="ResolvableType"></a>ResolvableType</h2><p>核心API - org.springframework.core.ResolvableType</p>
<ul>
<li>起始版本：[4.0,)</li>
<li>扮演角色：GenericTypeResolver和GenericCollectionTypeResolver替代者</li>
<li>工厂方法：for*方法</li>
<li>转换方法：as*方法</li>
<li>处理方法：resolve*方法</li>
</ul>
<p>官方给出的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(<span class="string">&quot;myMap&quot;</span>));</span><br><span class="line">      t.getSuperType(); <span class="comment">// AbstractMap&lt;Integer, List&lt;String&gt;&gt;</span></span><br><span class="line">      t.asMap(); <span class="comment">// Map&lt;Integer, List&lt;String&gt;&gt;</span></span><br><span class="line">      t.getGeneric(<span class="number">0</span>).resolve(); <span class="comment">// Integer</span></span><br><span class="line">      t.getGeneric(<span class="number">1</span>).resolve(); <span class="comment">// List</span></span><br><span class="line">      t.getGeneric(<span class="number">1</span>); <span class="comment">// List&lt;String&gt;</span></span><br><span class="line">      t.resolveGeneric(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// String</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们来使用相关的API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolvableTypeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 工厂创建</span></span><br><span class="line">        <span class="comment">// StringList &lt;- ArrayList &lt;- AbstractList &lt;- list</span></span><br><span class="line">        ResolvableType resolvableType = ResolvableType.forClass(GenericTypeResolverDemo.StringList.class);</span><br><span class="line">        resolvableType.getSuperType(); <span class="comment">//ArrayList</span></span><br><span class="line">        resolvableType.getSuperType().getSuperType(); <span class="comment">// AbstractList</span></span><br><span class="line"></span><br><span class="line">        System.out.println(resolvableType.asCollection().resolve()); <span class="comment">//获取Raw Type</span></span><br><span class="line">        System.out.println(resolvableType.asCollection().resolveGeneric(<span class="number">0</span>)); <span class="comment">// 获取泛型参数类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ResolvableType也有两个局限性，第一，ResolvableType无法处理泛型擦写，第二，ResolvableType无法处理非具体化的ParameterizedType。</p>
</blockquote>
<h2 id="面试题-15"><a href="#面试题-15" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Java泛型擦写是发生在编译时，还是运行时？"><a href="#Java泛型擦写是发生在编译时，还是运行时？" class="headerlink" title="Java泛型擦写是发生在编译时，还是运行时？"></a>Java泛型擦写是发生在编译时，还是运行时？</h3><p>运行时。</p>
<h3 id="请介绍Java-5-Type类型的派生类或接口"><a href="#请介绍Java-5-Type类型的派生类或接口" class="headerlink" title="请介绍Java 5 Type类型的派生类或接口?"></a>请介绍Java 5 Type类型的派生类或接口?</h3><p>见Java5 类型接口</p>
<h3 id="请说明ResolvableType的设计优势"><a href="#请说明ResolvableType的设计优势" class="headerlink" title="请说明ResolvableType的设计优势"></a>请说明ResolvableType的设计优势</h3><ul>
<li>简化Java5 Type API开发，屏蔽复杂API的运用，如ParameterizedType</li>
<li>不变性设计（Immutability）</li>
<li>Fluent API设计（Builder模式），链式（流式）编程</li>
</ul>
<h1 id="Spring-事件"><a href="#Spring-事件" class="headerlink" title="Spring 事件"></a>Spring 事件</h1><h2 id="Java事件-监听器编程模型"><a href="#Java事件-监听器编程模型" class="headerlink" title="Java事件/监听器编程模型"></a>Java事件/监听器编程模型</h2><ul>
<li>设计模式 - 观察者模式扩展<ul>
<li>可观者对象（消息发送者） - java.util.Observable</li>
<li>观察者 -  java.util.Observer</li>
</ul>
</li>
<li>标准化接口<ul>
<li>事件对象 - java.util.EventObject</li>
<li>事件监听器 - java.util.EventListener</li>
</ul>
</li>
</ul>
<p>使用的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable observable = <span class="keyword">new</span> EventObservable();</span><br><span class="line">        <span class="comment">// 添加观察者（监听者）</span></span><br><span class="line">        observable.addObserver(<span class="keyword">new</span> EventObserver());</span><br><span class="line">        observable.notifyObservers(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EventObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">            setChanged();</span><br><span class="line">            <span class="keyword">super</span>.notifyObservers(<span class="keyword">new</span> EventObject(arg));</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EventObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object event)</span> </span>&#123;</span><br><span class="line">            EventObject eventObject = (EventObject) event;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到事件&quot;</span> + eventObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里由于Observable的setChanged是protected，所以需要实现子类，重写这个方法，并且为了更方便的操作，我们一般也会扩充notifyObservers的实现逻辑。</p>
</blockquote>
<h2 id="面向接口的事件-监听器设计模式"><a href="#面向接口的事件-监听器设计模式" class="headerlink" title="面向接口的事件/监听器设计模式"></a>面向接口的事件/监听器设计模式</h2><p>事件/监听器场景举例</p>
<table>
<thead>
<tr>
<th>Java技术规范</th>
<th>事件接口</th>
<th>监听器接口</th>
</tr>
</thead>
<tbody><tr>
<td>JavaBeans</td>
<td>java.beans.PropertyChangeEvent</td>
<td>java.beans.PropertyChangeListener</td>
</tr>
<tr>
<td>Java AWT</td>
<td>java.awt.event.MouseEvent</td>
<td>java.awt.event.MouseListener</td>
</tr>
<tr>
<td>Java Swing</td>
<td>javax.swing.event.MenuEvent</td>
<td>javax.swing.event.MenuListener</td>
</tr>
<tr>
<td>Java Preference</td>
<td>java.util.prefs.PreferenceChangeEvent</td>
<td>java.util.prefs.PreferenceChangeListener</td>
</tr>
</tbody></table>
<h2 id="面向注解的事件-监听器设计模式"><a href="#面向注解的事件-监听器设计模式" class="headerlink" title="面向注解的事件/监听器设计模式"></a>面向注解的事件/监听器设计模式</h2><p>事件/监听器注解场景举例</p>
<table>
<thead>
<tr>
<th>Java 技术规范</th>
<th>事件注解</th>
<th>监听器注解</th>
</tr>
</thead>
<tbody><tr>
<td>Servlet 3.0+</td>
<td></td>
<td>@javax.servlet.annotation.WebListener</td>
</tr>
<tr>
<td>JPA 1.0+</td>
<td>@javax.persistence.PostPersist</td>
<td></td>
</tr>
<tr>
<td>Java Common</td>
<td>@PostConstruct</td>
<td></td>
</tr>
<tr>
<td>EJB 3.0+</td>
<td>@javax.ejb.PrePassivate</td>
<td></td>
</tr>
<tr>
<td>JSF 2.0+</td>
<td>@javax.faces.event.ListenerFor</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Spring标准事件-ApplicationEvent"><a href="#Spring标准事件-ApplicationEvent" class="headerlink" title="Spring标准事件 ApplicationEvent"></a>Spring标准事件 ApplicationEvent</h2><p>Java标准事件 java.util.EventObject扩展：</p>
<ul>
<li>扩展特性：事件发生事件戳</li>
</ul>
<p>Spring应用上下文ApplicationEvent扩展 - ApplicationContextEvent</p>
<ul>
<li>Spring应用上下文（ApplicationContext作为事件源）</li>
<li>具体实现：<ul>
<li>org.springframework.context.event.ContextClosedEvent</li>
<li>org.springframework.context.event.ContextRefreshedEvent</li>
<li>org.springframework.context.event.ContextStartedEvent</li>
<li>org.springframework.context.event.ContextStoppedEvent</li>
</ul>
</li>
</ul>
<h2 id="基于接口的Spring事件监听器"><a href="#基于接口的Spring事件监听器" class="headerlink" title="基于接口的Spring事件监听器"></a>基于接口的Spring事件监听器</h2><p>Java标准事件监听器java.util.EventListener扩展</p>
<ul>
<li>扩展接口 - org.springframework.context.ApplicationListener</li>
<li>设计特点：单一类型事件处理</li>
<li>处理方法：onApplicationEvent(ApplicationEvent event);</li>
<li>事件类型：org.springframework.context.ApplicationEvent</li>
</ul>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">        <span class="comment">// 向Spring应用上下文注册事件</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ApplicationEvent&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到Spring事件： &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        context.refresh();</span><br><span class="line">        context.start();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于注解的Spring事件监听器"><a href="#基于注解的Spring事件监听器" class="headerlink" title="基于注解的Spring事件监听器"></a>基于注解的Spring事件监听器</h2><p>Spring注解 - @org.springframework.context.event.EventListener</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>设计特点</td>
<td>支持多ApplicationEvent类型，无需接口约束</td>
</tr>
<tr>
<td>注解目标</td>
<td>方法</td>
</tr>
<tr>
<td>是否支持异步执行</td>
<td>支持</td>
</tr>
<tr>
<td>是否支持泛型类型事件</td>
<td>支持</td>
</tr>
<tr>
<td>是指支持顺序控制</td>
<td>支持，配合@Order注解控制</td>
</tr>
</tbody></table>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListenerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        GenericApplicationContext context = new GenericApplicationContext();</span></span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 将引导类作为配置类</span></span><br><span class="line">        context.register(ApplicationListenerDemo.class);</span><br><span class="line">        <span class="comment">// 方法一：基于Spring接口：向Spring应用上下文注册事件</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ApplicationEvent&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">                println(<span class="string">&quot;ApplicationListene接收到Spring事件： &quot;</span> + event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 方法二：基于Spring注解@EventListener</span></span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line">        context.start();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">       println(<span class="string">&quot;@EventListener1接收到Spring事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent1</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        println(<span class="string">&quot;@EventListener2接收到Spring事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextStartedEvent event)</span> </span>&#123;</span><br><span class="line">        println(<span class="string">&quot;@EventListener接收到Spring事件（异步）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">       println(<span class="string">&quot;@EventListener接收到Spring事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object printable)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[线程：%s] : %s\n&quot;</span>, Thread.currentThread(), printable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册Spring-ApplicationListener"><a href="#注册Spring-ApplicationListener" class="headerlink" title="注册Spring ApplicationListener"></a>注册Spring ApplicationListener</h2><ol>
<li>方法一：ApplicationListener作为Spring Bean注册</li>
<li>方法二：通过ConfigurableApplicationContext API注册</li>
</ol>
<p>第二种方式在之前我们已经讨论过了，这里第一种方式也比较容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">           println(<span class="string">&quot;MyApplicationListener接收到Spring事件&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后将MyApplicationListener标注为Spring Bean即可。</p>
<h2 id="Spring事件发布器"><a href="#Spring事件发布器" class="headerlink" title="Spring事件发布器"></a>Spring事件发布器</h2><ul>
<li>方法一：通过ApplicationEventPublisher发布Spring事件<ul>
<li>获取ApplicationEventPublisher<ul>
<li>依赖注入</li>
</ul>
</li>
</ul>
</li>
<li>方法二：通过ApplicationEventPublisher发布Spring事件<ul>
<li>获取ApplicationEventMulticaster<ul>
<li>依赖注入</li>
<li>依赖查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用ApplicationListenerDemo实现ApplicationEventPublisherAware接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> ApplicationEvent(<span class="string">&quot;hello world&quot;</span>) &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring层次性上下文事件传播"><a href="#Spring层次性上下文事件传播" class="headerlink" title="Spring层次性上下文事件传播"></a>Spring层次性上下文事件传播</h2><ul>
<li><p>发生说明</p>
<p>当Spring应用出现多层次Spring应用上下文（ApplicationContext）时，如Spring WebMVC、Spring Boot或Spring Cloud场景下，由子ApplicationContext发起Spring事件可能会传递到其Parent ApplicationContext（直到Root）的过程。</p>
</li>
<li><p>如何避免</p>
<p>定位Spring事件源（ApplicationContext）进行过滤处理</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HierarchicalSpringEventPropagateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建parent Spring应用上下文</span></span><br><span class="line">        AnnotationConfigApplicationContext parentContent = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        <span class="comment">// 2.创建current Spring应用上下文</span></span><br><span class="line">        parentContent.setId(<span class="string">&quot;parent-context&quot;</span>);</span><br><span class="line">        parentContent.register(MyListener.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.current -&gt; parent</span></span><br><span class="line">        AnnotationConfigApplicationContext currentContent = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        parentContent.setId(<span class="string">&quot;current-context&quot;</span>);</span><br><span class="line">        currentContent.setParent(parentContent);</span><br><span class="line">        currentContent.register(MyListener.class);</span><br><span class="line"></span><br><span class="line">        parentContent.refresh();</span><br><span class="line">        <span class="comment">// 这里会触发两次，因为会出发父应用上下文的事件</span></span><br><span class="line">        currentContent.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的顺序，不能颠倒</span></span><br><span class="line">        currentContent.close();</span><br><span class="line">        parentContent.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 这里必须是静态字段</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;ApplicationEvent&gt; processedEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationContextEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (processedEvents.add(event)) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;监听到 Spring应用上下文[ID：%s]事件： %s\n&quot;</span>, event.getApplicationContext().getId(), event.getClass().getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring内建事件"><a href="#Spring内建事件" class="headerlink" title="Spring内建事件"></a>Spring内建事件</h2><p>ApplicationContextEvent派生事件：</p>
<ul>
<li>ContextRefreshedEvent：Spring应用上下文就绪事件</li>
<li>ContextStartedEvent：Spring应用上下文启动事件</li>
<li>ContextStoppedEvent：Spring应用上下文停止事件</li>
<li>ContextClosedEvent：Spring应用上下文关闭事件</li>
</ul>
<h2 id="Payload事件"><a href="#Payload事件" class="headerlink" title="Payload事件"></a>Payload事件</h2><p>Spring Payload事件 - org.springframework.context.PayloadApplicationEvent</p>
<ul>
<li>使用场景：简化Spring事件发送，关注事件源主体</li>
<li>发送方法：ApplicationEventPublisher#publishEvent(Object event)</li>
</ul>
<blockquote>
<p>这个事件使用的很少，并且对于泛型的处理还存在Bug，可以使用ApplicationEventPublisher#publishEvent方法。</p>
</blockquote>
<h2 id="自定义Spring事件"><a href="#自定义Spring事件" class="headerlink" title="自定义Spring事件"></a>自定义Spring事件</h2><ol>
<li>扩展 org.springframework.context.ApplicationEvent</li>
<li>实现 org.springframework.context.ApplicationListener</li>
<li>注册 org.springframework.context.ApplicationListener</li>
</ol>
<p>我们来实现一个自定义的Spring事件，第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySpringEvent</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) <span class="keyword">super</span>.getSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，实现自定义的事件监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MySpringEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MySpringEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[线程：%s] :监听到事件 %s\n&quot;</span>, Thread.currentThread().getName(), event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，注册自定义事件监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedSpringEventDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入ApplicationEventPublisher"><a href="#依赖注入ApplicationEventPublisher" class="headerlink" title="依赖注入ApplicationEventPublisher"></a>依赖注入ApplicationEventPublisher</h2><ol>
<li>通过ApplicationEventPublisherAware回调接口</li>
<li>通过@Autowired ApplicationEventPublisher</li>
</ol>
<p>相关的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectingApplicationEventPublisherDemo</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// #3</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;the event from @Autowired ApplicationEventPublisher&quot;</span>));</span><br><span class="line">        <span class="comment">// #4</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;the event from @Autowired ApplicationContext&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(InjectingApplicationEventPublisherDemo.class);</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;the event from ApplicationEventPublisher&quot;</span>)); <span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123; <span class="comment">//#2</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="string">&quot;the event from ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖查找ApplicationEventMulticaster"><a href="#依赖查找ApplicationEventMulticaster" class="headerlink" title="依赖查找ApplicationEventMulticaster"></a>依赖查找ApplicationEventMulticaster</h2><p>查找条件：</p>
<ul>
<li>Bean名称：”applicationEventMulticaster”</li>
<li>Bean类型：org.springframework.context.event.ApplicationEventMulticaster</li>
</ul>
<p>依赖查找的细节可以在AbstractApplicationContext#initApplicationEventMulticaster中看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果不存在会直接new一个，也就是说初始化之后，ApplicationEventMulticaster不会为空</span></span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">						<span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationEventPublisher底层实现"><a href="#ApplicationEventPublisher底层实现" class="headerlink" title="ApplicationEventPublisher底层实现"></a>ApplicationEventPublisher底层实现</h2><p>底层实现：</p>
<ul>
<li>接口：org.springframework.context.event.ApplicationEventMulticaster</li>
<li>抽象类：org.springframework.context.event.AbstractApplicationEventMulticaster</li>
<li>实现类：org.springframework.context.event.SimpleApplicationEventMulticaster</li>
</ul>
<blockquote>
<p>早期的Spring，ApplicationEventPublisherAware与BeanPostProcessor不能同时使用，后面的版本采用了事件回放的机制修复了这个BUG。</p>
</blockquote>
<h2 id="同步和异步Spring事件广播"><a href="#同步和异步Spring事件广播" class="headerlink" title="同步和异步Spring事件广播"></a>同步和异步Spring事件广播</h2><p>基本实现类 - org.springframework.context.event.SimpleApplicationEventMulticaster</p>
<ul>
<li>模式切换： setTaskExecutor(Executor taskExecutor)<ul>
<li>默认模式：同步</li>
<li>异步模式：如java.util.concurrent.ThreadPoolExecutor</li>
</ul>
</li>
<li>设计缺陷：非基于接口契约编程</li>
</ul>
<p>基于编码的同步和异步事件广播示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventHandlerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh(); <span class="comment">// 初始化 ApplicationEventMulticaster</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依赖查找 ApplicationEventMulticaster</span></span><br><span class="line">        ApplicationEventMulticaster applicationEventMulticaster = context.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (applicationEventMulticaster <span class="keyword">instanceof</span> SimpleApplicationEventMulticaster) &#123;</span><br><span class="line">            SimpleApplicationEventMulticaster simpleApplicationEventMulticaster = (SimpleApplicationEventMulticaster) applicationEventMulticaster;</span><br><span class="line">            <span class="comment">//切换 taskExecutor</span></span><br><span class="line">            ExecutorService taskExecutor = Executors.newSingleThreadExecutor(<span class="keyword">new</span> CustomizableThreadFactory(<span class="string">&quot;my-spring-event-thread-pool&quot;</span>));</span><br><span class="line">            <span class="comment">// 同步 -&gt; 异步</span></span><br><span class="line">            simpleApplicationEventMulticaster.setTaskExecutor(taskExecutor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加ContextClosedEvent事件处理</span></span><br><span class="line">            applicationEventMulticaster.addApplicationListener(<span class="keyword">new</span> ApplicationListener&lt;ContextClosedEvent&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!taskExecutor.isShutdown()) &#123;</span><br><span class="line">                        taskExecutor.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这种编码的方式，还可以通过注解的方式。</p>
<p>基于注解 - org.springframework.context.event.EventListener</p>
<ul>
<li>模式切换<ul>
<li>默认模式：同步</li>
<li>异步模式：标注@org.springframework.scheduling.annotation.Async</li>
</ul>
</li>
<li>实现限制：无法直接实现同步/异步动态切换</li>
</ul>
<p>基于注解方式的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 激活Spring异步特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedAsyncEventHandlerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(AnnotatedAsyncEventHandlerDemo.class);</span><br><span class="line"></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> MySpringEventListener());</span><br><span class="line"></span><br><span class="line">        context.refresh(); <span class="comment">// 初始化 ApplicationEventMulticaster</span></span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MySpringEvent(<span class="string">&quot;hello,world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(MySpringEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[线程：%s] : %s\n&quot;</span>, Thread.currentThread().getName(), event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService taskExecutor = newSingleThreadExecutor(<span class="keyword">new</span> CustomizableThreadFactory(<span class="string">&quot;my-spring-event-thread-pool-a&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring事件异常处理"><a href="#Spring事件异常处理" class="headerlink" title="Spring事件异常处理"></a>Spring事件异常处理</h2><p>Spring3.0错误处理接口 - org.springframework.util.ErrorHandler</p>
<p>使用场景：</p>
<ul>
<li>Spring事件（Events）<ul>
<li>SimpleApplicationEventMulticaster Spring 4.1开始支持</li>
</ul>
</li>
<li>Spring本地调度（Scheduling）<ul>
<li>org.springframework.scheduling.concurrent.ConcurrentTaskScheduler</li>
<li>org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler</li>
</ul>
</li>
</ul>
<p>实现的核心代码在SimpleApplicationEventMulticaster#invokeListener：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">		ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line">		<span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				doInvokeListener(listener, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">				errorHandler.handleError(err);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			doInvokeListener(listener, event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring事件-监听实现原理"><a href="#Spring事件-监听实现原理" class="headerlink" title="Spring事件/监听实现原理"></a>Spring事件/监听实现原理</h2><p>核心类 - org.springframework.context.event.SimpleApplicationEventMulticaster</p>
<ul>
<li>设计模式：观察者模式扩展<ul>
<li>被观察者 - org.springframework.context.ApplicationListener<ul>
<li>API添加</li>
<li>依赖查找</li>
</ul>
</li>
<li>通知对象 - org.springframework.context.ApplicationEvent</li>
</ul>
</li>
<li>执行模式：同步/异步</li>
<li>异常处理：org.springframework.util.ErrorHandler</li>
<li>泛型处理：org.springframework.core.ResolvableType</li>
</ul>
<blockquote>
<p>监听事件的时候，Spring还会处理ApplicationEvent的子孙类，包含所有层次的事件。</p>
</blockquote>
<h2 id="SpringBoot事件"><a href="#SpringBoot事件" class="headerlink" title="SpringBoot事件"></a>SpringBoot事件</h2><p>SpringBoot事件</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>发生时机</th>
</tr>
</thead>
<tbody><tr>
<td>ApplicationStartingEvent</td>
<td>当SpringBoot应用已启动时</td>
</tr>
<tr>
<td>ApplicationStartedEvent</td>
<td>当SpringBoot应用已启动时</td>
</tr>
<tr>
<td>ApplicationEnvironmentPreparedEvent</td>
<td>当SpringBoot Environment实例已准备时</td>
</tr>
<tr>
<td>ApplicationPreparedEvent</td>
<td>当SpringBoot应用预备时</td>
</tr>
<tr>
<td>ApplicationReadyEvent</td>
<td>当SpringBoot应用完全可用时</td>
</tr>
<tr>
<td>ApplicationFailedEvent</td>
<td>当SpringBoot应用启动失败时</td>
</tr>
</tbody></table>
<p>SpringCloud事件</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>发生时机</th>
</tr>
</thead>
<tbody><tr>
<td>EnvironmentChangeEvent</td>
<td>当Environment示例配置属性发生变化时</td>
</tr>
<tr>
<td>HeartbeatEvent</td>
<td>当DiscoveryClient客户端发送心跳时</td>
</tr>
<tr>
<td>InstancePreRegisteredEvent</td>
<td>当服务实例注册前</td>
</tr>
<tr>
<td>InstanceRegisteredEvent</td>
<td>当服务实例注册后</td>
</tr>
<tr>
<td>RefreshEvent</td>
<td>当RefreshEndpoint被调用时</td>
</tr>
<tr>
<td>RefreshScopedRefreshedEvent</td>
<td>当Refresh Scope Bean刷新后</td>
</tr>
</tbody></table>
<h2 id="面试题-16"><a href="#面试题-16" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Spring事件核心接口-组件？"><a href="#Spring事件核心接口-组件？" class="headerlink" title="Spring事件核心接口/组件？"></a>Spring事件核心接口/组件？</h3><ul>
<li>Spring事件 - org.springframework.context.ApplicationEvent</li>
<li>Spring事件监听器 -  org.springframework.context.ApplicationListener</li>
<li>Spring事件发布器 - org.springframework.context.ApplicationEventPublisher</li>
<li>Spring事件广播器 - org.springframework.context.event.ApplicationEventMulticaster</li>
</ul>
<h2 id="Spring同步和异步事件处理的使用场景？"><a href="#Spring同步和异步事件处理的使用场景？" class="headerlink" title="Spring同步和异步事件处理的使用场景？"></a>Spring同步和异步事件处理的使用场景？</h2><ul>
<li>Spring同步事件 - 绝大部分Spring使用场景，如ContextRefreshedEvent</li>
<li>Spring异步事件 - 主要  @EventListener与@Async配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整SimpleApplicationEventMulticaster中关联的taskExecutor对象，除非使用者非常了解Spring事件机制，否则容易出现异常行为。</li>
</ul>
<h2 id="EventListener的工作原理"><a href="#EventListener的工作原理" class="headerlink" title="@EventListener的工作原理"></a>@EventListener的工作原理</h2><p>// …</p>
<h1 id="Spring-注解驱动"><a href="#Spring-注解驱动" class="headerlink" title="Spring 注解驱动"></a>Spring 注解驱动</h1><p>Spring注解驱动的编程发展的大概历程：</p>
<ol>
<li>注解驱动的启蒙时代：Spring Framework 1.x</li>
<li>注解驱动的过渡时代：Spring Framework 2.x</li>
<li>注解驱动的黄金时代：Spring Framework 3.x</li>
<li>注解驱动的完善时代：Spring Framework 4.x</li>
<li>注解驱动的当下时代：Spring Framework 5.x</li>
</ol>
<h2 id="Spring核心注解场景分类"><a href="#Spring核心注解场景分类" class="headerlink" title="Spring核心注解场景分类"></a>Spring核心注解场景分类</h2><p>Spring模式注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Repository</td>
<td>数据仓库模式注解</td>
<td>2.0</td>
</tr>
<tr>
<td>@Component</td>
<td>通用组件模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Service</td>
<td>服务模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Controller</td>
<td>Web控制器模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类模式注解</td>
<td>3.0</td>
</tr>
</tbody></table>
<p>装配注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@ImportResource</td>
<td>替换XML元素<import></td>
<td>2.5</td>
</tr>
<tr>
<td>@Import</td>
<td>导入Configuration类</td>
<td>2.5</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>扫描指定package下标注Spring模式注解的类</td>
<td>3.1</td>
</tr>
</tbody></table>
<p>依赖注入注解：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>Bean依赖注入，支持多种依赖查找方式</td>
<td>2.5</td>
</tr>
<tr>
<td>@Qualifer</td>
<td>细粒度的@Autowired依赖查找</td>
<td>2.5</td>
</tr>
</tbody></table>
<h2 id="Spring注解编程模型"><a href="#Spring注解编程模型" class="headerlink" title="Spring注解编程模型"></a>Spring注解编程模型</h2><p>编程模型概览：</p>
<ul>
<li>元注解（Meta-Annotations）</li>
<li>Spring模式注解（Stereotype Annotations）</li>
<li>Spring组合注解（Composed Annotations）</li>
<li>Spring注解属性别名和覆盖（Attribute Aliases and Overrides）</li>
</ul>
<h2 id="Spring元注解"><a href="#Spring元注解" class="headerlink" title="Spring元注解"></a>Spring元注解</h2><p>除了直接使用JDK 定义好的注解，我们还可以自定义注解，在JDK 1.5中提供了4个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：</p>
<ul>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ul>
<p> Target注解的作用是描述注解的使用范围。Reteniton注解的作用是，描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）。Documented注解的作用是，描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。Inherited注解的作用是，使被它修饰的注解具有继承性（如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解）。</p>
<p>除了以上四种标准，还有我们之前提到过的@Repeatable。</p>
<h2 id="Spring模式注解"><a href="#Spring模式注解" class="headerlink" title="Spring模式注解"></a>Spring模式注解</h2><p>模式注解是一种注解，这种注解是用于去声明应用中扮演”组件”角色的类，@Component是一种通用的组件注解，标注这个注解的类会被Spring扫描。</p>
<blockquote>
<p>由于注解无法像接口或者类一样继承，因此只能采用使用注解描述注解的方式。</p>
</blockquote>
<p>@Component”派生性”原理：</p>
<ul>
<li>核心组件 - org.springframework.context.annotation.ClassPathBeanDefinitionScanner<ul>
<li>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider</li>
</ul>
</li>
<li>资源处理 - org.springframework.core.io.support.ResourcePatternResolver</li>
<li>资源 - 类元信息<ul>
<li>org.springframework.core.type.classreading.MetadataReaderFactory</li>
</ul>
</li>
<li>类元信息 - org.springframework.core.type.ClassMetadata<ul>
<li>ASM实现 - org.springframework.core.type.classreading.ClassMetadataReadingVisitor</li>
<li>反射实现 - org.springframework.core.type.StandardAnnotationMetadata</li>
</ul>
</li>
<li>注解元信息 - org.springframework.core.type.AnnotationMetadata<ul>
<li>ASM实现 - org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</li>
<li>反射实现 - org.springframework.core.type.StandardAnnotationMetadata</li>
</ul>
</li>
</ul>
<p>我们定义一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个具有”派生性”的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 元注解，实现@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponent &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试是否生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.jyc.thinking.in.spring.annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">        context.register(ComponentScanDemo.class);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 从Spring 4.0开始支持多层次@Component派生</span></span><br><span class="line">        TestClass bean = context.getBean(TestClass.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-组合注解"><a href="#Spring-组合注解" class="headerlink" title="Spring 组合注解"></a>Spring 组合注解</h2><p>Spring组合注解（Composed Annotations）中的元注允许是Spring模式注解（Stereotype Annotation）与其他Spring功能性注解的任意组合。</p>
<p>比较典型的例子就是在SpringBoot场景中的SpringBootApplication：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring注解属性别名"><a href="#Spring注解属性别名" class="headerlink" title="Spring注解属性别名"></a>Spring注解属性别名</h2><p>注解属性的别名实际上总共有两种，一种是显性的别名，一种是隐性的别名。</p>
<p>显性的别名比较容易理解，在@ComponentScan中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>此时basePackages和value就互为显性别名，下面是隐性别名的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponentScan &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐形别名,当被元标注的注解中的属性无法表达语义的时候，就需要额外增加attribute属性，如果没有attribute属性，就表示&quot;继承&quot; <span class="doctag">@AliasFor</span>中的注解的属性</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是注解的一种&quot;多态&quot;，子注解提供了新的属性方法引用&quot;父&quot;（元）注解中的属性方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scanBasePackages -&gt; <span class="doctag">@AliasFor</span> ComponentScan.basePackages.value(显性别名)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@AliasFor</span> ComponentScan.basePackages.value 传递隐形别名,而且这种方式是支持多层次的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @AliasFor(annotation = ComponentScan.class, attribute = &quot;value&quot;)</span></span><br><span class="line"><span class="comment">//    String[] scanBasePackages() default &#123;&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring注解属性覆盖"><a href="#Spring注解属性覆盖" class="headerlink" title="Spring注解属性覆盖"></a>Spring注解属性覆盖</h2><p>属性覆盖也有两种，一种是显性覆盖，一种是隐形覆盖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@MyComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponentScan2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(annotation = MyComponentScan.class, attribute = &quot;scanBasePackages&quot;)</span></span><br><span class="line">    String[] BasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐形覆盖</span></span><br><span class="line"><span class="comment">     * 在<span class="doctag">@MyComponentScan</span>中也有scanBasePackages属性，如果注解中存在同名的就会覆盖掉元标注注解中的属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显性覆盖</span></span><br><span class="line"><span class="comment">     * packages覆盖了scanBasePackages 同时覆盖了<span class="doctag">@MyComponentScan</span>.scanBasePackages</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;scanBasePackages&quot;)</span></span><br><span class="line">    String[] packages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Enable模块驱动"><a href="#Spring-Enable模块驱动" class="headerlink" title="Spring @Enable模块驱动"></a>Spring @Enable模块驱动</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
</search>
