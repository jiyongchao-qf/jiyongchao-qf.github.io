---
title: leetcode in Java
date: 2021-06-24 15:33:37
tags:
 - 算法
top: 1
author: 吉永超
---

算法是编程世界的核心内容，本文主要记录使用Java 语言实现leetcode题目的过程。相应的源代码可以参考：[ 算法刷题示例 ](https://github.com/jiyongchao-qf/learn-leetcode)。
<!-- more -->

# 前言

如何精通一个领域？

- Chunk it up（切碎知识点）
- Deliberate practicing（刻意练习）
- Feedback（反馈）

# 数据结构

数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。数据结构优化的核心思路：1.升维 2.用空间换时间。

## 数组

数组的查询的时间复杂度O(1)，插入/删除元素的时间复杂度O(n)

## 链表

链表的查询时间时间复杂度O(n)，插入/删除元素的时间复杂度O(1)

提高链表线性表查找的效率？

1. 添加第一级索引
2. 添加第二级索引
3. 添加多级索引，总数为log2n个索引

时间复杂度为O(log2n)，空间复杂度为O(n)



## 跳表

跳表的问题：索引的维护比较困难

## 哈希表

哈希表（Hashtable），也叫散列表，是根据关键码值（keyvalue）而直接进行访问的数据结构

它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。

这个映射函数叫做散列函数（HashFunction），存放记录的数组叫做哈希表（或散列表）

## 栈

stack：先入后出；添加，删除皆为O(1)，有时候也称为FILO

## 队列

queue：先入先出；添加、删除皆为O(1)，有时候也成为FIFO

## 优先队列

优先队列(PriorityQueue)

插入操作：O(1)

取出操作：O(logN) - 按照元素的优先级取出

底层具体实现的数据结构较为多样和复杂：heap、bst、treap...



## 双端队列

双端队列（Dequeue） Double-End Queue

## 树

树和图的主要差异在于是否形成了环

1. 前序（Pre-order）：根-左-右
2. 中序（In-order）：左-根-右
3. 后序（Post-order）：左-右-根

## 二叉树

二叉搜索树，也称二叉搜索树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是一棵空树或者具有下列性质的二叉树：

1. 左子树上的`所有结点`的值均小于它的根节点的值
2. 右子树上`所有结点`的值均大于它的根结点的值
3. 依次类推：左、右子树也分别为二叉查找树（这就是重复性）

中序遍历：升序排列

插入和查询都是O(logn)

如果二叉树退化成了链表（即元素都在左子树上或者都在右子树上），那么时间复杂度会变成O（n）

树采用递归求接的主要原因：

1.节点的定义

2.可重复性（自相似性）

## 二叉搜索树



## 平衡二叉树



## 红黑树

## 堆



## 图



## 拓扑排序



## 并查集

并查集（Disjoint-set）

适用的场景：

组团、配对问题

Group or not？

并查集的操作

1、makeSet（s）：建立一个新的并查集，其中包含s个单元素集合。

2、unionSet（x，y）：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。

3、find（x）：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。

# 常用算法

## 递归



## 分治



## 回溯

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分布解决问题的过程中，当它通过尝试发现现有的分布答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能分布解答再次尝试寻找问题的答案。

回溯法通常用最简的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分布方法后宣告该问题没有答案。

在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。回溯法的典型应用：八皇后问题和数独。

## 贪心算法

贪心算法是一种在每一步选择中都采取在当前状态下最好或最有（即最有利的选择），从而希望导致结果是全局最好或最优的算法。

贪心算法与动态规划的不同在于它对于每个子问题的解决方案都做出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心法可以解决一些最优化问题，如：求图中的最小生成树、哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所求的答案。

一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个的最好办法。由于贪心法的高效性以及其所求得得答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确得问题。

## 深度优先搜索



## 广度优先搜索

## 字典树

字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不限于字符串），所以经常被搜索引擎系统用于文本词频统计。

它的优点是：最大限度地减少无谓地字符串比较，查询效率比哈希表高。

注意：字典树不是二叉树，可以有多个子节点。

基本性质：

1、结点本身不存完整单词；

2、从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；

3、每个结点的所有子节点路径代表的字符都不相同



## 二分查找



## 布隆过滤器

一个很长的二进制向量和一系列随机映射函数。布隆过来长期可以用于检索一个元素是否在一个集合中。

有点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误别率和删除困难。

当布隆过滤器把元素都插入结束之后，对于测试元素（新元素）。当它验证是否存在的时候，如果验证位是1，那么有可能在，如果是0，那么一定不存在。

## LRU Cache

LRU Cache缓存

1、记忆

2、钱包 - 储物柜

3、代码模块

两个要素：大小、替换策略

Hash Table + Double LinkedList

O(1)查询

O(1)修改、更新

LRU（最近至少使用）

## 位运算



## 排序算法



## 动态规划

动态规划（Dynamic Programming） → 动态递归

将一个复杂的问题分解为子问题：分治 + 最优子结构

关键点

动态规划和递归或者分治 没有根本上的区别（关键是看有无最优子结构）

共性：找到重复子问题

差异性：最优子结构、中途可以淘汰次优解

# 高频考题（简单）

## [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```java
public void moveZeroes(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        // 将非零数移动到index处
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[index] = nums[i];
                index++;
            }
        }

        for (int i = index; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
```



# 高频考题（中等）

## 剑指 Offer 67. 把字符串转换成整数

```java
public int myAtoi(String str) {
        int index = 0, sign = 1, total = 0;
        // 空字符串
        if (str.length() == 0) {
            return 0;
        }
        // 移除空格
        while (str.charAt(index) == ' ') {
            index++;
        }
        // 处理正负号
        if (str.charAt(index) == '+' || str.charAt(index) == '-') {
            sign = str.charAt(index) == '+' ? 1 : -1;
            index++;
        }
        // 转为数字
        while (index < str.length()) {
            int digit = str.charAt(index) - '0';
            if (digit < 0 || digit > 9) {
                break;
            }
            // 越界处理
            if (Integer.MAX_VALUE / 10 < total ||
                    (Integer.MAX_VALUE / 10 == total && Integer.MAX_VALUE % 10 < digit)) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            } else {
                total = 10 * total + digit;
                index++;
            }
        }
        return total * sign;
    }
```

